{"sol":{"prefix":"sol","body":["/**\n *    author:  math2do\n *    created: $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND\n **/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"Algorithms/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  $0\n  return 0;\n}\n"],"description":"sol"},"4d":{"prefix":"4d","body":["vector <int> dx = {-1, 0, 1, 0};\nvector <int> dy = {0, 1, 0, -1};\n"],"description":"4d"},"8d":{"prefix":"8d","body":["vector <int> dx = {-1, -1, 0, 1, 1, 1, 0, -1};\r\nvector <int> dy = {0, 1, 1, 1, 0, -1, -1, -1};"],"description":"8d"},"add":{"prefix":"add","body":["inline void add(int &a, int b) {\r\n  a += b;\r\n  if (a >= mod) {\r\n    a -= mod;\r\n  }\r\n}"],"description":"add"},"aho_corasick":{"prefix":"aho_corasick","body":["template <bool child_cnt_matter>\r\nclass aho_corasick {\r\n public:\r\n  using pbb = pair <bool, bool>;\r\n  static constexpr int size = ...\r\n  inline int hash(char ch) { \r\n    return ch - ...; \r\n  }\r\n\r\n  struct _node {\r\n   public:\r\n    bool end;\r\n    int all;\r\n    int end_cnt;\r\n    vector <_node*> c;\r\n    vector <int> cnt;\r\n    vector <int> nth;\r\n    set <int> chars;\r\n    _node *link;\r\n    _node() : end(false), all(0), end_cnt(0), link(NULL) {\r\n      c.resize(size);\r\n      cnt.resize(size);\r\n      for (int i = 0; i < size; i++) {\r\n        c[i] = NULL;\r\n        cnt[i] = 0;\r\n      } \r\n    } \r\n  };\r\n  \r\n  bool insert(_node* node, const string &str, int idx, int at) {\r\n    int len = str.length();\r\n    if (idx == len) {\r\n      if (node->end) {\r\n        //..handle no duplicates by returning false\r\n        ...\r\n      }\r\n      node->nth.push_back(at);\r\n      node->end_cnt++;\r\n      node->end = true;\r\n      return true;\r\n    }\r\n    int pos = hash(str[idx]);\r\n    _node *temp = node->c[pos];\r\n    if (temp == NULL) {\r\n      temp = new _node();\r\n      node->c[pos] = temp;\r\n      node->chars.insert(pos);\r\n    }\r\n    bool res = insert(temp, str, idx + 1, at);\r\n    if (res == true) {\r\n      node->cnt[pos]++;\r\n      node->all++;\r\n    }\r\n    return res;\r\n  } \r\n\r\n  bool insert(vector <string> &arr) {\r\n    pats.insert(pats.end(), arr.begin(), arr.end());\r\n    int m = arr.size();\r\n    if (child_cnt_matter) {\r\n      for (int ith = 0; ith < m; ith++) {\r\n        string& str = arr[ith];\r\n        insert(root, str, 0, n + ith);\r\n      }\r\n      n += m;\r\n      return true;\r\n    }\r\n\r\n    //..insertion with duplicates\r\n    for (int ith = 0; ith < m; ith++) {\r\n      _node* crawl = root;\r\n      string& str = arr[ith];\r\n      int len = str.length();\r\n      for (int idx = 0; idx < len; idx++) {\r\n        int pos = hash(str[idx]);\r\n        if (!crawl->c[pos]) {\r\n          crawl->c[pos] = new _node();\r\n          crawl->chars.insert(pos);\r\n        }\r\n        crawl->cnt[pos]++;\r\n        crawl->all++;\r\n        crawl = crawl->c[pos];\r\n      }\r\n      crawl->end_cnt++;\r\n      crawl->nth.push_back(n + ith);\r\n      crawl->end = true;\r\n    }\r\n    n += m;\r\n    return true;\r\n  }\r\n  bool insert(const string& str) {\r\n    vector <string> arr(1, str);\r\n    bool res = insert(arr);\r\n    return res;\r\n  } \r\n\r\n  bool find(const string &str) {\r\n    _node* crawl = root;\r\n    int len = str.length();\r\n    for (int idx = 0; idx < len; idx++) {\r\n      int pos = hash(str[idx]);\r\n      if (!crawl->c[pos]) {\r\n        return false;\r\n      }\r\n      crawl = crawl->c[pos];\r\n    }\r\n    if (crawl->end) return true;\r\n    return false;\r\n  }\r\n\r\n  //..first = was present, second = is child subtree completely removed\r\n  pbb remove(_node* node, const string &str, int idx) {\r\n    int len = str.length();\r\n    if (node == NULL) return {false, false};\r\n    if (idx == len) {\r\n      if (!node->end) return {false, false};\r\n      if (node->all == 0) {\r\n        delete node;\r\n        return {true, true};\r\n      }\r\n      node->end_cnt--;     // deleting only one of same words\r\n      node->end_cnt = 0 .. // deleting all same words\r\n      if (node->end_cnt == 0) {\r\n        node->end = false;\r\n      }\r\n      return {true, false};\r\n    }\r\n\r\n    int pos = hash(str[idx]);\r\n    _node* temp = node->c[pos];\r\n    if (temp == NULL) return {false, false};\r\n    pbb res = remove(temp, str, idx + 1);\r\n    if (res.first) {\r\n      if (res.second) {\r\n        node->c[pos] = NULL;\r\n      }\r\n      node->cnt[pos]--;\r\n      node->all--;\r\n      if (node->all == 0) {\r\n        delete node;\r\n        return {true, true};\r\n      }\r\n      return {true, false};\r\n    }\r\n    return res;\r\n  }\r\n\r\n  bool remove(const string& str) {\r\n    pbb res = remove(root, str, 0);\r\n    return res.first;\r\n  }\r\n\r\n  //..very much similar to lps pattern matching\r\n  inline void Move(_node* &temp, int pos) {\r\n    while (!temp->c[pos]) {\r\n      temp = temp->link;\r\n    }\r\n    temp = temp->c[pos];\r\n  }\r\n\r\n  void build() {\r\n    queue <_node*> q;\r\n    for (int pos = 0; pos < size; pos++) {\r\n      if (root->c[pos]) {\r\n        q.push(root->c[pos]);\r\n        root->c[pos]->link = root;\r\n      } else {\r\n        root->c[pos] = root;\r\n      } \r\n    }\r\n        \r\n    while (!q.empty()) {\r\n      int level = (int) q.size();\r\n      while (level--) {\r\n        _node* u = q.front(); q.pop();\r\n        for (int pos : u->chars) {  \r\n          q.push(u->c[pos]);\r\n          _node* temp = u->link;\r\n          Move(temp, pos);\r\n          u->c[pos]->link = temp; \r\n          u->c[pos]->nth.insert(u->c[pos]->nth.end(), (temp->nth).begin(), (temp->nth).end());\r\n        } \r\n      }\r\n    } \r\n  } \r\n\r\n  vector <vector <int>> match(const string &txt) {\r\n    int len = txt.length();\r\n    _node* temp = root;\r\n    vector <vector <int>> ans(n);\r\n    for  (int idx = 0; idx < len; idx++) {\r\n      int pos = hash(txt[idx]);\r\n      Move(temp, pos);\r\n      for (int ith : temp->nth) {\r\n        int m = pats[ith].length();\r\n        ans[ith].push_back(idx + 1 - m);\r\n      } \r\n    }\r\n    return ans;\r\n    // ans[i] contains first indexing where ith patthern started matching\r\n  } \r\n\r\n  vector <string> pats;\r\n  int n;\r\n  _node* root;\r\n  aho_corasick() {\r\n    root = new _node();\r\n    root->link = root; \r\n    n = 0;\r\n  }\r\n};\r\n\r\n/*\r\naho_corasick<true> ac;\r\nac.insert(pat);\r\nac.build();\r\nvector <vector <int>> match = ac.match(txt);\r\n*/"],"description":"aho_corasick"},"angle":{"prefix":"angle","body":["auto angle = [&] (int h, int m) {\r\n  if (h == 12) h = 0;  \r\n  if (m == 60) m = 0;  \r\n  double ang_h = (double) 0.5 * (h * 60 + m);\r\n  double ang_m = (double) 6.0 * m;\r\n  double ang = abs(ang_h - ang_m);\r\n  if (ang > 180.0) {\r\n    ang = 360 - ang;\r\n  }\r\n  return ang;\r\n};"],"description":"angle"},"area":{"prefix":"area","body":["double area(vector <Point> &arr) {\r\n  int n = arr.size();\r\n  double area = 0.0;   \r\n  int j = n - 1;\r\n  for (int i = 0; i < n; i++) { \r\n    area += (arr[j].x + arr[i].x) * (arr[j].y - arr[i].y);\r\n    j = i; \r\n  } \r\n  return abs(area / 2.0); \r\n}"],"description":"area"},"arr":{"prefix":"arr","body":["  for (int i = 0; i < n; i++) {\r\n\r\n  } "],"description":"arr"},"articulation":{"prefix":"articulation","body":["template <typename T>\r\nvector <bool> articulation(dfs_undigraph<T> &g) {\r\n  g.dfs_all();\r\n  vector<bool> art(g.n, false);\r\n  \r\n  for (int v = 0; v < g.n; v++) {\r\n    int u = g.pv[v];\r\n    if (u == -1) continue;\r\n    \r\n    // u -- root node, check child cnt\r\n    if (g.pv[u] == -1) {\r\n      if (g.cnt[u] > 1) {\r\n        art[u] = true;\r\n      }\r\n      continue;\r\n    }\r\n    // u -- v is a proper edge\r\n    if (g.min_depth[v] >= g.depth[u]) {\r\n      art[u] = true;\r\n    } \r\n  }\r\n  \r\n  return art;\r\n}\r\n\r\ntemplate <typename T>\r\nvector <int> articulation(const undigraph <T> &g) {\r\n  vector <bool> seen(g.n, false);\r\n  vector <int> low(g.n, 0);\r\n  vector <int> dis(g.n, 0);\r\n  vector <int> pv(g.n, -1);\r\n  vector <bool> art(g.n, false);\r\n  int timer = 0;\r\n\r\n  function <void(int)> dfs = [&](int u) {\r\n    seen[u] = true;\r\n    dis[u] = low[u] = ++timer;\r\n    int child_cnt = 0;\r\n    for (int id : g.g[u]) {\r\n      int v = g.edges[id].from ^ g.edges[id].to ^ u;\r\n      if (v == pv[u]) continue;\r\n      \r\n      if (!seen[v]) {\r\n        child_cnt++;\r\n        pv[v] = u;\r\n        dfs(v);\r\n        low[u] = min(low[u], low[v]);\r\n        if (pv[u] == -1 && child_cnt > 1) {\r\n          art[u] = true;\r\n        }\r\n        if (pv[u] != -1 && low[v] >= dis[u]) {\r\n          art[u] = true;\r\n        }\r\n      } else {\r\n        low[u] = min(low[u], dis[v]);\r\n      }\r\n    }\r\n  };\r\n  dfs(0);\r\n  vector <int> ans;\r\n  for (int i = 0; i < g.n; i++) {\r\n    if (art[i]) {\r\n      ans.push_back(i);\r\n    } \r\n  } \r\n\r\n  return ans;\r\n  // returns sorted list of weak vertices\r\n} \r\n"],"description":"articulation"},"bellman_ford":{"prefix":"bellman_ford","body":["template <typename T>\r\nvector <T> bellman_ford(const graph<T> &g, int from, bool& neg) {\r\n  neg = false;\r\n  T inf = numeric_limits<T>::max();\r\n  vector <T> dist(g.n, inf);\r\n  dist[from] = 0;\r\n\r\n  auto relax = [&](auto &e) -> bool {\r\n    bool relaxed = false;\r\n    int u = e.from;\r\n    int v = e.to;\r\n    int w = e.cost;\r\n    if (dist[u] != inf && dist[u] + w < dist[v]) {\r\n      dist[v] = dist[u] + w;\r\n      relaxed = true;\r\n    }\r\n    return relaxed;\r\n  };\r\n\r\n  //relax all edges g.n - 1 times\r\n  for (int qq = 1; qq <= g.n - 1; qq++) {\r\n    for (auto &e : g.edges) {\r\n      relax(e);\r\n    }\r\n  } \r\n\r\n  //if it relaxes more, then it contains negative cycle\r\n  for (auto &e : g.edges) {\r\n    if (relax(e)) {\r\n      neg = true;\r\n      goto end;\r\n    } \r\n  }\r\n  end : {\r\n    return dist;\r\n  }\r\n  //dist[i] = distance to 'i' from 'from', inf if not reachable\r\n  //neg = true if negative cycle is present\r\n}\r\n"],"description":"bellman_ford"},"bfs":{"prefix":"bfs","body":["auto bfs = [&](int from) {\r\n  vector <bool> seen(g.n, false);\r\n  vector <int> dist(g.n, numeric_limits<T>::max());\r\n  queue <int> q;\r\n  q.push(from);\r\n  seen[from] = true;\r\n  dist[from] = 0;\r\n  int depth = 0;\r\n  while (!q.empty()) {\r\n    int size = (int) q.size();\r\n    while (size--) {\r\n      int u = q.front(); q.pop();\r\n      dist[u] = depth;\r\n      for (int id : g.g[u]) {\r\n        int v = g.edges[id].from ^ g.edges[id].to ^ u;\r\n        if (!seen[v]) {\r\n          seen[v] = true;\r\n          q.push(v);\r\n        }\r\n      } \r\n    }\r\n    depth += 1;\r\n  }\r\n  return dist;\r\n};"],"description":"bfs"},"bicone":{"prefix":"bicone","body":["template <typename T>\r\nvector<int> find_bicone(dfs_undigraph<T> &g, int &cnt) {\r\n  g.dfs_all();\r\n  vector<int> vertex_comp(g.n);\r\n  cnt = 0;\r\n  for (int i : g.order) {\r\n    if (g.pv[i] == -1 || g.min_depth[i] == g.depth[i]) {\r\n      vertex_comp[i] = cnt++;\r\n    } else {\r\n      vertex_comp[i] = vertex_comp[g.pv[i]];\r\n    }\r\n  }\r\n  return vertex_comp;\r\n}"],"description":"bicone"},"bigint":{"prefix":"bigint","body":["namespace BigInteger {\r\n  const int base = 1000000000;\r\n  const int base_digits = 9;\r\n   \r\n  struct bigint {\r\n    vector<int> z;\r\n    int sign;\r\n   \r\n    bigint() : sign(1) {}\r\n   \r\n    bigint(long long v) {\r\n      *this = v;\r\n    }\r\n   \r\n    bigint(const string &s) {\r\n      read(s);\r\n    }\r\n   \r\n    void operator=(const bigint &v) {\r\n      sign = v.sign;\r\n      z = v.z;\r\n    }\r\n   \r\n    void operator=(long long v) {\r\n      sign = 1;\r\n      if (v < 0) {\r\n        sign = -1, v = -v;\r\n      }\r\n      z.clear();\r\n      for (; v > 0; v = v / base) {\r\n        z.push_back((int) (v % base));\r\n      }\r\n    }\r\n   \r\n    bigint operator+(const bigint &v) const {\r\n      if (sign == v.sign) {\r\n        bigint res = v;\r\n        for (int i = 0, carry = 0; i < (int) max(z.size(), v.z.size()) || carry; ++i) {\r\n          if (i == (int) res.z.size()) {\r\n            res.z.push_back(0);\r\n          }\r\n          res.z[i] += carry + (i < (int) z.size() ? z[i] : 0);\r\n          carry = res.z[i] >= base;\r\n          if (carry) {\r\n            res.z[i] -= base;\r\n          }\r\n        }\r\n        return res;\r\n      } else {\r\n        return *this - (-v);\r\n      }\r\n    }\r\n   \r\n    bigint operator-(const bigint &v) const {\r\n      if (sign == v.sign) {\r\n        if (abs() >= v.abs()) {\r\n          bigint res = *this;\r\n          for (int i = 0, carry = 0; i < (int) v.z.size() || carry; ++i) {\r\n            res.z[i] -= carry + (i < (int) v.z.size() ? v.z[i] : 0);\r\n            carry = res.z[i] < 0;\r\n            if (carry) {\r\n              res.z[i] += base;\r\n            }\r\n          }\r\n          res.trim();\r\n          return res;\r\n        } else {\r\n          return -(v - *this);\r\n        }\r\n      } else {\r\n        return *this + (-v);\r\n      }\r\n    }\r\n   \r\n    void operator*=(int v) {\r\n      if (v < 0) {\r\n        sign = -sign, v = -v;\r\n      }\r\n      for (int i = 0, carry = 0; i < (int) z.size() || carry; ++i) {\r\n        if (i == (int) z.size()) {\r\n          z.push_back(0);\r\n        }\r\n        long long cur = (long long) z[i] * v + carry;\r\n        carry = (int) (cur / base);\r\n        z[i] = (int) (cur % base);\r\n        //asm(\"divl %%ecx\" : \"=a\"(carry), \"=d\"(a[i]) : \"A\"(cur), \"c\"(base));\r\n      }\r\n      trim();\r\n    }\r\n   \r\n    bigint operator*(int v) const {\r\n      bigint res = *this;\r\n      res *= v;\r\n      return res;\r\n    }\r\n   \r\n    friend pair<bigint, bigint> divmod(const bigint &a1, const bigint &b1) {\r\n      int norm = base / (b1.z.back() + 1);\r\n      bigint a = a1.abs() * norm;\r\n      bigint b = b1.abs() * norm;\r\n      bigint q, r;\r\n      q.z.resize(a.z.size());\r\n      for (int i = a.z.size() - 1; i >= 0; i--) {\r\n        r *= base;\r\n        r += a.z[i];\r\n        int s1 = b.z.size() < r.z.size() ? r.z[b.z.size()] : 0;\r\n        int s2 = b.z.size() - 1 < r.z.size() ? r.z[b.z.size() - 1] : 0;\r\n        int d = (int) (((long long) s1 * base + s2) / b.z.back());\r\n        r -= b * d;\r\n        while (r < 0) {\r\n          r += b, --d;\r\n        }\r\n        q.z[i] = d;\r\n      }\r\n      q.sign = a1.sign * b1.sign;\r\n      r.sign = a1.sign;\r\n      q.trim();\r\n      r.trim();\r\n      return make_pair(q, r / norm);\r\n    }\r\n   \r\n    friend bigint sqrt(const bigint &a1) {\r\n      bigint a = a1;\r\n      while (a.z.empty() || (int) a.z.size() % 2 == 1) {\r\n        a.z.push_back(0);\r\n      }\r\n      int n = a.z.size();\r\n      int firstDigit = (int) sqrt((long long) a.z[n - 1] * base + a.z[n - 2]);\r\n      int norm = base / (firstDigit + 1);\r\n      a *= norm;\r\n      a *= norm;\r\n      while (a.z.empty() || (int) a.z.size() % 2 == 1) {\r\n        a.z.push_back(0);\r\n      }\r\n      bigint r = (long long) a.z[n - 1] * base + a.z[n - 2];\r\n      firstDigit = (int) sqrt((long long) a.z[n - 1] * base + a.z[n - 2]);\r\n      int q = firstDigit;\r\n      bigint res;\r\n      for (int j = n / 2 - 1; j >= 0; j--) {\r\n        for (;; --q) {\r\n          bigint r1 =\r\n            (r - (res * 2 * base + q) * q) * base * base +\r\n            (j > 0 ? (long long) a.z[2 * j - 1] * base + a.z[2 * j - 2] : 0);\r\n          if (r1 >= 0) {\r\n            r = r1;\r\n            break;\r\n          }\r\n        }\r\n        res *= base;\r\n        res += q;\r\n        if (j > 0) {\r\n          int d1 = res.z.size() + 2 < r.z.size() ? r.z[res.z.size() + 2] : 0;\r\n          int d2 = res.z.size() + 1 < r.z.size() ? r.z[res.z.size() + 1] : 0;\r\n          int d3 = res.z.size() < r.z.size() ? r.z[res.z.size()] : 0;\r\n          q = (int) (((long long) d1 * base * base + (long long) d2 * base + d3) / (firstDigit * 2));\r\n        }\r\n      }\r\n      res.trim();\r\n      return res / norm;\r\n    }\r\n   \r\n    bigint operator/(const bigint &v) const {\r\n      return divmod(*this, v).first;\r\n    }\r\n   \r\n    bigint operator%(const bigint &v) const {\r\n      return divmod(*this, v).second;\r\n    }\r\n   \r\n    void operator/=(int v) {\r\n      if (v < 0) {\r\n        sign = -sign, v = -v;\r\n      }\r\n      for (int i = z.size() - 1, rem = 0; i >= 0; --i) {\r\n        long long cur = z[i] + (long long) rem * base;\r\n        z[i] = (int) (cur / v);\r\n        rem = (int) (cur % v);\r\n      }\r\n      trim();\r\n    }\r\n   \r\n    bigint operator/(int v) const {\r\n      bigint res = *this;\r\n      res /= v;\r\n      return res;\r\n    }\r\n   \r\n    int operator%(int v) const {\r\n      if (v < 0) {\r\n        v = -v;\r\n      }\r\n      int m = 0;\r\n      for (int i = z.size() - 1; i >= 0; --i) {\r\n        m = (int) (((long long) m * base + z[i]) % v);\r\n      }\r\n      return m * sign;\r\n    }\r\n   \r\n    void operator+=(const bigint &v) {\r\n      *this = *this + v;\r\n    }\r\n    void operator-=(const bigint &v) {\r\n      *this = *this - v;\r\n    }\r\n    void operator*=(const bigint &v) {\r\n      *this = *this * v;\r\n    }\r\n    void operator/=(const bigint &v) {\r\n      *this = *this / v;\r\n    }\r\n   \r\n    bool operator<(const bigint &v) const {\r\n      if (sign != v.sign) {\r\n        return sign < v.sign;\r\n      }\r\n      if (z.size() != v.z.size()) {\r\n        return z.size() * sign < v.z.size() * v.sign;\r\n      }\r\n      for (int i = z.size() - 1; i >= 0; i--) {\r\n        if (z[i] != v.z[i]) {\r\n          return z[i] * sign < v.z[i] * sign;\r\n        }\r\n      }\r\n      return false;\r\n    }\r\n   \r\n    bool operator>(const bigint &v) const {\r\n      return v < *this;\r\n    }\r\n    bool operator<=(const bigint &v) const {\r\n      return !(v < *this);\r\n    }\r\n    bool operator>=(const bigint &v) const {\r\n      return !(*this < v);\r\n    }\r\n    bool operator==(const bigint &v) const {\r\n      return !(*this < v) && !(v < *this);\r\n    }\r\n    bool operator!=(const bigint &v) const {\r\n      return *this < v || v < *this;\r\n    }\r\n   \r\n    void trim() {\r\n      while (!z.empty() && z.back() == 0) {\r\n        z.pop_back();\r\n      }\r\n      if (z.empty()) {\r\n        sign = 1;\r\n      }\r\n    }\r\n   \r\n    bool isZero() const {\r\n      return z.empty() || ((int) z.size() == 1 && !z[0]);\r\n    }\r\n   \r\n    bigint operator-() const {\r\n      bigint res = *this;\r\n      res.sign = -sign;\r\n      return res;\r\n    }\r\n   \r\n    bigint abs() const {\r\n      bigint res = *this;\r\n      res.sign *= res.sign;\r\n      return res;\r\n    }\r\n   \r\n    long long longValue() const {\r\n      long long res = 0;\r\n      for (int i = z.size() - 1; i >= 0; i--) {\r\n        res = res * base + z[i];\r\n      }\r\n      return res * sign;\r\n    }\r\n   \r\n    friend bigint gcd(const bigint &a, const bigint &b) {\r\n      return b.isZero() ? a : gcd(b, a % b);\r\n    }\r\n    friend bigint lcm(const bigint &a, const bigint &b) {\r\n      return a / gcd(a, b) * b;\r\n    }\r\n   \r\n    void read(const string &s) {\r\n      sign = 1;\r\n      z.clear();\r\n      int pos = 0;\r\n      while (pos < (int) s.size() && (s[pos] == '-' || s[pos] == '+')) {\r\n        if (s[pos] == '-') {\r\n          sign = -sign;\r\n        }\r\n        ++pos;\r\n      }\r\n      for (int i = s.size() - 1; i >= pos; i -= base_digits) {\r\n        int x = 0;\r\n        for (int j = max(pos, i - base_digits + 1); j <= i; j++) {\r\n          x = x * 10 + s[j] - '0';\r\n        }\r\n        z.push_back(x);\r\n      }\r\n      trim();\r\n    }\r\n   \r\n    friend istream &operator>>(istream &stream, bigint &v) {\r\n      string s;\r\n      stream >> s;\r\n      v.read(s);\r\n      return stream;\r\n    }\r\n   \r\n    friend ostream &operator<<(ostream &stream, const bigint &v) {\r\n      if (v.sign == -1) {\r\n        stream << '-';\r\n      }\r\n      stream << (v.z.empty() ? 0 : v.z.back());\r\n      for (int i = v.z.size() - 2; i >= 0; --i) {\r\n        stream << setw(base_digits) << setfill('0') << v.z[i];\r\n      }\r\n      return stream;\r\n    }\r\n   \r\n    static vector<int> convert_base(const vector<int> &a, int old_digits, int new_digits) {\r\n      vector<long long> p(max(old_digits, new_digits) + 1);\r\n      p[0] = 1;\r\n      for (int i = 1; i < (int) p.size(); i++) {\r\n        p[i] = p[i - 1] * 10;\r\n      }\r\n      vector<int> res;\r\n      long long cur = 0;\r\n      int cur_digits = 0;\r\n      for (int i = 0; i < (int) a.size(); i++) {\r\n        cur += a[i] * p[cur_digits];\r\n        cur_digits += old_digits;\r\n        while (cur_digits >= new_digits) {\r\n          res.push_back((int) (cur % p[new_digits]));\r\n          cur /= p[new_digits];\r\n          cur_digits -= new_digits;\r\n        }\r\n      }\r\n      res.push_back((int) cur);\r\n      while (!res.empty() && res.back() == 0) {\r\n        res.pop_back();\r\n      }\r\n      return res;\r\n    }\r\n   \r\n    typedef vector<long long> vll;\r\n   \r\n    static vll karatsubaMultiply(const vll &a, const vll &b) {\r\n      int n = a.size();\r\n      vll res(n + n);\r\n      if (n <= 32) {\r\n        for (int i = 0; i < n; i++) {\r\n          for (int j = 0; j < n; j++) {\r\n            res[i + j] += a[i] * b[j];\r\n          }\r\n        }\r\n        return res;\r\n      }\r\n      int k = n >> 1;\r\n      vll a1(a.begin(), a.begin() + k);\r\n      vll a2(a.begin() + k, a.end());\r\n      vll b1(b.begin(), b.begin() + k);\r\n      vll b2(b.begin() + k, b.end());\r\n      vll a1b1 = karatsubaMultiply(a1, b1);\r\n      vll a2b2 = karatsubaMultiply(a2, b2);\r\n      for (int i = 0; i < k; i++) {\r\n        a2[i] += a1[i];\r\n      }\r\n      for (int i = 0; i < k; i++) {\r\n        b2[i] += b1[i];\r\n      }\r\n      vll r = karatsubaMultiply(a2, b2);\r\n      for (int i = 0; i < (int) a1b1.size(); i++) {\r\n        r[i] -= a1b1[i];\r\n      }\r\n      for (int i = 0; i < (int) a2b2.size(); i++) {\r\n        r[i] -= a2b2[i];\r\n      }\r\n      for (int i = 0; i < (int) r.size(); i++) {\r\n        res[i + k] += r[i];\r\n      }\r\n      for (int i = 0; i < (int) a1b1.size(); i++) {\r\n        res[i] += a1b1[i];\r\n      }\r\n      for (int i = 0; i < (int) a2b2.size(); i++) {\r\n        res[i + n] += a2b2[i];\r\n      }\r\n      return res;\r\n    }\r\n   \r\n    bigint operator*(const bigint &v) const {\r\n      vector<int> a6 = convert_base(this->z, base_digits, 6);\r\n      vector<int> b6 = convert_base(v.z, base_digits, 6);\r\n      vll a(a6.begin(), a6.end());\r\n      vll b(b6.begin(), b6.end());\r\n      while (a.size() < b.size()) {\r\n        a.push_back(0);\r\n      }\r\n      while (b.size() < a.size()) {\r\n        b.push_back(0);\r\n      }\r\n      while (a.size() & (a.size() - 1)) {\r\n        a.push_back(0);\r\n        b.push_back(0);\r\n      }\r\n      vll c = karatsubaMultiply(a, b);\r\n      bigint res;\r\n      res.sign = sign * v.sign;\r\n      for (int i = 0, carry = 0; i < (int) c.size(); i++) {\r\n        long long cur = c[i] + carry;\r\n        res.z.push_back((int) (cur % 1000000));\r\n        carry = (int) (cur / 1000000);\r\n      }\r\n      res.z = convert_base(res.z, 6, base_digits);\r\n      res.trim();\r\n      return res;\r\n    }\r\n  };\r\n} \r\nusing big = BigInteger::bigint;"],"description":"bigint"},"bridge":{"prefix":"bridge","body":["// import dfs_undigraph first\r\n\r\ntemplate <typename T>\r\nvector<bool> find_bridges(dfs_undigraph<T> &g) {\r\n  g.dfs_all();\r\n  vector<bool> bridge(g.edges.size(), false);\r\n  for (int i = 0; i < g.n; i++) {\r\n    if (g.pv[i] != -1 && g.min_depth[i] == g.depth[i]) {\r\n      bridge[g.pe[i]] = true;\r\n    }\r\n  }\r\n  return bridge;\r\n}\r\n\r\n// delete above when this is tested\r\ntemplate <typename T>\r\nvector<bool> find_bridges(dfs_undigraph<T> &g) {\r\n  g.dfs_all();\r\n  vector<bool> bridge(g.edges.size(), false);\r\n  for (int v = 0; v < g.n; v++) {\r\n    int u = g.pv[v];\r\n    if (u == -1) continue;\r\n    \r\n    if (g.min_depth[v] > g.depth[u]) {\r\n      bridge[g.pe[v]] = true;\r\n    }\r\n  }\r\n  return bridge;\r\n}\r\n\r\n\r\ntemplate <typename T>\r\nvector <int> bridge(const undigraph <T> &g) {\r\n  vector <bool> seen(g.n, false);\r\n  vector <int> low(g.n, 0);\r\n  vector <int> dis(g.n, 0);\r\n  vector <int> pv(g.n, -1);\r\n  int timer = 0;\r\n  vector <int> ans;\r\n  function <void(int)> dfs = [&](int u) {\r\n    seen[u] = true;\r\n    dis[u] = low[u] = ++timer;\r\n    for (int id : g.g[u]) {\r\n      int v = g.edges[id].from ^ g.edges[id].to ^ u;\r\n      if (v == pv[u]) continue;\r\n      \r\n      if (!seen[v]) {\r\n        pv[v] = u;\r\n        dfs(v);\r\n        low[u] = min(low[u], low[v]);\r\n        if (low[v] > dis[u]) {\r\n          ans.push_back(id);\r\n        }\r\n      } else {\r\n        low[u] = min(low[u], dis[v]);\r\n      }\r\n    }\r\n  };\r\n  dfs(0);\r\n  return ans;\r\n  // return edge id's of bridges\r\n} \r\n"],"description":"bridge"},"calendar":{"prefix":"calendar","body":["vector <string> week = {\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"};\r\nvector <string> month = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"};\r\nvector <int> day = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\r\n\r\nbool leap(int year) {\r\n  if (((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0)) {\r\n    return true;\r\n  }\r\n  return false; \r\n}\r\n"],"description":"calendar"},"can_palindrome":{"prefix":"can_palindrome","body":["bool can_palindrome(const string &str, int n) {\r\n  vector <int> fre(26, 0);\r\n  for (int i = 0; i < n; i++) {\r\n    fre[str[i] - 'a']++;\r\n  }\r\n  pair <char, int> odd = {'0', 0};\r\n  for (int i = 0; i < 26; i++) {\r\n    if (fre[i] > 0) {\r\n      if (fre[i] % 2 == 1) {\r\n        if (odd.second == 0) {\r\n          odd.second = 1;\r\n          odd.first = (char)(i + 'a');\r\n        } else {\r\n          return false;\r\n        } \r\n      }\r\n    } \r\n  }\r\n  if (odd.second == 1) {\r\n    if (n % 2 == 0) return false; \r\n  } \r\n  return true;\r\n}"],"description":"can_palindrome"},"catalan":{"prefix":"catalan","body":["const int N = 100;\r\nvector <long long> dp(N + 1);\r\nauto calc = [&] () {\r\n  dp[0] = dp[1] = 1;\r\n  for (int i = 2; i <= N; i++) { \r\n    dp[i] = 0; \r\n    for (int j = 0; j < i; j++) {\r\n      dp[i] += dp[j] * dp[i - j - 1]; \r\n    }\r\n  }\r\n};\r\ncalc();\r\n"],"description":"catalan"},"chmax":{"prefix":"chmax","body":["template <typename T> \r\ninline bool chmax(T &a, const T &b) {\r\n  return a < b ? a = b, true : false;\r\n}"],"description":"chmax"},"chmin":{"prefix":"chmin","body":["template <typename T> \r\ninline bool chmin(T &a, const T &b) {\r\n  return a > b ? a = b, true : false;\r\n}"],"description":"chmin"},"clock":{"prefix":"clock","body":["  #ifdef LOCAL\r\n    fprintf(stderr, \"Time elapsed: %.12lf secs...\\n\", tick());\r\n  #endif"],"description":"clock"},"closest":{"prefix":"closest","body":["template <typename T>\r\nT closest(vector <T>& arr, T x) {\r\n  int n = arr.size();\r\n  int l = 0;\r\n  int h = n - 1;\r\n  int L = l, H = h;\r\n  while (l <= h) {\r\n    int mid = (l + h) / 2;\r\n    if (x <= arr[mid]) {\r\n      H = mid;\r\n      h = mid - 1;\r\n    } else {\r\n      l = mid + 1;\r\n      L = mid;\r\n    }\r\n  }\r\n  if (abs(arr[H] - x) <= abs(arr[L] - x)) return arr[H];\r\n  return arr[L];\r\n  //returns closest val to x in arr\r\n}"],"description":"closest"},"comb":{"prefix":"comb","body":["template <typename T>\r\nclass combination {\r\n public:\r\n  vector <T> fact;\r\n  vector <T> inv_fact;\r\n  combination(int N) : fact(N + 1), inv_fact(N + 1) {\r\n    assert(N < mod);\r\n    fact[0] = 1;\r\n    for (int i = 1; i <= N; i++) {\r\n      fact[i] = fact[i - 1] * i;\r\n    }\r\n    inv_fact[N] = T(1) / fact[N];\r\n    for (int i = N - 1; i >= 0; i--) {\r\n      inv_fact[i] = inv_fact[i + 1] * (i + 1);\r\n    }\r\n  } \r\n  T P(int n, int r) const {\r\n    if (r < 0 || n < r) return 0;\r\n    return fact[n] * inv_fact[n - r];\r\n  }\r\n \r\n  T C(int n, int r) const {\r\n    if (r < 0 || n < r) return 0;\r\n    return fact[n] * inv_fact[r] * inv_fact[n - r];\r\n  }\r\n};\r\n\r\nconst int N = (int) (1e6 + 1);\r\ncombination <mint> co(N);\r\ninline mint C(int n, int r) { return co.C(n, r); }\r\ninline mint P(int n, int r) { return co.P(n, r); }"],"description":"comb"},"combination":{"prefix":"combination","body":["template <typename T>\r\nclass combination {\r\n public:\r\n  vector <T> fact;\r\n  vector <T> inv_fact;\r\n  combination(int N) : fact(N + 1), inv_fact(N + 1) {\r\n    assert(N < mod);\r\n    fact[0] = 1;\r\n    for (int i = 1; i <= N; i++) {\r\n      fact[i] = fact[i - 1] * i;\r\n    }\r\n    inv_fact[N] = T(1) / fact[N];\r\n    for (int i = N - 1; i >= 0; i--) {\r\n      inv_fact[i] = inv_fact[i + 1] * (i + 1);\r\n    }\r\n  } \r\n  T P(int n, int r) const {\r\n    if (r < 0 || n < r) return 0;\r\n    return fact[n] * inv_fact[n - r];\r\n  }\r\n \r\n  T C(int n, int r) const {\r\n    if (r < 0 || n < r) return 0;\r\n    return fact[n] * inv_fact[r] * inv_fact[n - r];\r\n  }\r\n};\r\n\r\nconst int N = (int) (1e6 + 1);\r\ncombination <mint> co(N);\r\ninline mint C(int n, int r) { return co.C(n, r); }\r\ninline mint P(int n, int r) { return co.P(n, r); }"],"description":"combination"},"comp":{"prefix":"comp","body":["template <typename T>\r\nstruct large {\r\n  bool operator()(const T &a, const T &b) const {\r\n    return (!(a < b) && !(!(a < b) && !(b < a)));\r\n  } \r\n};\r\n\r\ntemplate <typename T>\r\nstruct small {\r\n  bool operator()(const T &a, const T &b) const {\r\n    return a < b;\r\n  } \r\n};\r\n\r\ntemplate <typename T>\r\nstruct same {\r\n  bool operator()(const T &a, const T &b) const {\r\n    return (!(a < b) && !(b < a));\r\n  } \r\n};"],"description":"comp"},"crt":{"prefix":"crt","body":["//..solve for x, given x = ai (mod mi), all mi are mutually co-prime\r\n/*\r\n//..Mine\r\nint crt(vector <int> &a, vector <int> &m) {\r\n  int t = a.size();\r\n  int M = 1, x = 0;\r\n  for (int i = 0; i < t; i++) M *= m[i];\r\n  for (int i = 0; i < t; i++) {\r\n    int n = M / m[i];\r\n    int u = modi(n % m[i], m[i]);\r\n    x += n * u * a[i];\r\n  }\r\n  x %= M;\r\n  if (x < 0) x += M;\r\n  return x;\r\n}\r\n*/\r\n\r\ntemplate <typename T>\r\nvoid crt(const vector<int>& p, const vector<int>& a, T& res) {\r\n  assert(p.size() == a.size());\r\n  auto inverse = [&](int q, int m) {\r\n    q %= m;\r\n    if (q < 0) q += m;\r\n    int b = m, u = 0, v = 1;\r\n    while (q) {\r\n      int t = b / q;\r\n      b -= t * q; swap(q, b);\r\n      u -= t * v; swap(u, v);\r\n    }\r\n    assert(b == 1);\r\n    if (u < 0) u += m;\r\n    return u;\r\n  };\r\n  vector<int> x(p.size());\r\n  for (int i = 0; i < (int) p.size(); i++) {\r\n    assert(0 <= a[i] && a[i] < p[i]);\r\n    x[i] = a[i];\r\n    for (int j = 0; j < i; j++) {\r\n      x[i] = (int) ((long long) (x[i] - x[j]) * inverse(p[j], p[i]) % p[i]);\r\n      if (x[i] < 0) x[i] += p[i];\r\n    }\r\n  }\r\n  res = 0;\r\n  for (int i = (int) p.size() - 1; i >= 0; i--) {\r\n    res = res * p[i] + x[i];\r\n  }\r\n}"],"description":"crt"},"cum":{"prefix":"cum","body":["template <typename T, typename U>\r\nclass cum {\r\n public:\r\n  int n, m;\r\n  vector <vector <T> > mat;\r\n  cum(vector <vector <U> > &_mat) {\r\n    n = _mat.size();\r\n    m = _mat[0].size();\r\n    mat = vector <vector <T> >(n + 1, vector <T>(m + 1, 0));\r\n    for (int i = 0; i < n; i++) {\r\n      for (int j = 0; j < m; j++) {\r\n        mat[i + 1][j + 1] = _mat[i][j];\r\n      } \r\n    } \r\n    for (int i = 1; i < n + 1; i++) {\r\n      for (int j = 1; j < m + 1; j++) {\r\n        mat[i][j] += mat[i - 1][j] + mat[i][j - 1] - mat[i - 1][j - 1];\r\n      } \r\n    }\r\n  }\r\n  T get(int x, int y) {\r\n    return get(0, 0, x, y);\r\n  } \r\n  T get(int p, int q, int r, int s) {\r\n    p += 1, q += 1, r += 1, s += 1;\r\n    return mat[r][s] - mat[r][q - 1] - mat[p - 1][s] + mat[p - 1][q - 1];\r\n  } \r\n};\r\n\r\ntemplate <typename T, typename U>\r\nclass cum {\r\n public:\r\n  int n;\r\n  vector <T> arr;\r\n  cum(vector <U> &_arr) {\r\n    n = _arr.size();\r\n    arr = vector <int>(n);\r\n    arr[0] = _arr[0];\r\n    for (int i = 1; i < n; i++) {\r\n      arr[i] = arr[i - 1] + _arr[i]; \r\n    } \r\n  }\r\n  T get(int x, int y) {\r\n    T H = arr[y];\r\n    T L = x - 1 >= 0 ? arr[x - 1] : 0;\r\n    return H - L;\r\n  } \r\n};"],"description":"cum"},"cycles":{"prefix":"cycles","body":["template <typename T>\r\nvector<vector<int>> find_cycles(const graph<T> &g, int bound_cnt = 1 << 30, int bound_size = 1 << 30) {\r\n  vector<int> was(g.n, -1);\r\n  vector<int> st;\r\n  vector<vector<int>> cycles;\r\n  int total_size = 0;\r\n  function<void(int, int)> dfs = [&](int v, int pe) {\r\n    if ((int) cycles.size() >= bound_cnt || total_size >= bound_size) {\r\n      return;\r\n    }\r\n    was[v] = (int) st.size();\r\n    for (int id : g.g[v]) {\r\n      if (id == pe) {\r\n        continue;\r\n      }\r\n      auto &e = g.edges[id];\r\n      int to = e.from ^ e.to ^ v;\r\n      if (was[to] >= 0) {\r\n        vector<int> cycle(1, id);\r\n        for (int j = was[to]; j < (int) st.size(); j++) {\r\n          cycle.push_back(st[j]);\r\n        }\r\n        cycles.push_back(cycle);\r\n        total_size += (int) cycle.size();\r\n        if ((int) cycles.size() >= bound_cnt || total_size >= bound_size) {\r\n          return;\r\n        }\r\n        continue;\r\n      }\r\n      if (was[to] == -1) {\r\n        st.push_back(id);\r\n        dfs(to, id);\r\n        st.pop_back();\r\n      }\r\n    }\r\n    was[v] = -2;\r\n  };\r\n  for (int i = 0; i < g.n; i++) {\r\n    if (was[i] == -1) {\r\n      dfs(i, -1);\r\n    }\r\n  }\r\n  return cycles;\r\n  // cycles are given by edge ids, all cycles are simple\r\n  // breaks after getting bound_cnt cycles or total_size >= bound_size\r\n  // digraph: finds at least one cycle in every connected component (if not broken)\r\n  // undigraph: finds cycle basis\r\n}\r\n "],"description":"cycles"},"cyclic":{"prefix":"cyclic","body":["template <typename T>\r\nbool cyclic(const digraph <T> &g) {\r\n  enum color { white, gray, black };\r\n\r\n  vector <color> col(g.n, white);\r\n\r\n  function <bool(int)> dfs = [&](int u) -> bool {\r\n    col[u] = gray;\r\n    for (int id : g.g[u]) {\r\n      int v = g.edges[id].from ^ g.edges[id].to ^ u;\r\n      if (col[v] == white) {\r\n        if (dfs(v)) {\r\n          return true;\r\n        } \r\n      } else if (col[v] == gray) {\r\n        return true;\r\n      }\r\n    } \r\n    col[u] = black;\r\n    return false; \r\n  };\r\n  \r\n  for (int u = 0; u < g.n; u++) {\r\n    if (col[u] == white) {\r\n      if (dfs(u)) {\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n  return false; \r\n  //returns true if digraph is cyclic, else false\r\n} \r\n\r\n// cycle in undigraph\r\ntemplate <typename T>\r\nbool cyclic(const undigraph <T> &g) {\r\n  vector <bool> seen(g.n, false);\r\n\r\n  function <bool(int, int)> dfs = [&](int u, int p) -> bool {\r\n    seen[u] = true;\r\n    for (int id : g.g[u]) {\r\n      int v = g.edges[id].from ^ g.edges[id].to ^ u;\r\n      if (v == p) continue;\r\n      \r\n      if (!seen[v]) {\r\n        if (dfs(v, u)) {\r\n          return true;\r\n        } \r\n      } else {\r\n        return true;\r\n      }\r\n    } \r\n    return false; \r\n  };\r\n  \r\n  for (int u = 0; u < g.n; u++) {\r\n    if (!seen[u]) {\r\n      if (dfs(u, -1)) {\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n  return false; \r\n  //returns true if undigraph is cyclic, else false\r\n} \r\n"],"description":"cyclic"},"deb":{"prefix":"deb","body":["template <typename A, typename B>\r\nstring to_string(pair<A, B> p) {\r\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\r\n}\r\n\r\ntemplate <typename A>\r\nstring to_string(A v) {\r\n  bool first = true;\r\n  string res = \"{\";\r\n  for (const auto &x : v) {\r\n    if (!first) {\r\n      res += \", \";\r\n    }\r\n    first = false;\r\n    res += to_string(x);\r\n  }\r\n  res += \"}\";\r\n  return res;\r\n}\r\n\r\nvoid debug_out() { cerr << endl; }\r\n \r\ntemplate <typename Head, typename... Tail>\r\nvoid debug_out(Head H, Tail... T) {\r\n  cerr << \" \" << to_string(H);\r\n  debug_out(T...);\r\n}\r\n \r\n#ifdef LOCAL\r\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\r\n#else\r\n#define debug(...) 42\r\n#endif"],"description":"deb"},"debug":{"prefix":"debug","body":["template <typename A, typename B>\nstring to_string(pair<A, B> p);\n \ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n \ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n \nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n \nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"t\" : \"f\");\n}\n\nstring to_string(const char &ch) {\n  return \"'\" + string(1, ch) + \"'\";\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  reverse(res.begin(), res.end());\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"{\" + to_string(p.first) + \", \" + to_string(p.second) + \"}\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"{\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \"}\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"{\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \"}\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n"],"description":"debug"},"debug_impl":{"prefix":"debug_impl","body":["template <typename A, typename B>\r\nstring to_string(pair<A, B> p);\r\n \r\ntemplate <typename A, typename B, typename C>\r\nstring to_string(tuple<A, B, C> p);\r\n \r\ntemplate <typename A, typename B, typename C, typename D>\r\nstring to_string(tuple<A, B, C, D> p);\r\n \r\nstring to_string(const string& s) {\r\n  return '\"' + s + '\"';\r\n}\r\n \r\nstring to_string(const char* s) {\r\n  return to_string((string) s);\r\n}\r\n \r\nstring to_string(bool b) {\r\n  return (b ? \"true\" : \"false\");\r\n}\r\n\r\nstring to_string(const char &ch) {\r\n  return \"'\" + string(1, ch) + \"'\";\r\n}\r\n\r\nstring to_string(vector<bool> v) {\r\n  bool first = true;\r\n  string res = \"{\";\r\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\r\n    if (!first) {\r\n      res += \", \";\r\n    }\r\n    first = false;\r\n    res += to_string(v[i]);\r\n  }\r\n  res += \"}\";\r\n  return res;\r\n}\r\n \r\ntemplate <size_t N>\r\nstring to_string(bitset<N> v) {\r\n  string res = \"\";\r\n  for (size_t i = 0; i < N; i++) {\r\n    res += static_cast<char>('0' + v[i]);\r\n  }\r\n  reverse(res.begin(), res.end());\r\n  return res;\r\n}\r\n\r\ntemplate <typename A>\r\nstring to_string(A v) {\r\n  bool first = true;\r\n  string res = \"{\";\r\n  for (const auto &x : v) {\r\n    if (!first) {\r\n      res += \", \";\r\n    }\r\n    first = false;\r\n    res += to_string(x);\r\n  }\r\n  res += \"}\";\r\n  return res;\r\n}\r\n \r\ntemplate <typename A, typename B>\r\nstring to_string(pair<A, B> p) {\r\n  return \"{\" + to_string(p.first) + \", \" + to_string(p.second) + \"}\";\r\n}\r\n \r\ntemplate <typename A, typename B, typename C>\r\nstring to_string(tuple<A, B, C> p) {\r\n  return \"{\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \"}\";\r\n}\r\n \r\ntemplate <typename A, typename B, typename C, typename D>\r\nstring to_string(tuple<A, B, C, D> p) {\r\n  return \"{\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \"}\";\r\n}\r\n\r\ntemplate <typename T> \r\nstring to_string(vector <vector<T>> &mat) {\r\n  string res = \"\";\r\n  char temp[32];\r\n  int n = mat.size();\r\n  if (n == 0) return res;\r\n  res += \"\\n\";\r\n  for (int i = 0; i < n; i++) {\r\n    for (int j = 0; j < (int) mat[i].size(); j++) {\r\n      sprintf(temp, \"%-18s\", to_string(mat[i][j]).c_str());\r\n      res += string(temp);\r\n    }\r\n    res += \"\\n\";\r\n  }\r\n  return res;\r\n}\r\n\r\nvoid debug_out() { cerr << endl; }\r\n\r\ntemplate <typename Head, typename... Tail>\r\nvoid debug_out(Head H, Tail... T) {\r\n  cerr << \" \" << to_string(H);\r\n  debug_out(T...);\r\n}\r\n \r\n#ifdef LOCAL\r\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\r\n#else\r\n#define debug(...) 42\r\n#endif\r\n"],"description":"debug_impl"},"dfs":{"prefix":"dfs","body":["vector <bool> seen(g.n, false);\nfunction<void(int)> dfs = [&](int u) {\n  seen[u] = true;\n  for (int id : g.g[u]) {\n    int v = g.edges[id].from ^ g.edges[id].to ^ u;\n    if (!seen[v]) {\n      dfs(v);\n    }\n  }\n};\n//dfs(0);\n"],"description":"dfs"},"dfs_forest":{"prefix":"dfs_forest","body":["template <typename T>\r\nclass dfs_forest : public forest<T> {\r\n public:\r\n  using forest<T>::edges;\r\n  using forest<T>::g;\r\n  using forest<T>::n;\r\n \r\n  vector<int> pv;\r\n  vector<int> pe;\r\n  vector<int> order;\r\n  vector<int> pos;\r\n  vector<int> end;\r\n  vector<int> sz;\r\n  vector<int> root;\r\n  vector<int> depth;\r\n  vector<T> dist;\r\n  int timer;\r\n \r\n  dfs_forest(int _n) : forest<T>(_n) {\r\n  }\r\n \r\n  void init() {\r\n    pv = vector<int>(n, -1);\r\n    pe = vector<int>(n, -1);\r\n    order.clear();\r\n    pos = vector<int>(n, -1);\r\n    end = vector<int>(n, -1);\r\n    sz = vector<int>(n, 0);\r\n    root = vector<int>(n, -1);\r\n    depth = vector<int>(n, -1);\r\n    dist = vector<T>(n);\r\n  }\r\n \r\n  void clear() {\r\n    pv.clear();\r\n    pe.clear();\r\n    order.clear();\r\n    pos.clear();\r\n    end.clear();\r\n    sz.clear();\r\n    root.clear();\r\n    depth.clear();\r\n    dist.clear();\r\n  }\r\n \r\n private:\r\n  void do_dfs(int v) {\r\n    pos[v] = (int) order.size();\r\n    order.push_back(v);\r\n    sz[v] = 1;\r\n    for (int id : g[v]) {\r\n      if (id == pe[v]) {\r\n        continue;\r\n      }\r\n      auto &e = edges[id];\r\n      int to = e.from ^ e.to ^ v;\r\n      depth[to] = depth[v] + 1;\r\n      dist[to] = dist[v] + e.cost;\r\n      pv[to] = v;\r\n      pe[to] = id;\r\n      root[to] = (root[v] != -1 ? root[v] : to);\r\n      do_dfs(to);\r\n      sz[v] += sz[to];\r\n    }\r\n    end[v] = (int) order.size() - 1;\r\n  }\r\n \r\n  void do_dfs_from(int v) {\r\n    depth[v] = 0;\r\n    dist[v] = T{};\r\n    root[v] = v;\r\n    pv[v] = pe[v] = -1;\r\n    do_dfs(v);\r\n  }\r\n \r\n public: \r\n  void dfs(int v, bool clear_order = true) {\r\n    if (pv.empty()) {\r\n      init();\r\n    } else {\r\n      if (clear_order) {\r\n        order.clear();\r\n      }\r\n    }\r\n    do_dfs_from(v);\r\n  }\r\n \r\n  void dfs_all() {\r\n    init();\r\n    for (int v = 0; v < n; v++) {\r\n      if (depth[v] == -1) {\r\n        do_dfs_from(v);\r\n      }\r\n    }\r\n    assert((int) order.size() == n);\r\n  }\r\n};"],"description":"dfs_forest"},"dfs_toposort":{"prefix":"dfs_toposort","body":["//..verified against AOJ GRL_4_B\r\nconst int N = 100001;\r\nvector <bool> visited(N);\r\n\r\nclass Graph {\r\nprivate:\r\n  int V;\r\n  int E;\r\n  vector <vector <int>> adj;\r\n  void dfsUtil(int u, stack <int> &st);\r\npublic:\r\n  Graph(int n, int m);\r\n  void addEdge(int s, int t);\r\n  void topologicalSort();\r\n};\r\n\r\nGraph::Graph(int n, int m) {\r\n  this->V = n;\r\n  this->E = m;\r\n  adj.resize(n);\r\n}\r\n\r\nvoid Graph::addEdge(int s, int t) {\r\n  adj[s].push_back(t);\r\n}\r\n\r\nvoid Graph::dfsUtil(int u, stack <int> &st) {\r\n  visited[u] = true;\r\n  for (int i = 0; i < (int) adj[u].size(); i++) {\r\n    int v = adj[u][i];\r\n    if (!visited[v]) {\r\n      dfsUtil(v, st);\r\n    }\r\n  }\r\n  st.push(u);\r\n}\r\n\r\nvoid Graph::topologicalSort() {\r\n  fill(visited.begin(), visited.begin() + V, false);\r\n  stack <int> st;\r\n  for (int u = 0; u < V; u++) {\r\n    if (!visited[u]) {\r\n      dfsUtil(u, st);\r\n    }\r\n  }\r\n\r\n  //..printing topo order\r\n  while (!st.empty()) {\r\n    int u = st.top();\r\n    st.pop();\r\n    cout << u << endl;\r\n  }\r\n}\r\n\r\nint main() {\r\n  int n, m;\r\n  cin >> n >> m;\r\n  Graph g(n, m);\r\n  int s, t;\r\n  for (int i = 0; i < m; i++) {\r\n    cin >> s >> t;\r\n    g.addEdge(s, t);\r\n  } \r\n  g.topologicalSort();\r\n  return 0;\r\n} "],"description":"dfs_toposort"},"dfs_undigraph":{"prefix":"dfs_undigraph","body":["template <typename T>\r\nclass dfs_undigraph : public undigraph<T> {\r\n public:\r\n  using undigraph<T>::edges;\r\n  using undigraph<T>::g;\r\n  using undigraph<T>::n;\r\n \r\n  vector<int> pv;\r\n  vector<int> pe;\r\n  vector<int> order;\r\n  vector<int> pos;\r\n  vector<int> end;\r\n  vector<int> sz;\r\n  vector<int> root;\r\n  vector<int> depth;\r\n  vector<int> min_depth;\r\n  vector<T> dist;\r\n  vector<int> was;\r\n  int attempt;\r\n \r\n  dfs_undigraph(int _n) : undigraph<T>(_n) {\r\n  }\r\n \r\n  void init() {\r\n    pv = vector<int>(n, -1);\r\n    pe = vector<int>(n, -1);\r\n    order.clear();\r\n    pos = vector<int>(n, -1);\r\n    end = vector<int>(n, -1);\r\n    sz = vector<int>(n, 0);\r\n    root = vector<int>(n, -1);\r\n    depth = vector<int>(n, -1);\r\n    min_depth = vector<int>(n, -1);\r\n    dist = vector<T>(n);\r\n    was = vector<int>(n, -1);\r\n    attempt = 0;\r\n  }\r\n \r\n  void clear() {\r\n    pv.clear();\r\n    pe.clear();\r\n    order.clear();\r\n    pos.clear();\r\n    end.clear();\r\n    sz.clear();\r\n    root.clear();\r\n    depth.clear();\r\n    min_depth.clear();\r\n    dist.clear();\r\n    was.clear();\r\n  }\r\n \r\n private:\r\n  void do_dfs(int v) {\r\n    was[v] = attempt;\r\n    pos[v] = (int) order.size();\r\n    order.push_back(v);\r\n    sz[v] = 1;\r\n    min_depth[v] = depth[v];\r\n    for (int id : g[v]) {\r\n      if (id == pe[v]) {\r\n        continue;\r\n      }\r\n      auto &e = edges[id];\r\n      int to = e.from ^ e.to ^ v;\r\n      if (was[to] == attempt) {\r\n        min_depth[v] = min(min_depth[v], depth[to]);\r\n        continue;\r\n      }\r\n      depth[to] = depth[v] + 1;\r\n      dist[to] = dist[v] + e.cost;\r\n      pv[to] = v;\r\n      pe[to] = id;\r\n      root[to] = (root[v] != -1 ? root[v] : to);\r\n      do_dfs(to);\r\n      sz[v] += sz[to];\r\n      min_depth[v] = min(min_depth[v], min_depth[to]);\r\n    }\r\n    end[v] = (int) order.size() - 1;\r\n  }\r\n \r\n  void do_dfs_from(int v) {\r\n    ++attempt;\r\n    depth[v] = 0;\r\n    dist[v] = T{};\r\n    root[v] = v;\r\n    pv[v] = pe[v] = -1;\r\n    do_dfs(v);\r\n  }\r\n \r\n public:\r\n  void dfs(int v, bool clear_order = true) {\r\n    if (pv.empty()) {\r\n      init();\r\n    } else {\r\n      if (clear_order) {\r\n        order.clear();\r\n      }\r\n    }\r\n    do_dfs_from(v);\r\n  }\r\n \r\n  void dfs_all() {\r\n    init();\r\n    for (int v = 0; v < n; v++) {\r\n      if (depth[v] == -1) {\r\n        do_dfs_from(v);\r\n      }\r\n    }\r\n    assert((int) order.size() == n);\r\n  }\r\n};"],"description":"dfs_undigraph"},"diameter":{"prefix":"diameter","body":["template <typename T>\r\nT diameter(const forest <T> &g) {\r\n  vector <bool> seen(g.n, false);\r\n  vector <T> depth(g.n, -1);\r\n\r\n  function <void(int)> dfs = [&](int u) {\r\n    seen[u] = true;\r\n    for (int id : g.g[u]) {\r\n      auto &e = g.edges[id];\r\n      int v = e.from ^ e.to ^ u;\r\n      if (!seen[v]) {\r\n        depth[v] = depth[u] + e.cost;\r\n        dfs(v);\r\n      }\r\n    }\r\n  };\r\n\r\n  depth[0] = 0;\r\n  dfs(0);\r\n\r\n  T max_depth = numeric_limits<T>::min();\r\n  int from = 0;\r\n  for (int u = 0; u < g.n; u++) {\r\n    if (depth[u] > max_depth) {\r\n      max_depth = depth[u];\r\n      from = u;\r\n    }\r\n  }\r\n  \r\n  //reset\r\n  seen = vector <bool> (g.n, false);\r\n  depth = vector <int> (g.n, -1);\r\n  depth[from] = 0;\r\n  dfs(from);\r\n\r\n  T ans = numeric_limits<T>::min();\r\n  for (int u = 0; u < g.n; u++) {\r\n    ans = max(ans, depth[u]);\r\n  }\r\n  return ans;\r\n  // returns length of diameter\r\n} "],"description":"diameter"},"digraph":{"prefix":"digraph","body":["template <typename T>\r\nclass digraph : public graph<T> {\r\n public:\r\n  using graph<T>::edges;\r\n  using graph<T>::g;\r\n  using graph<T>::n;\r\n \r\n  digraph(int _n) : graph<T>(_n) {\r\n  }\r\n \r\n  int add(int from, int to, T cost = 1) {\r\n    assert(0 <= from && from < n && 0 <= to && to < n);\r\n    int id = (int) edges.size();\r\n    g[from].push_back(id);\r\n    edges.push_back({from, to, cost});\r\n    return id;\r\n  }\r\n \r\n  digraph<T> reverse() const {\r\n    digraph<T> rev(n);\r\n    for (auto &e : edges) {\r\n      rev.add(e.to, e.from, e.cost);\r\n    }\r\n    return rev;\r\n  }\r\n};"],"description":"digraph"},"dijkstra":{"prefix":"dijkstra","body":["/*\r\n//..Mine\r\nusing priority_queue : dijkstra_pq\r\nusing set : dijkstra_st\r\n*/\r\ntemplate <typename T>\r\nvector <T> dijkstra(const graph<T> &g, int start) {\r\n  assert(0 <= start && start < g.n);\r\n  vector<T> dist(g.n, numeric_limits<T>::max());\r\n  priority_queue<pair<T, int>, vector<pair<T, int> >, greater<pair<T, int> > > s;\r\n  dist[start] = 0;\r\n  s.emplace(dist[start], start);\r\n  while (!s.empty()) {\r\n    T expected = s.top().first;\r\n    int i = s.top().second;\r\n    s.pop();\r\n    if (dist[i] != expected) {\r\n      continue;\r\n    }\r\n    for (int id : g.g[i]) {\r\n      auto &e = g.edges[id];\r\n      int to = e.from ^ e.to ^ i;\r\n      if (dist[i] + e.cost < dist[to]) {\r\n        dist[to] = dist[i] + e.cost;\r\n        s.emplace(dist[to], to);\r\n      }\r\n    }\r\n  }\r\n  return dist;\r\n  // returns numeric_limits<T>::max() if there's no path\r\n}\r\n"],"description":"dijkstra"},"dijkstra_pq":{"prefix":"dijkstra_pq","body":["//verified against interviewbit knight problem and AOJ GRL_1_A\r\nstruct Edge {\r\n  int dst;\r\n  int wgt;\r\n  Edge(int idst, int iwgt) : dst(idst), wgt(iwgt) {};\r\n};\r\n\r\nclass Graph {\r\nprivate:\r\n  int V;\r\n  int E;\r\n  vector <vector <Edge>> adj;\r\npublic:\r\n  Graph(int n, int m);\r\n  void addEdge(int src, int dst, int wgt);\r\n  void dijkstra(int src);\r\n};\r\n\r\nGraph::Graph(int n, int m) {\r\n  this->V = n;\r\n  this->E = m;\r\n  adj.resize(n);\r\n}\r\n\r\nvoid Graph::addEdge(int src, int dst, int wgt) {\r\n  adj[src].push_back(Edge(dst, wgt));\r\n}\r\n\r\nvoid Graph::dijkstra(int src) {\r\n  vector <int> dist(V, pinf);\r\n  priority_queue <pair <int, int>, vector <pair <int, int>>, greater<pair <int, int>>> pq;\r\n  dist[src] = 0;\r\n  pq.emplace(0, src);\r\n  while (!pq.empty()) {\r\n    pair <int, int> pr = pq.top(); pq.pop();\r\n    int u = pr.second;\r\n    for (Edge &edge : adj[u]) {\r\n      int v = edge.dst;\r\n      int w = edge.wgt;\r\n      if (dist[u] + w < dist[v]) {\r\n        dist[v] = dist[u] + w;\r\n        pq.emplace(dist[v], v);\r\n      } \r\n    } \r\n  } \r\n\r\n  for (int i = 0; i < V; i++) {\r\n    if (dist[i] == pinf) cout << \"INF\" << endl;\r\n    else cout << dist[i] << endl;\r\n  } \r\n} \r\n\r\nint main() {\r\n  ios_base::sync_with_stdio(false);\r\n  cin.tie(0);\r\n  int n, m, src;\r\n  cin >> n >> m >> src;\r\n  Graph g(n, m);\r\n  int s, t, w;\r\n  for (int i = 0; i < m; i++) {\r\n    cin >> s >> t >> w;\r\n    g.addEdge(s, t, w);\r\n  }\r\n  g.dijkstra(src);\r\n  return 0;\r\n}\r\n"],"description":"dijkstra_pq"},"dijkstra_st":{"prefix":"dijkstra_st","body":["//verified against interviewbit knight problem and AOJ GRL_1_A\r\nstruct Edge {\r\n  int dst;\r\n  int wgt;\r\n  Edge(int idst, int iwgt) : dst(idst), wgt(iwgt) {};\r\n};\r\n\r\nclass Graph {\r\nprivate:\r\n  int V;\r\n  int E;\r\n  vector <vector <Edge>> adj;\r\npublic:\r\n  Graph(int n, int m);\r\n  void addEdge(int src, int dst, int wgt);\r\n  void dijkstra(int src);\r\n};\r\n\r\nGraph::Graph(int n, int m) {\r\n  this->V = n;\r\n  this->E = m;\r\n  adj.resize(n);\r\n}\r\n\r\nvoid Graph::addEdge(int src, int dst, int wgt) {\r\n  adj[src].push_back(Edge(dst, wgt));\r\n}\r\n\r\nvoid Graph::dijkstra(int src) {\r\n  set <pair <int, int>> st;\r\n  vector <int> dist(V, pinf);\r\n  dist[src] = 0;\r\n  st.emplace(dist[src], src);\r\n\r\n  while (!st.empty()) {\r\n    pair <int, int> pr = *(st.begin());\r\n    st.erase(st.begin());\r\n    int u = pr.second;\r\n\r\n    for (Edge &edge : adj[u]) {\r\n      int v = edge.dst;\r\n      int w = edge.wgt;\r\n\r\n      if (dist[u] + w < dist[v]) {\r\n        if (dist[v] != pinf) {\r\n          st.erase(st.find(make_pair(dist[v], v)));\r\n        }\r\n        dist[v] = w + dist[u];\r\n        st.emplace(dist[v], v);\r\n      }\r\n    }\r\n  }\r\n\r\n  \r\n  //..printing distances from source\r\n  for (int i = 0; i < V; i++) {\r\n    if (dist[i] == pinf) {\r\n      cout << \"INF\" << endl;\r\n    } else {\r\n      cout << dist[i] << endl;\r\n    }\r\n  }\r\n}\r\n\r\nint main() {\r\n  int n, m, src;\r\n  cin >> n >> m >> src;\r\n  Graph g(n, m);\r\n  int s, t, w;\r\n  for (int i = 0; i < m; i++) {\r\n    cin >> s >> t >> w;\r\n    g.addEdge(s, t, w);\r\n  }\r\n  g.dijkstra(src);\r\n  return 0;\r\n}"],"description":"dijkstra_st"},"dinic":{"prefix":"dinic","body":["//verifed against AOJ GRL_6_A \r\nconst int maxnodes = 101;\r\n\r\nvector <int> start(maxnodes);\r\n\r\nstruct Edge {\r\n  int to, rev;\r\n  int flow, cap;\r\n};\r\n\r\nclass Graph {\r\nprivate:\r\n  int V;\r\n  vector <int> level;\r\n  vector <vector <Edge>> adj;\r\n  bool dinic_bfs(int s, int t);\r\n  int dinic_dfs(int s, int t, int flow);\r\npublic:\r\n  Graph(int n);\r\n  void addEdge(int src, int dst, int cap);\r\n  int maxFlow(int s, int t);\r\n};\r\n\r\nGraph::Graph(int n) {\r\n  adj.resize(n);\r\n  level.resize(n);\r\n  this->V = n;\r\n}\r\n\r\nvoid Graph::addEdge(int src, int dst, int cap) {\r\n  Edge a = {dst, (int) adj[dst].size(), 0, cap};\r\n  Edge b = {src, (int) adj[src].size(), 0, 0};\r\n  adj[src].push_back(a);\r\n  adj[dst].push_back(b);  \r\n}\r\n\r\nbool Graph::dinic_bfs(int s, int t) {\r\n  fill(level.begin(), level.end(), -1);\r\n  level[s] = 0;\r\n  queue <int> q;\r\n  q.push(s);\r\n\r\n  while (!q.empty()) {\r\n    int u = q.front();\r\n    q.pop();\r\n    for (int j = 0; j < (int) adj[u].size(); j++) {\r\n      Edge &e = adj[u][j];\r\n      int v = e.to;\r\n      if (level[v] < 0 && e.flow < e.cap) {\r\n        level[v] = level[u] + 1;\r\n        q.push(v);\r\n      }\r\n    }\r\n  }\r\n  return level[t] >= 0;\r\n}\r\n\r\nint Graph::dinic_dfs(int u, int t, int flow) {\r\n  if (u == t) {\r\n    return flow;\r\n  }\r\n  for (; start[u] < (int) adj[u].size(); start[u]++) {\r\n    Edge &e = adj[u][start[u]]; \r\n    int v = e.to;\r\n    if (level[v] == level[u] + 1 && e.flow < e.cap) {\r\n      int flow_ahead = dinic_dfs(v, t, min(flow, e.cap - e.flow));\r\n      if (flow_ahead > 0) {\r\n        e.flow += flow_ahead;\r\n        adj[v][e.rev].flow -= flow_ahead;\r\n        return flow_ahead;\r\n      }\r\n    }\r\n  }\r\n  return 0;\r\n}\r\n\r\nint Graph::maxFlow(int s, int t) {\r\n  int result = 0;\r\n  while (dinic_bfs(s, t)) {\r\n    fill(start.begin(), start.begin() + V, 0);\r\n    while (int delta = dinic_dfs(s, t, INT_MAX)) {\r\n      result += delta;\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\nint main() {\r\n  int n, m;\r\n  cin >> n >> m;\r\n  Graph g(n);\r\n  int s, d, c;\r\n  for (int i = 0; i < m; i++) {\r\n    cin >> s >> d >> c;\r\n    g.addEdge(s, d, c);\r\n  }\r\n  cout << g.maxFlow(0, n - 1) << endl;\r\n}\r\n\r\n\r\n// Tourist's\r\ntemplate <typename T>\r\nclass dinic {\r\n public:\r\n  flow_graph<T> &g;\r\n\r\n  vector<int> ptr;\r\n  vector<int> d;\r\n  vector<int> q;\r\n\r\n  dinic(flow_graph<T> &_g) : g(_g) {\r\n    ptr.resize(g.n);\r\n    d.resize(g.n);\r\n    q.resize(g.n);\r\n  }\r\n\r\n  bool expath() {\r\n    fill(d.begin(), d.end(), -1);\r\n    q[0] = g.fin;\r\n    d[g.fin] = 0;\r\n    int beg = 0, end = 1;\r\n    while (beg < end) {\r\n      int i = q[beg++];\r\n      for (int id : g.g[i]) {\r\n        const auto &e = g.edges[id];\r\n        const auto &back = g.edges[id ^ 1];\r\n        if (back.c - back.f > g.eps && d[e.to] == -1) {\r\n          d[e.to] = d[i] + 1;\r\n          if (e.to == g.st) {\r\n            return true;\r\n          }\r\n          q[end++] = e.to;\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n   \r\n  T dfs(int v, T w) {\r\n    if (v == g.fin) {\r\n      return w;\r\n    }\r\n    int &j = ptr[v];\r\n    while (j >= 0) {\r\n      int id = g.g[v][j];\r\n      const auto &e = g.edges[id];\r\n      if (e.c - e.f > g.eps && d[e.to] == d[v] - 1) {\r\n        T t = dfs(e.to, min(e.c - e.f, w));\r\n        if (t > g.eps) {\r\n          g.edges[id].f += t;\r\n          g.edges[id ^ 1].f -= t;\r\n          return t;\r\n        }\r\n      }\r\n      j--;\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  T max_flow() {\r\n    while (expath()) {\r\n      for (int i = 0; i < g.n; i++) {\r\n        ptr[i] = (int) g.g[i].size() - 1;\r\n      }\r\n      T big_add = 0;\r\n      while (true) {\r\n        T add = dfs(g.st, numeric_limits<T>::max());\r\n        if (add <= g.eps) {\r\n          break;\r\n        }\r\n        big_add += add;\r\n      }\r\n      if (big_add <= g.eps) {\r\n        break;\r\n      }\r\n      g.flow += big_add;\r\n    }\r\n    return g.flow;\r\n  }\r\n\r\n  vector<bool> min_cut() {\r\n    max_flow();\r\n    vector<bool> ret(g.n);\r\n    for (int i = 0; i < g.n; i++) {\r\n      ret[i] = (d[i] != -1);\r\n    }\r\n    return ret;\r\n  }\r\n};\r\n"],"description":"dinic"},"diophantine":{"prefix":"diophantine","body":["int gcd(int a, int b, int &x, int &y) {\r\n  if (a == 0) {\r\n    x = 0; y = 1;\r\n    return b;\r\n  }\r\n  int x1, y1;\r\n  int d = gcd(b%a, a, x1, y1);\r\n  x = y1 - (b / a) * x1;\r\n  y = x1;\r\n  return d;\r\n}\r\n\r\nbool find_any_solution(int a, int b, int c, int &x0, int &y0, int &g) {\r\n  g = gcd(abs(a), abs(b), x0, y0);\r\n  if (c % g) {\r\n    return false;\r\n  }\r\n\r\n  x0 *= c / g;\r\n  y0 *= c / g;\r\n  if (a < 0) x0 = -x0;\r\n  if (b < 0) y0 = -y0;\r\n  return true;\r\n}"],"description":"diophantine"},"dominators":{"prefix":"dominators","body":["template <typename T>\r\nvector<int> dominators(digraph<T> &g, int root) {\r\n  int n = g.n;\r\n  vector<int> pos(n, -1);\r\n  vector<int> order;\r\n  vector<int> parent(n, -1);\r\n  function<void(int)> dfs = [&](int v) {\r\n    pos[v] = (int) order.size();\r\n    order.push_back(v);\r\n    for (int id : g.g[v]) {\r\n      if (g.ignore != nullptr && g.ignore(id)) {\r\n        continue;\r\n      }\r\n      auto &e = g.edges[id];\r\n      int u = e.to;\r\n      if (pos[u] == -1) {\r\n        parent[u] = v;\r\n        dfs(u);\r\n      }\r\n    }\r\n  };\r\n  dfs(root);\r\n  vector<int> p(n), best(n);\r\n  iota(p.begin(), p.end(), 0);\r\n  iota(best.begin(), best.end(), 0);\r\n  vector<int> sdom = pos;\r\n  function<int(int)> find_best = [&](int x) {\r\n    if (p[x] != x) {\r\n      int u = find_best(p[x]);\r\n      if (sdom[u] < sdom[best[x]]) {\r\n        best[x] = u;\r\n      }\r\n      p[x] = p[p[x]];\r\n    }\r\n    if (sdom[best[p[x]]] < sdom[best[x]]) {\r\n      best[x] = best[p[x]];\r\n    }\r\n    return best[x];\r\n  };\r\n  digraph<int> g_rev = g.reverse();\r\n  vector<int> idom(n, -1);\r\n  vector<int> link(n, 0);\r\n  vector< vector<int> > bucket(n);\r\n  for (int it = (int) order.size() - 1; it >= 0; it--) {\r\n    int w = order[it];\r\n    for (int id : g_rev.g[w]) {\r\n      if (g_rev.ignore != nullptr && g_rev.ignore(id)) {\r\n        continue;\r\n      }\r\n      auto &e = g_rev.edges[id];\r\n      int u = e.to;\r\n      sdom[w] = min(sdom[w], sdom[find_best(u)]);\r\n    }\r\n    idom[w] = order[sdom[w]];\r\n    for (int u : bucket[w]) {\r\n      link[u] = find_best(u);\r\n    }\r\n    for (int id : g.g[w]) {\r\n      if (g.ignore != nullptr && g.ignore(id)) {\r\n        continue;\r\n      }\r\n      auto &e = g.edges[id];\r\n      int u = e.to;\r\n      if (parent[u] == w) {\r\n        p[u] = w;\r\n      }\r\n    }\r\n    bucket[order[sdom[w]]].push_back(w);\r\n  }\r\n  for (int it = 1; it < (int) order.size(); it++) {\r\n    int w = order[it];\r\n    idom[w] = idom[link[w]];\r\n  }\r\n  return idom;\r\n  // idom[i] -- immediate dominator for vertex i\r\n}\r\n "],"description":"dominators"},"dsu":{"prefix":"dsu","body":["class dsu {\r\n public:\r\n  vector<int> p;\r\n  int n;\r\n \r\n  dsu(int _n) : n(_n) {\r\n    p.resize(n);\r\n    iota(p.begin(), p.end(), 0);\r\n  }\r\n \r\n  inline int get(int x) {\r\n    return (x == p[x] ? x : (p[x] = get(p[x])));\r\n  }\r\n \r\n  inline bool unite(int x, int y) {\r\n    x = get(x);\r\n    y = get(y);\r\n    if (x != y) {\r\n      p[x] = y;\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n};\r\n\r\n//compressed path\r\nclass dsu {\r\n public:\r\n  vector <int> p;\r\n  vector <int> r;\r\n  dsu(int n) {\r\n    p.resize(n);\r\n    r.resize(n);\r\n    iota(p.begin(), p.end(), 0);\r\n    fill(r.begin(), r.end(), 0);\r\n  } \r\n\r\n  inline int get(int x) {\r\n    if (x == p[x]) {\r\n      return x;\r\n    }\r\n    return p[x] = get(p[x]);\r\n  }\r\n\r\n  inline bool unite(int x, int y) {\r\n    x = get(x);\r\n    y = get(y);\r\n    if (x != y) {\r\n      if (r[y] < r[x]) {\r\n        swap(y, x);\r\n      }\r\n      p[x] = y;\r\n      if (r[x] == r[y]) {\r\n        r[y]++;\r\n      }\r\n      return true;\r\n    }\r\n    return false;\r\n  }  \r\n};\r\n"],"description":"dsu"},"duval":{"prefix":"duval","body":["vector<string> duval(string const& s) {\r\n  int n = s.size();\r\n  int i = 0;\r\n  vector<string> fac;\r\n  while (i < n) {\r\n    int j = i + 1, k = i;\r\n    while (j < n && s[k] <= s[j]) {\r\n      if (s[k] < s[j]) k = i;\r\n      else k++;\r\n      j++;\r\n    }\r\n    while (i <= k) {\r\n      fac.push_back(s.substr(i, j - k));\r\n      i += j - k;\r\n    }\r\n  }\r\n  return fac;\r\n}"],"description":"duval"},"endmond_karp":{"prefix":"endmond_karp","body":["//..uses bfs for augmentation\r\n//..verified against AOJ GRL_6_A \r\nstruct Edge {\r\n  int v, rev;\r\n  int cap, flow;\r\n};\r\n\r\nclass Graph {\r\nprivate:\r\n  int V;\r\n  int E;\r\n  vector <vector <Edge>> adj;\r\n  bool augment(int s, int t, vector <int> &prev);\r\npublic:\r\n  Graph(int n, int m);\r\n  void addEdge(int src, int dst, int cap);\r\n  int maxFlow(int s, int t);\r\n};\r\n\r\nGraph::Graph(int n, int m) {\r\n  this->V = n;\r\n  this->E = m;\r\n  adj.resize(n);\r\n}\r\n\r\nvoid Graph::addEdge(int src, int dst, int cap) {\r\n  Edge a = {dst, (int) adj[dst].size(), cap, 0};\r\n  Edge b = {src, (int) adj[src].size(), 0, 0};\r\n\r\n  adj[src].push_back(a);\r\n  adj[dst].push_back(b);\r\n}\r\n\r\nbool Graph::augment(int s, int t, vector <int> &prev) {\r\n  queue <int> q;\r\n  fill(prev.begin(), prev.end(), -1); //..used as visited\r\n  q.push(s);\r\n     \r\n  while (!q.empty()) {\r\n    int u = q.front();\r\n    q.pop();\r\n\r\n    for (Edge e : adj[u]) {\r\n      int v = e.v;\r\n      if (prev[v] == -1 && e.flow < e.cap) {\r\n        prev[v] = e.rev;\r\n        q.push(v);\r\n      }\r\n    }\r\n  }\r\n  return prev[t] != -1;\r\n}\r\n\r\nint Graph::maxFlow(int s, int t) {\r\n  int total = 0;\r\n  vector <int> prev(V);\r\n  while (augment(s, t, prev)) {\r\n    int v = t;\r\n    int flow = pinf;\r\n    //..find flow\r\n    while (v != s) {\r\n      int u = prev[v];\r\n      Edge e = adj[v][u];         //..reverse Edge\r\n      Edge f = adj[e.v][e.rev];   //..forward Edge\r\n      flow = min(flow, f.cap - f.flow);\r\n      v = e.v;\r\n    }\r\n    total += flow;\r\n    //..flow it\r\n    v = t;\r\n    while (v != s) {\r\n      int u = prev[v];\r\n      Edge &e = adj[v][u];\r\n      Edge &f = adj[e.v][e.rev];\r\n      f.flow += flow;\r\n      e.flow -= flow;\r\n      v = e.v;\r\n    } \r\n  }\r\n  return total;\r\n}\r\n\r\nint main() {\r\n  int n, m;\r\n  cin >> n >> m;\r\n  Graph g(n, m);\r\n\r\n  int src, dst, cap;\r\n  for (int i = 0; i < m; i++) {\r\n    cin >> src >> dst >> cap; \r\n    g.addEdge(src, dst, cap);\r\n  }\r\n  cout << g.maxFlow(0, n - 1) << '\\n';\r\n  return 0;\r\n}"],"description":"endmond_karp"},"etov":{"prefix":"etov","body":["template <typename T>\r\nvector<int> edges_to_vertices(const graph<T> &g, const vector<int> &edge_cycle) {\r\n  int sz = (int) edge_cycle.size();\r\n  vector<int> vertex_cycle;\r\n  if (sz <= 2) {\r\n    vertex_cycle.push_back(g.edges[edge_cycle[0]].from);\r\n    if (sz == 2) {\r\n      vertex_cycle.push_back(g.edges[edge_cycle[0]].to);\r\n    }\r\n  } else {\r\n    for (int i = 0; i < sz; i++) {\r\n      int j = (i + 1) % sz;\r\n      auto &e = g.edges[edge_cycle[i]];\r\n      auto &other = g.edges[edge_cycle[j]];\r\n      if (other.from == e.from || other.to == e.from) {\r\n        vertex_cycle.push_back(e.to);\r\n      } else {\r\n        vertex_cycle.push_back(e.from);\r\n      }\r\n    }\r\n  }\r\n  return vertex_cycle;\r\n  // only for simple cycles!\r\n}\r\n "],"description":"etov"},"euclid":{"prefix":"euclid","body":["int euclid(point p1, point p2) { \r\n  int x1 = p1.x;\r\n  int y1 = p1.y;\r\n  int x2 = p2.x;\r\n  int y2 = p2.y;\r\n  return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2); \r\n} "],"description":"euclid"},"euler":{"prefix":"euler","body":["template <typename T>\r\nvector<int> find_eulerian_path(const graph<T> &g, int &root) {\r\n  // in_deg and out_deg are fake for undigraph!\r\n  vector<int> in_deg(g.n, 0);\r\n  vector<int> out_deg(g.n, 0);\r\n  int cnt_edges = 0;\r\n  for (int id = 0; id < (int) g.edges.size(); id++) {\r\n    cnt_edges++;\r\n    auto &e = g.edges[id];\r\n    out_deg[e.from]++;\r\n    in_deg[e.to]++;\r\n  }\r\n  root = -1;\r\n  int odd = 0;\r\n  for (int i = 0; i < g.n; i++) {\r\n    if ((in_deg[i] + out_deg[i]) % 2 == 1) {\r\n      odd++;\r\n      if (root == -1 || out_deg[i] - in_deg[i] > out_deg[root] - in_deg[root]) {\r\n        root = i;\r\n      }\r\n    }\r\n  }\r\n  if (odd > 2) {  \r\n    root = -1;\r\n    return vector<int>();\r\n  }\r\n  if (root == -1) {\r\n    root = 0;\r\n    while (root < g.n && in_deg[root] + out_deg[root] == 0) {\r\n      root++;\r\n    }\r\n    if (root == g.n) {\r\n      // an empty path\r\n      root = 0;\r\n      return vector<int>();\r\n    }\r\n  }\r\n  vector<bool> used(g.edges.size(), false);\r\n  vector<int> ptr(g.n, 0);\r\n  vector<int> balance(g.n, 0);\r\n  vector<int> res(cnt_edges);\r\n  int stack_ptr = 0;\r\n  int write_ptr = cnt_edges;\r\n  int v = root;\r\n  while (true) {\r\n    bool found = false;\r\n    while (ptr[v] < (int) g.g[v].size()) {\r\n      int id = g.g[v][ptr[v]++];\r\n      if (used[id]) {\r\n        continue;\r\n      }\r\n      used[id] = true;\r\n      res[stack_ptr++] = id;\r\n      auto &e = g.edges[id];\r\n      balance[v]++;\r\n      v ^= e.from ^ e.to;\r\n      balance[v]--;\r\n      found = true;\r\n      break;\r\n    }\r\n    if (!found) {\r\n      if (stack_ptr == 0) {\r\n        break;\r\n      }\r\n      int id = res[--stack_ptr];\r\n      res[--write_ptr] = id;\r\n      auto &e = g.edges[id];\r\n      v ^= e.from ^ e.to;\r\n    }\r\n  }\r\n  int disbalance = 0;\r\n  for (int i = 0; i < g.n; i++) {\r\n    disbalance += abs(balance[i]);\r\n  }\r\n  if (write_ptr != 0 || disbalance > 2) {\r\n    root = -1;\r\n    return vector<int>();\r\n  }\r\n  return res;\r\n}\r\n\r\n"],"description":"euler"},"extended_gcd":{"prefix":"extended_gcd","body":["int extended_gcd(int a, int b, int &x, int &y) {\r\n  if (b == 0) {\r\n    x = 1;\r\n    y = 0;\r\n    return a;\r\n  }\r\n  int x1, y1;\r\n  int d = extended_gcd(b, a % b, x1, y1);\r\n  x = y1;\r\n  y = x1 - (a / b) * y1;\r\n  return d;\r\n}\r\n"],"description":"extended_gcd"},"factorise":{"prefix":"factorise","body":["namespace factorizer {\r\n \r\n  template <typename T>\r\n  struct FactorizerVarMod { static T value; };\r\n  template <typename T>\r\n  T FactorizerVarMod<T>::value;\r\n   \r\n  template <typename T>\r\n  bool IsPrime(T n, const vector<T>& bases) {\r\n    if (n < 2) {\r\n      return false;\r\n    }\r\n    vector<T> small_primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\r\n    for (const T& x : small_primes) {\r\n      if (n % x == 0) {\r\n        return n == x;\r\n      }\r\n    }\r\n    if (n < 31 * 31) {\r\n      return true;\r\n    }\r\n    int s = 0;\r\n    T d = n - 1;\r\n    while ((d & 1) == 0) {\r\n      d >>= 1;\r\n      s++;\r\n    }\r\n    FactorizerVarMod<T>::value = n;\r\n    for (const T& a : bases) {\r\n      if (a % n == 0) {\r\n        continue;\r\n      }\r\n      Modular<FactorizerVarMod<T>> cur = a;\r\n      cur = power(cur, d);\r\n      if (cur == 1) {\r\n        continue;\r\n      }\r\n      bool witness = true;\r\n      for (int r = 0; r < s; r++) {\r\n        if (cur == n - 1) {\r\n          witness = false;\r\n          break;\r\n        }\r\n        cur *= cur;\r\n      }\r\n      if (witness) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n   \r\n  bool IsPrime(long long n) {\r\n    return IsPrime(n, {2, 325, 9375, 28178, 450775, 9780504, 1795265022});\r\n  }\r\n   \r\n  bool IsPrime(int32_t n) {\r\n    return IsPrime(n, {2, 7, 61});\r\n  }\r\n   \r\n  // but if you really need unsigned long long version...\r\n  /*\r\n  bool IsPrime(unsigned long long n) {\r\n    if (n < 2) {\r\n      return false;\r\n    }\r\n    vector<uint32_t> small_primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\r\n    for (uint32_t x : small_primes) {\r\n      if (n == x) {\r\n\treturn true;\r\n      }\r\n      if (n % x == 0) {\r\n      return false;\r\n      }\r\n    }\r\n    if (n < 31 * 31) {\r\n      return true;\r\n    }\r\n    uint32_t s = __builtin_ctzll(n - 1);\r\n    unsigned long long d = (n - 1) >> s;\r\n    function<bool(unsigned long long)> witness = [&n, &s, &d](unsigned long long a) {\r\n      unsigned long long cur = 1, p = d;\r\n      while (p > 0) {\r\n\tif (p & 1) {\r\n\t  cur = (__uint128_t) cur * a % n;\r\n\t}\r\n\ta = (__uint128_t) a * a % n;\r\n\tp >>= 1;\r\n      }\r\n      if (cur == 1) {\r\n\treturn false;\r\n      }\r\n      for (uint32_t r = 0; r < s; r++) {\r\n\tif (cur == n - 1) {\r\n\t  return false;\r\n\t}\r\n\tcur = (__uint128_t) cur * cur % n;\r\n      }\r\n      return true;\r\n    };\r\n    vector<unsigned long long> bases_64bit = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};\r\n    for (unsigned long long a : bases_64bit) {\r\n      if (a % n == 0) {\r\n\treturn true;\r\n      }\r\n      if (witness(a)) {\r\n\treturn false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n  */\r\n   \r\n  vector<int> least = {0, 1};\r\n  vector<int> primes;\r\n  int precalculated = 1;\r\n   \r\n  void RunLinearSieve(int n) {\r\n    n = max(n, 1);\r\n    least.assign(n + 1, 0);\r\n    primes.clear();\r\n    for (int i = 2; i <= n; i++) {\r\n      if (least[i] == 0) {\r\n        least[i] = i;\r\n        primes.push_back(i);\r\n      }\r\n      for (int x : primes) {\r\n        if (x > least[i] || i * x > n) {\r\n          break;\r\n        }\r\n        least[i * x] = x;\r\n      }\r\n    }\r\n    precalculated = n;\r\n  }\r\n   \r\n  void RunSlowSieve(int n) {\r\n    n = max(n, 1);\r\n    least.assign(n + 1, 0);\r\n    for (int i = 2; i * i <= n; i++) {\r\n      if (least[i] == 0) {\r\n        for (int j = i * i; j <= n; j += i) {\r\n          if (least[j] == 0) {\r\n            least[j] = i;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    primes.clear();\r\n    for (int i = 2; i <= n; i++) {\r\n      if (least[i] == 0) {\r\n        least[i] = i;\r\n        primes.push_back(i);\r\n      }\r\n    }\r\n    precalculated = n;\r\n  }\r\n   \r\n  void RunSieve(int n) {\r\n    RunLinearSieve(n);\r\n  }\r\n   \r\n  template <typename T>\r\n  vector<pair<T, int>> MergeFactors(const vector<pair<T, int>>& a, const vector<pair<T, int>>& b) {\r\n    vector<pair<T, int>> c;\r\n    int i = 0;\r\n    int j = 0;\r\n    while (i < (int) a.size() || j < (int) b.size()) {\r\n      if (i < (int) a.size() && j < (int) b.size() && a[i].first == b[j].first) {\r\n        c.emplace_back(a[i].first, a[i].second + b[j].second);\r\n        ++i;\r\n        ++j;\r\n        continue;\r\n      }\r\n      if (j == (int) b.size() || (i < (int) a.size() && a[i].first < b[j].first)) {\r\n        c.push_back(a[i++]);\r\n      } else {\r\n        c.push_back(b[j++]);\r\n      }\r\n    }\r\n    return c;\r\n  }\r\n   \r\n  template <typename T>\r\n  vector<pair<T, int>> RhoC(const T& n, const T& c) {\r\n    if (n <= 1) {\r\n      return {};\r\n    }\r\n    if ((n & 1) == 0) {\r\n      return MergeFactors({{2, 1}}, RhoC(n / 2, c));\r\n    }\r\n    if (IsPrime(n)) {\r\n      return {{n, 1}};\r\n    }\r\n    FactorizerVarMod<T>::value = n;\r\n    Modular<FactorizerVarMod<T>> x = 2;\r\n    Modular<FactorizerVarMod<T>> saved = 2;\r\n    T power = 1;\r\n    T lam = 1;\r\n    while (true) {\r\n      x = x * x + c;\r\n      T g = __gcd((x - saved)(), n);\r\n      if (g != 1) {\r\n        return MergeFactors(RhoC(g, c + 1), RhoC(n / g, c + 1));\r\n      }\r\n      if (power == lam) {\r\n        saved = x;\r\n        power <<= 1;\r\n        lam = 0;\r\n      }\r\n      lam++;\r\n    }\r\n    return {};\r\n  }\r\n   \r\n  template <typename T>\r\n  vector<pair<T, int>> Rho(const T& n) {\r\n    return RhoC(n, static_cast<T>(1));\r\n  }\r\n   \r\n  template <typename T>\r\n  vector<pair<T, int>> Factorize(T x) {\r\n    if (x <= 1) {\r\n      return {};\r\n    }\r\n    if (x <= precalculated) {\r\n      vector<pair<T, int>> ret;\r\n      while (x > 1) {\r\n        if (!ret.empty() && ret.back().first == least[x]) {\r\n          ret.back().second++;\r\n        } else {\r\n          ret.emplace_back(least[x], 1);\r\n        }\r\n        x /= least[x];\r\n      }\r\n      return ret;\r\n    }\r\n    if (x <= static_cast<long long>(precalculated) * precalculated) {\r\n      vector<pair<T, int>> ret;\r\n      if (!IsPrime(x)) {\r\n        for (T i : primes) {\r\n          T t = x / i;\r\n          if (i > t) {\r\n            break;\r\n          }\r\n          if (x == t * i) {\r\n            int cnt = 0;\r\n            while (x % i == 0) {\r\n              x /= i;\r\n              cnt++;\r\n            }\r\n            ret.emplace_back(i, cnt);\r\n            if (IsPrime(x)) {\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      if (x > 1) {\r\n        ret.emplace_back(x, 1);\r\n      }\r\n      return ret;\r\n    }\r\n    return Rho(x);\r\n  }\r\n   \r\n  template <typename T>\r\n  vector<T> BuildDivisorsFromFactors(const vector<pair<T, int>>& factors) {\r\n    vector<T> divisors = {1};\r\n    for (auto& p : factors) {\r\n      int sz = (int) divisors.size();\r\n      for (int i = 0; i < sz; i++) {\r\n        T cur = divisors[i];\r\n        for (int j = 0; j < p.second; j++) {\r\n          cur *= p.first;\r\n          divisors.push_back(cur);\r\n        }\r\n      }\r\n    }\r\n    sort(divisors.begin(), divisors.end());\r\n    return divisors;\r\n  }\r\n \r\n}  // namespace factorizer\r\n\r\nusing namespace factoriser;\r\n\r\n// returns prime factorisation\r\ntemplate <typename T>\r\nvector <pair<T, T>> prime_factorise(T n) {\r\n  vector <pair <T, T>> fac;\r\n  if (n <= 1) return fac;\r\n  int cnt = 0;\r\n  bool found = false;\r\n  while (n % 2 == 0) {    \r\n    n = n / 2;\r\n    cnt += 1;\r\n    found = true;\r\n  }  \r\n  if (found) fac.emplace_back(2, cnt);\r\n\r\n  for (int i = 3; i <= (int) sqrt(n); i = i + 2) {  \r\n    cnt = 0;\r\n    found = false;\r\n    while (n % i == 0) {\r\n      n = n / i;\r\n      cnt += 1;\r\n      found = true;\r\n    }  \r\n    if (found) fac.emplace_back(i, cnt);\r\n  }  \r\n\r\n  if (n > 2) {\r\n    fac.emplace_back(n, 1);\r\n  }\r\n  return fac;\r\n}\r\n\r\n// returns all factors\r\ntemplate <typename T>\r\nvector <T> factorise(T val) {\r\n  vector <T> fac;\r\n  for (T n = 1; n * n <= val; n++) {\r\n    if (val % n == 0) {\r\n      if (val / n == n) {\r\n        fac.emplace_back(n);\r\n      } else {\r\n        fac.emplace_back(n);\r\n        fac.emplace_back(val / n);\r\n      }\r\n    } \r\n  }\r\n  sort(fac.begin(), fac.end());\r\n  return fac;\r\n}\r\n"],"description":"factorise"},"fast":{"prefix":"fast","body":["#pragma comment(linker, \"/stack:200000000\")\r\n#pragma GCC optimize(\"Ofast\")\r\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,avx,avx2\")"],"description":"fast"},"fenwick":{"prefix":"fenwick","body":["//..range sum, modify only adds value,\r\ntemplate <typename T>\r\nclass fenwick {\r\n public:\r\n  vector<T> fenw;\r\n  int n;\r\n \r\n  fenwick(int _n) : n(_n) {\r\n    fenw.resize(n);\r\n  }\r\n \r\n  void modify(int x, T v) {\r\n    while (x < n) {\r\n      fenw[x] += v;\r\n      x |= (x + 1);\r\n    }\r\n  }\r\n \r\n  T get(int x) {\r\n    T v{};\r\n    while (x >= 0) {\r\n      v += fenw[x];\r\n      x = (x & (x + 1)) - 1;\r\n    }\r\n    return v;\r\n  }\r\n};\r\n\r\nstruct node {\r\n  int a = ...; //don't forget to set default value\r\n  inline void operator += (node &other) {\r\n    ...\r\n  } \r\n};\r\n\r\n//..range minimum query [0 - x]\r\ntemplate <typename T>\r\nclass fenwick {\r\n  vector<T> fenw;\r\n  int n, v;\r\n \r\n  fenwick(int n, int v) : n(n), v(v) {\r\n    fenw = vector<int>(n, v);\r\n  }\r\n \r\n  void modify(int x, int v) {\r\n    while (x < n) {\r\n      fenw[x] = min(fenw[x], v);\r\n      x |= x + 1;\r\n    }\r\n  }\r\n \r\n  T get(int x) {\r\n    T res = v;\r\n    while (x >= 0) {\r\n      res = min(res, fenw[x]);\r\n      x = (x & (x + 1)) - 1;\r\n    }\r\n    return res;\r\n  }\r\n};\r\n*/\r\n\r\n//..[0 - i] range minimum point update Fenwick, lsb(x) = (x & -x)\r\ntemplate <typename T>\r\nclass fenwick {\r\n public:\r\n  vector <T> bit;\r\n  vector <T> arr;\r\n  int init = numeric_limits<T>::max();\r\n  int n;\r\n  fenwick(int _n) : n(_n + 1) { \r\n    arr = vector <T>(n, init);\r\n    bit = vector <T>(n, init);\r\n  }\r\n\r\n  fenwick(vector <int>& nums) : fenwick(nums.size()) {\r\n    int len = nums.size();\r\n    for (int i = 0; i < len; i++) {\r\n      modify(i, nums[i]);\r\n    }                      \r\n  }\r\n\r\n  void modify(int i, int val) { \r\n    int idx = i + 1;\r\n    while (idx < n) {\r\n      bit[idx] = min(bit[idx], val);\r\n      idx = idx + (idx & -idx);\r\n    }\r\n    arr[i] = val;\r\n  }\r\n\r\n  T get(int i) {\r\n    T res = init;\r\n    int idx = i + 1;\r\n    while (idx > 0) {\r\n      res = min(res, bit[idx]);\r\n      idx = idx - (idx & -idx);\r\n    }\r\n    return res;\r\n  }\r\n};\r\n\r\n//range sum point update Fenwick, lsb(x) = (x & -x)\r\ntemplate <typename T>\r\nclass fenwick {\r\n public:\r\n  vector <T> bit;\r\n  vector <T> arr;\r\n  int init = 0;\r\n  int n;\r\n\r\n  fenwick(int _n) : n(_n + 1) {\r\n    arr = vector <T>(n, init);\r\n    bit = vector <T>(n, init);\r\n  }\r\n\r\n  fenwick(vector <int> &nums) : fenwick(nums.size()) {\r\n    int len = nums.size();\r\n    for (int i = 0; i < len; i++) {\r\n      modify(i, nums[i]);\r\n    }\r\n  }\r\n\r\n  void modify(int i, int val) { \r\n    int idx = i + 1;\r\n    while (idx < n) {\r\n      bit[idx] += val - arr[i];\r\n      idx = idx + (idx & -idx);\r\n    }\r\n    arr[i] = val;\r\n  }\r\n\r\n  T get(int i) {\r\n    T sum = init;\r\n    int idx = i + 1;\r\n    while (idx > 0) {\r\n      sum += bit[idx];\r\n      idx = idx - (idx & -idx);\r\n    }\r\n    return sum;\r\n  }\r\n\r\n  int get(int i, int j) { \r\n    int sumj = get(j);\r\n    int sumi = get(i - 1);\r\n    return sumj - sumi;\r\n  }\r\n};\r\n"],"description":"fenwick"},"fenwick2d":{"prefix":"fenwick2d","body":["template <typename T>\nclass fenwick2d {\n public:\n  vector<vector<T>> fenw;\n  int n, m;\n \n  fenwick2d(int _n, int _m) : n(_n), m(_m) {\n    fenw.resize(n);\n    for (int i = 0; i < n; i++) {\n      fenw[i].resize(m);\n    }\n  }\n \n  inline void modify(int i, int j, T v) {\n    int x = i;\n    while (x < n) {\n      int y = j;\n      while (y < m) {\n        fenw[x][y] += v;\n        y |= (y + 1);\n      }\n      x |= (x + 1);\n    }\n  }\n \n  inline T get(int i, int j) {\n    T v{};\n    int x = i;\n    while (x >= 0) {\n      int y = j;\n      while (y >= 0) {\n        v += fenw[x][y];\n        y = (y & (y + 1)) - 1;\n      }\n      x = (x & (x + 1)) - 1;\n    }\n    return v;\n  }\n};\n"],"description":"fenwick2d"},"fft":{"prefix":"fft","body":["namespace fft {\r\n  const double PI = acos(-1);\r\n \r\n  struct num {\r\n    double x, y;\r\n    num(double x = 0, double y = 0) : x(x), y(y) {}\r\n\r\n    num operator+(const num& o) const {\r\n      return num(x + o.x, y + o.y);\r\n    }\r\n \r\n    num operator-(const num& o) const {\r\n      return num(x - o.x, y - o.y);\r\n    }\r\n \r\n    num operator*(const num& o) const {\r\n      return num(x * o.x - y * o.y, x * o.y + y * o.x);\r\n    }\r\n  };\r\n \r\n  num conj(num a) {\r\n    return num(a.x, -a.y);\r\n  }\r\n  vector<num> fa, fb, roots = {num(0, 0), num(1, 0)};\r\n  vector<int> rev = {0, 1};\r\n  int base = 1;\r\n \r\n  void ensure_base(int nbase) {\r\n    if (nbase <= base) {\r\n      return;\r\n    }\r\n    rev.resize(1 << nbase);\r\n    for (int i = 0; i < (1 << nbase); ++i) {\r\n      rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (nbase - 1));\r\n    }\r\n    roots.resize(1 << nbase);\r\n    while (base < nbase) {\r\n      double angle = 2 * PI / (1 << (base + 1));\r\n      for (int i = 1 << (base - 1); i < (1 << base); ++i) {\r\n        roots[i << 1] = roots[i];\r\n        double ang = angle * ((i << 1) + 1 - (1 << base));\r\n        roots[i << 1 | 1] = num(cos(ang), sin(ang));\r\n      }\r\n      ++base;\r\n    }\r\n  }\r\n \r\n  void dft(vector<num>& a, int n) {\r\n    int zeros = __builtin_ctz(n);\r\n    ensure_base(zeros);\r\n    int shift = base - zeros;\r\n    for (int i = 0; i < n; ++i) {\r\n      if (i < (rev[i] >> shift)) {\r\n        swap(a[i], a[rev[i] >> shift]);\r\n      }\r\n    }\r\n    for (int i = 1; i < n; i <<= 1) {\r\n      for (int j = 0; j < n; j += i << 1) {\r\n        for (int k = 0; k < i; ++k) {\r\n          num x = a[j + k], y = a[j + k + i] * roots[i + k];\r\n          a[j + k] = x + y;\r\n          a[j + k + i] = x - y;\r\n        }\r\n      }\r\n    }\r\n  }\r\n \r\n  vector<double> multiply(const vector<double>& a, const vector<double>& b) {\r\n    int need = a.size() + b.size() - 1, nbase = 0;\r\n    while (1 << nbase < need) {\r\n      ++nbase;\r\n    }\r\n    ensure_base(nbase);\r\n    bool equal = a == b;\r\n    int sz = 1 << nbase;\r\n    if (sz > (int) fa.size()) {\r\n      fa.resize(sz);\r\n    }\r\n    if (sz > (int) fb.size()) {\r\n      fb.resize(sz);\r\n    }\r\n    for (int i = 0; i < (int) a.size(); i++) {\r\n      fa[i] = num(a[i], 0);\r\n    }\r\n    for (int i = a.size(); i < sz; ++i) {\r\n      fa[i] = num(0, 0);\r\n    }\r\n    dft(fa, sz);\r\n    if (equal) {\r\n      for (int i = 0; i < sz; ++i) {\r\n        fb[i] = fa[i];\r\n      }\r\n    } else {\r\n      for (int i = 0; i < (int) b.size(); ++i) {\r\n        fb[i] = num(b[i], 0);\r\n      }\r\n      for (int i = (int) b.size(); i < sz; ++i) {\r\n        fb[i] = num(0, 0);\r\n      }\r\n      dft(fb, sz);\r\n    }\r\n    num ratio(1.0 / sz, 0);\r\n    for (int i = 0; i < sz; ++i) {\r\n      fa[i] = fa[i] * fb[i] * ratio;\r\n    }\r\n    reverse(fa.begin() + 1, fa.begin() + sz);\r\n    dft(fa, sz);\r\n    vector<double> c(need);\r\n    for (int i = 0; i < need; ++i) {\r\n      c[i] = fa[i].x;\r\n    }\r\n    return c;\r\n  }\r\n}\r\n \r\nusing fft::multiply;"],"description":"fft"},"fib":{"prefix":"fib","body":["vector <int> fib(int maxe = (int) (1e9)) {\r\n  vector <int> seq = {1, 1};\r\n  while (true) {\r\n    int n = seq.size();\r\n    long long next = (long long) seq[n - 1] + seq[n - 2];\r\n    if (next > maxe) {\r\n      break;\r\n    } \r\n    seq.push_back(next);\r\n  } \r\n  return seq;\r\n  //returns fibonacci sequence rising atmost maxe\r\n} "],"description":"fib"},"flow":{"prefix":"flow","body":["/*\r\n// ..Mine\r\nusing Dinic's maxflow (V * V * E) uses BFS : dinic\r\nusing push-relabel method (V * V * E) : push_relabel\r\nusing Ford-Fulkerson maxflow (E * F) uses DFS : ford_fulkerson\r\nusing Endmond-Karp (V * E * E) uses BFS : endmond_karp\r\n*/\r\n\r\ntemplate <typename T>\r\nclass flow_graph {\r\n public:\r\n  static constexpr T eps = (T) 1e-9;\r\n \r\n  struct edge {\r\n    int from;\r\n    int to;\r\n    T c;\r\n    T f;\r\n  };\r\n \r\n  vector<vector<int>> g;\r\n  vector<edge> edges;\r\n  int n;\r\n  int st;\r\n  int fin;\r\n  T flow;\r\n \r\n  flow_graph(int _n, int _st, int _fin) : n(_n), st(_st), fin(_fin) {\r\n    assert(0 <= st && st < n && 0 <= fin && fin < n && st != fin);\r\n    g.resize(n);\r\n    flow = 0;\r\n  }\r\n \r\n  void clear_flow() {\r\n    for (const edge &e : edges) {\r\n      e.f = 0;\r\n    }\r\n    flow = 0;\r\n  }\r\n   \r\n  int add(int from, int to, T forward_cap, T backward_cap) {\r\n    assert(0 <= from && from < n && 0 <= to && to < n);\r\n    int id = (int) edges.size();\r\n    g[from].push_back(id); //forward edge have even id\r\n    edges.push_back({from, to, forward_cap, 0});\r\n    g[to].push_back(id + 1);\r\n    edges.push_back({to, from, backward_cap, 0});\r\n    return id;\r\n  }\r\n};\r\n \r\ntemplate <typename T>\r\nclass dinic {\r\n public:\r\n  flow_graph<T> &g;\r\n \r\n  vector<int> ptr;\r\n  vector<int> d;\r\n  vector<int> q;\r\n \r\n  dinic(flow_graph<T> &_g) : g(_g) {\r\n    ptr.resize(g.n);\r\n    d.resize(g.n);\r\n    q.resize(g.n);\r\n  }\r\n \r\n  bool expath() {\r\n    fill(d.begin(), d.end(), -1);\r\n    q[0] = g.fin;\r\n    d[g.fin] = 0;\r\n    int beg = 0, end = 1;\r\n    while (beg < end) {\r\n      int i = q[beg++];\r\n      for (int id : g.g[i]) {\r\n        const auto &e = g.edges[id];\r\n        const auto &back = g.edges[id ^ 1]; // id + 1\r\n        if (back.c - back.f > g.eps && d[e.to] == -1) {\r\n          d[e.to] = d[i] + 1;\r\n          if (e.to == g.st) {\r\n            return true;\r\n          }\r\n          q[end++] = e.to;\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n   \r\n  T dfs(int v, T w) {\r\n    if (v == g.fin) {\r\n      return w;\r\n    }\r\n    int &j = ptr[v];\r\n    while (j >= 0) {\r\n      int id = g.g[v][j];\r\n      const auto &e = g.edges[id];\r\n      if (e.c - e.f > g.eps && d[e.to] == d[v] - 1) {\r\n        T t = dfs(e.to, min(e.c - e.f, w));\r\n        if (t > g.eps) {\r\n          g.edges[id].f += t;\r\n          g.edges[id ^ 1].f -= t;\r\n          return t;\r\n        }\r\n      }\r\n      j--;\r\n    }\r\n    return 0;\r\n  }\r\n \r\n  T max_flow() {\r\n    while (expath()) {\r\n      for (int i = 0; i < g.n; i++) {\r\n        ptr[i] = (int) g.g[i].size() - 1;\r\n      }\r\n      T big_add = 0;\r\n      while (true) {\r\n        T add = dfs(g.st, numeric_limits<T>::max());\r\n        if (add <= g.eps) {\r\n          break;\r\n        }\r\n        big_add += add;\r\n      }\r\n      if (big_add <= g.eps) {\r\n        break;\r\n      }\r\n      g.flow += big_add;\r\n    }\r\n    return g.flow;\r\n  }\r\n \r\n  vector<bool> min_cut() {\r\n    max_flow();\r\n    vector<bool> ret(g.n);\r\n    for (int i = 0; i < g.n; i++) {\r\n      ret[i] = (d[i] != -1);\r\n    }\r\n    return ret;\r\n  }\r\n};"],"description":"flow"},"floyd_warshall":{"prefix":"floyd_warshall","body":["template <typename T>\r\nvector <vector <T>> floyd_warshall(const graph<T> &g, bool &neg) {\r\n  neg = false;\r\n  T inf = numeric_limits<T>::max();\r\n  vector <vector <T>> dist(g.n, vector <T>(g.n, inf));\r\n  for (int u = 0; u < g.n; u++) {\r\n    dist[u][u] = 0;\r\n    for (int id : g.g[u]) {\r\n      int v = g.edges[id].to ^ g.edges[id].from ^ u;\r\n      dist[u][v] = g.edges[id].cost;\r\n    } \r\n  } \r\n  //i .... k .... j\r\n  for (int k = 0; k < g.n; k++) {\r\n    for (int i = 0; i < g.n; i++) {\r\n      for (int j = 0; j < g.n; j++) {\r\n        if (dist[i][k] != inf && dist[k][j] != inf) {\r\n          if (dist[i][k] + dist[k][j] < dist[i][j]) {\r\n            dist[i][j] = dist[i][k] + dist[k][j];\r\n          }\r\n        }\r\n      } \r\n    }\r\n  } \r\n  for (int i = 0; i < g.n; i++) {\r\n    neg |= (dist[i][i] < 0);\r\n  } \r\n  return dist;\r\n  //..negative cycle present when dist[i][i] < 0\r\n  //..contains inf if no path exists, else shortest path\r\n}\r\n"],"description":"floyd_warshall"},"for":{"prefix":"for","body":["for (int i = 0; i < $1; i++) {\n  $0\n}"],"description":"for"},"ford_fulkerson":{"prefix":"ford_fulkerson","body":["//..verified against AOJ GRL_6_A\r\nconst int N = 101;\r\nvector <bool> visited(N);\r\nstruct Edge {\r\n  int to, rev;\r\n  int flow, cap;\r\n};\r\n\r\nclass Graph {\r\nprivate:\r\n  int V;\r\n  int E;\r\n  vector < vector<Edge>> adj;\r\n  int augment(int u, int t, int flow);\r\npublic:\r\n  Graph(int n, int m);\r\n  void addEdge(int src, int dst, int cap);\r\n  int maxFlow(int s, int t);\r\n};\r\n\r\nGraph::Graph(int n, int m) {\r\n  this->V = n;\r\n  this->E = m;\r\n  adj.resize(n);\r\n} \r\n\r\nvoid Graph::addEdge(int src, int dst, int cap) {\r\n  Edge a = {dst, (int) adj[dst].size(), 0, cap};\r\n  Edge b = {src, (int) adj[src].size(), 0, 0};\r\n\r\n  adj[src].push_back(a);\r\n  adj[dst].push_back(b);  \r\n}\r\n\r\nint Graph::augment(int u, int t, int flow) {\r\n  if (u == t) {\r\n    return flow;\r\n  }\r\n  visited[u] = true;\r\n  for (Edge &e : adj[u]) {    //important to iterate the reference variable &e\r\n    int v = e.to;\r\n    if (!visited[v] && e.flow < e.cap) {\r\n      int flow_ahead = augment(v, t, min(flow, e.cap - e.flow));\r\n      if (flow_ahead > 0) {\r\n        e.flow += flow_ahead;\r\n        adj[v][e.rev].flow -= flow_ahead;\r\n        return flow_ahead;\r\n      }\r\n    }\r\n  }\r\n  return 0;\r\n}\r\n\r\nint Graph::maxFlow(int s, int t) {\r\n  int total = 0;\r\n  while (true) {\r\n    fill(visited.begin(), visited.begin() + V, false);\r\n    int flow = augment(s, t, pinf);\r\n    if (flow == 0) {\r\n      break;\r\n    }\r\n    total += flow;\r\n  }\r\n  return total;\r\n} \r\n\r\nint main() {  \r\n  int n, m;\r\n  cin >> n >> m;\r\n  Graph g(n, m);\r\n\r\n  int src, dst, cap;\r\n  for (int i = 0; i < m; i++) {\r\n    cin >> src >> dst >> cap;\r\n    g.addEdge(src, dst, cap);\r\n  }\r\n  cout << g.maxFlow(0, n - 1) << '\\n';\r\n  return 0;\r\n}"],"description":"ford_fulkerson"},"forest":{"prefix":"forest","body":["template <typename T>\r\nclass forest : public graph<T> {\r\n public:\r\n  using graph<T>::edges;\r\n  using graph<T>::g;\r\n  using graph<T>::n;\r\n \r\n  forest(int _n) : graph<T>(_n) {\r\n  }\r\n \r\n  int add(int from, int to, T cost = 1) {\r\n    assert(0 <= from && from < n && 0 <= to && to < n);\r\n    int id = (int) edges.size();\r\n    assert(id < n - 1);\r\n    g[from].push_back(id);\r\n    g[to].push_back(id);\r\n    edges.push_back({from, to, cost});\r\n    return id;\r\n  }\r\n};"],"description":"forest"},"fori":{"prefix":"fori","body":["for (int i = 0; i < $1; i++) {\n  $0\n} \n"],"description":"fori"},"forj":{"prefix":"forj","body":["for (int j = 0; j < $1; j++) {\n  $0\n} "],"description":"forj"},"fork":{"prefix":"fork","body":["for (int k = 0; k < $1; k++) {\n  $0\n}"],"description":"fork"},"frac":{"prefix":"frac","body":["struct frac {\r\n  long long num, den;\r\n \r\n  frac(long long x = 0, long long y = 1)  {\r\n    long long g = abs(__gcd(x, y));\r\n    if (y < 0) {\r\n      g = -g;\r\n    }\r\n    num = x / g;\r\n    den = y / g;\r\n  }\r\n \r\n  frac operator-() const {\r\n    return frac(-num, den);\r\n  }\r\n \r\n  frac operator+(const frac& o) const {\r\n    return frac(num * o.den + den * o.num, den * o.den);\r\n  }\r\n \r\n  frac operator-(const frac& o) const {\r\n    return frac(num * o.den - den * o.num, den * o.den);\r\n  }\r\n \r\n  frac operator*(const frac& o) const {\r\n    return frac(num * o.num, den * o.den);\r\n  }\r\n \r\n  frac operator/(const frac& o) const {\r\n    return frac(num * o.den, den * o.num);\r\n  }\r\n \r\n  bool operator<(const frac& o) const {\r\n    return num * o.den < den * o.num;\r\n  }\r\n \r\n  bool operator==(const frac& o) const {\r\n    return num * o.den == den * o.num;\r\n  }\r\n\r\n  bool operator>(const frac& o) const {\r\n    return num * o.den < den * o.num;\r\n  }\r\n};"],"description":"frac"},"friend":{"prefix":"friend","body":["class Complex {\r\n  int r;\r\n  int i;\r\n  Complex(int ir, int ii) : r(ir), i(ii) {}\r\n  friend istream& operator >> (istream &in,  Complex &c);\r\n  friend ostream& operator << (istream &out,  Complex &c);\r\n};\r\n\r\nistream& operator >> (istream &in,  Circle &c) {\r\n  //TODO\r\n}\r\n\r\nostream& operator << (ostream &out,  Circle &c) {\r\n  //TODO\r\n} "],"description":"friend"},"gauss":{"prefix":"gauss","body":["typedef double ld;\r\n \r\nconst ld eps = 1e-11;\r\n \r\nbool IsZero(ld v) {\r\n  return abs(v) < eps;\r\n}\r\n \r\nenum GAUSS_MODE {\r\n  DEGREE, ABS\r\n};\r\n \r\ntemplate <typename T>\r\nvoid GaussianElimination(vector<vector<T>>& a, int limit, GAUSS_MODE mode = ABS) {\r\n  if (a.empty() || a[0].empty()) {\r\n    return;\r\n  }\r\n  int h = static_cast<int>(a.size());\r\n  int w = static_cast<int>(a[0].size());\r\n  for (int i = 0; i < h; i++) {\r\n    assert(w == static_cast<int>(a[i].size()));\r\n  }\r\n  assert(limit <= w);\r\n  vector<int> deg(h);\r\n  for (int i = 0; i < h; i++) {\r\n    for (int j = 0; j < w; j++) {\r\n      deg[i] += !IsZero(a[i][j]);\r\n    }\r\n  }\r\n  {\r\n    int r = 0;\r\n    for (int c = 0; c < limit; c++) {\r\n      int id = -1;\r\n      for (int i = r; i < h; i++) {\r\n        if (!IsZero(a[i][c]) && (id == -1 || (mode == DEGREE && deg[i] < deg[id]) || (mode == ABS && abs(a[id][c]) < abs(a[i][c])))) {\r\n          id = i;\r\n        }\r\n      }\r\n      if (id == -1) {\r\n        continue;\r\n      }\r\n      if (id > r) {\r\n        swap(a[r], a[id]);\r\n        swap(deg[r], deg[id]);\r\n        for (int j = c; j < w; j++) {\r\n          a[id][j] = -a[id][j];\r\n        }\r\n      }\r\n      vector<int> nonzero;\r\n      for (int j = c; j < w; j++) {\r\n        if (!IsZero(a[r][j])) {\r\n          nonzero.push_back(j);\r\n        }\r\n      }\r\n      T inv_a = 1 / a[r][c];\r\n      for (int i = r + 1; i < h; i++) {\r\n        if (IsZero(a[i][c])) {\r\n          continue;\r\n        }\r\n        T coeff = -a[i][c] * inv_a;\r\n        for (int j : nonzero) {\r\n          if (!IsZero(a[i][j])) deg[i]--;\r\n          a[i][j] += coeff * a[r][j];\r\n          if (!IsZero(a[i][j])) deg[i]++;\r\n        }\r\n      }\r\n      ++r;\r\n    }\r\n  }\r\n  for (int r = h - 1; r >= 0; r--) {\r\n    for (int c = 0; c < limit; c++) {\r\n      if (!IsZero(a[r][c])) {\r\n        T inv_a = 1 / a[r][c];\r\n        for (int i = r - 1; i >= 0; i--) {\r\n          if (IsZero(a[i][c])) {\r\n            continue;\r\n          }\r\n          T coeff = -a[i][c] * inv_a;\r\n          for (int j = c; j < w; j++) {\r\n            a[i][j] += coeff * a[r][j];\r\n          }\r\n        }\r\n        break;\r\n      }\r\n    }\r\n  }\r\n}\r\n \r\ntemplate <typename T>\r\nvector<T> SolveLinearSystem(vector<vector<T>>& a, const vector<T>& b, int w) {\r\n  int h = static_cast<int>(a.size());\r\n  assert(h == static_cast<int>(b.size()));\r\n  if (h > 0) {\r\n    assert(w == static_cast<int>(a[0].size()));\r\n  }\r\n  for (int i = 0; i < h; i++) {\r\n    a[i].push_back(b[i]);\r\n  }\r\n  GaussianElimination(a, w);\r\n  vector<T> x(w, 0);\r\n  for (int i = 0; i < h; i++) {\r\n    for (int j = 0; j < w; j++) {\r\n      if (!IsZero(a[i][j])) {\r\n        x[j] = a[i][w] / a[i][j];\r\n        break;\r\n      }\r\n    }\r\n  }\r\n  return x;\r\n}"],"description":"gauss"},"gcd":{"prefix":"gcd","body":["template <typename T>\r\nT gcd(T a, T b) {\r\n  return b == 0 ? a : gcd(b, a % b);\r\n}"],"description":"gcd"},"gen":{"prefix":"gen","body":["import matplotlib.pyplot as plt\nimport networkx as nx\nimport sys\nsys.stdin = open(\"sol.in\", \"r\")\nG = nx.Graph()\nn, m = [int(x) for x in input().split()]\nfor i in range(0, m):\n  s, t, w = [int(x) for x in input().split()]\n  G.add_edge(s, t, weight=w)\n\npos = nx.spring_layout(G)  # compute graph layout\nnx.draw(G, pos, node_size=700)  # draw nodes and edges\nnx.draw_networkx_labels(G, pos)  # draw node labels/names\nlabels = nx.get_edge_attributes(G, 'weight')\nnx.draw_networkx_edge_labels(G, pos, edge_labels=labels)\nplt.show()"],"description":"gen"},"gomory_hu":{"prefix":"gomory_hu","body":["template <typename T>\r\nforest<T> gomory_hu(const undigraph<T> &g) {\r\n  int n = g.n;\r\n  if (n == 1) {\r\n    return forest<T>(n);\r\n  }\r\n  flow_graph<T> fg(n, 0, 1);\r\n  for (auto &e : g.edges) {\r\n    fg.add(e.from, e.to, e.cost, e.cost);\r\n  }\r\n  vector< vector<int> > dist(n, vector<int>(n, numeric_limits<T>::max()));\r\n  function<void(vector<int>)> dfs = [&g, &n, &fg, &dist, &dfs](vector<int> group) {\r\n    int sz = group.size();\r\n    if (sz == 1) {\r\n      return;\r\n    }\r\n    fg.clear_flow();\r\n    fg.st = group[0];\r\n    fg.fin = group[1];\r\n    T flow = fg.max_flow();\r\n    vector<bool> cut = fg.min_cut();\r\n    for (int i = 0; i < n; i++) {\r\n      for (int j = i + 1; j < n; j++) {\r\n        if (cut[i] != cut[j]) {\r\n          dist[i][j] = min(dist[i][j], flow);\r\n        }\r\n      }\r\n    }\r\n    vector<int> new_groups[2];\r\n    for (int v : group) {\r\n      new_groups[(int) cut[v]].push_back(v);\r\n    }\r\n    for (int id = 0; id < 2; id++) {\r\n      dfs(new_groups[id]);\r\n    }\r\n  };\r\n  vector<int> group(n);\r\n  iota(group.begin(), group.end(), 0);\r\n  dfs(group);\r\n  undigraph<T> mg(n);\r\n  for (int i = 0; i < n; i++) {\r\n    for (int j = i + 1; j < n; j++) {\r\n      mg.add(i, j, -dist[i][j]);\r\n    }\r\n  }\r\n  T foo;\r\n  vector<int> ids = mst(mg, foo);\r\n  forest<T> ret(n);\r\n  for (int id : ids) {\r\n    auto &e = mg.edges[id];\r\n    ret.add(e.from, e.to, -e.cost);\r\n  }\r\n  return ret;\r\n  // don't be lazy next time!\r\n  // implement a proper gomory-hu tree\r\n}"],"description":"gomory_hu"},"graham":{"prefix":"graham","body":["\r\nvector <point> graham(vector <point> &arr) { \r\n  int n = arr.size();  \r\n  int ymin = arr[0].y, start = 0; \r\n  for (int i = 1; i < n; i++) { \r\n    int y = arr[i].y; \r\n    if ((y < ymin) || (ymin == y && arr[i].x < arr[start].x)) {\r\n      ymin = arr[i].y;\r\n      start = i; \r\n    }\r\n  }\r\n  auto swap = [&] (point &p1, point &p2) { \r\n    point temp = p1; \r\n    p1 = p2; \r\n    p2 = temp;\r\n  }; \r\n  swap(arr[0], arr[start]);\r\n  point p0 = arr[0]; \r\n  auto comp = [&](const point &p1, const point &p2) { \r\n    int o = orientation(p0, p1, p2); \r\n    if (o == S) return euclid(p0, p1) < euclid(p0, p2);\r\n    return o == L;\r\n  };\r\n  sort(arr.begin() + 1, arr.end(), comp); \r\n  stack<point> st; \r\n  st.push(arr[0]); \r\n  st.push(arr[1]); \r\n  auto prev = [&]() { \r\n    point p = st.top(); \r\n    st.pop(); \r\n    point res = st.top(); \r\n    st.push(p); \r\n    return res; \r\n  };  \r\n  for (int i = 2; i < n; i++) {  \r\n    while (st.size() > 1 && orientation(prev(), st.top(), arr[i]) == R) {\r\n      st.pop(); \r\n    }\r\n    st.push(arr[i]); \r\n  } \r\n  point left_top = st.top();\r\n  ...vector <point> left_wall;\r\n  for (int i = n - 2; i >= 1; i--) {\r\n    if (orientation(p0, left_top, arr[i]) == S) {\r\n      left_wall.push_back(arr[i]);\r\n    } \r\n  }\r\n  vector <point> ans;\r\n  while (!st.empty()) { \r\n    point p = st.top(); \r\n    ans.push_back(p);\r\n    st.pop(); \r\n  }\r\n  reverse(ans.begin(), ans.end());\r\n  for (point p : left_wall) {\r\n    ans.push_back(p);\r\n  }\r\n  return ans;\r\n  // returns convex hull in antic-clockwise order from starting left-bottom most point\r\n} "],"description":"graham"},"graph":{"prefix":"graph","body":["template <typename T>\r\nclass graph {\r\n public:\r\n  struct edge {\r\n    int from;\r\n    int to;\r\n    T cost;\r\n  };\r\n \r\n  vector<edge> edges;\r\n  vector<vector<int>> g;\r\n  int n;\r\n \r\n  graph(int _n) : n(_n) {\r\n    g.resize(n);\r\n  }\r\n \r\n  virtual int add(int from, int to, T cost) = 0;\r\n};"],"description":"graph"},"group":{"prefix":"group","body":["template <typename T>\r\nvector <pair <int, int>> group(vector <T> &a) {\r\n  int n = a.size();\r\n  vector <pair<int, int>> grp(n);\r\n  int h = 0;\r\n  while (h < n) {\r\n    int l = h;\r\n    while (h + 1 < n && a[h + 1] == a[l]) {\r\n      h += 1;\r\n    }\r\n    for (int i = l; i <= h; i++) {\r\n      grp[i].first = l;\r\n      grp[i].second = h;\r\n    }\r\n    l = h + 1;\r\n    h = h + 1; \r\n  }\r\n  return grp; \r\n  //..grp[i] = range a[i] is scattered\r\n} \r\n"],"description":"group"},"hadamard":{"prefix":"hadamard","body":["namespace fwht { \r\n  template<typename T>\r\n  void hadamard(vector<T> &a) {\r\n    int n = a.size();\r\n    for (int k = 1; k < n; k <<= 1) {\r\n      for (int i = 0; i < n; i += 2 * k) {\r\n        for (int j = 0; j < k; j++) {\r\n          T x = a[i + j];\r\n          T y = a[i + j + k];\r\n          a[i + j] = x + y;\r\n          a[i + j + k] = x - y;\r\n        }\r\n      }\r\n    }\r\n  }\r\n   \r\n  template<typename T>\r\n  vector<T> multiply(vector<T> a, vector<T> b) {\r\n    int eq = (a == b);\r\n    int n = 1;\r\n    while (n < (int) max(a.size(), b.size())) {\r\n      n <<= 1;\r\n    }\r\n    a.resize(n);\r\n    b.resize(n);\r\n    hadamard(a);\r\n    if (eq) b = a; else hadamard(b);\r\n    for (int i = 0; i < n; i++) {\r\n      a[i] *= b[i];\r\n    }\r\n    hadamard(a);\r\n    T q = 1 / static_cast<T>(n);\r\n    for (int i = 0; i < n; i++) {\r\n      a[i] *= q;\r\n    }\r\n    return a;\r\n  }\r\n} \r\n// namespace fwht"],"description":"hadamard"},"hash":{"prefix":"hash","body":["//..both p and mod prime\r\nconst int p = 31;\r\nconst int mod = (int) (1e9 + 9);\r\n\r\ninline long long mul(long long a, long long b) {\r\n  long long res = a * b;\r\n  a = res % mod;\r\n  return a;\r\n}\r\n\r\ninline void add(long long &a, long long b) {\r\n  a += b;\r\n  if (a >= mod) {\r\n    a -= mod;\r\n  }\r\n}\r\n\r\n//..polynomial rolling hashing of form : str[0] * (p ^ 0) + str[1] * (p ^ 1) + str[2] * (p ^ 2)\r\n//..complete hash value at end of hash array\r\nvector <long long> hashing(const string &str) {\r\n  long long val = 0;\r\n  long long exp = 1;\r\n  int len = str.length();\r\n  vector <long long> hash(len);\r\n  for (int i = 0; i < len; i++) {   \r\n    char ch = str[i];\r\n    int coef = ch - 'a' + 1;\r\n    add(val, mul(coef, exp));\r\n    exp = mul(exp, p);\r\n\r\n    hash[i] = val;\r\n  }\r\n\r\n  return hash;\r\n  //..returns incremental hash values\r\n}\r\n"],"description":"hash"},"hash61":{"prefix":"hash61","body":["typedef uint64_t HT;\n \nmt19937 rng(787788789);\n \nstruct hash61 {\n  static const HT md = (1LL << 61) - 1;\n  static HT step;\n  static vector<HT> pw;\n \n  static HT addmod(HT a, HT b) {\n    a += b;\n    if (a >= md) a -= md;\n    return a;\n  }\n \n  static HT submod(HT a, HT b) {\n    a += md - b;\n    if (a >= md) a -= md;\n    return a;\n  }\n \n  static HT mulmod(HT a, HT b) {\n    HT l1 = (uint32_t) a, h1 = a >> 32, l2 = (uint32_t) b, h2 = b >> 32;\n    HT l = l1 * l2, m = l1 * h2 + l2 * h1, h = h1 * h2;\n    HT ret = (l & md) + (l >> 61) + (h << 3) + (m >> 29) + (m << 35 >> 3) + 1;\n    ret = (ret & md) + (ret >> 61);\n    ret = (ret & md) + (ret >> 61);\n    return ret - 1;\n  }\n \n  void ensure_pw(int sz) {\n    int cur = (int) pw.size();\n    if (cur < sz) {\n      pw.resize(sz);\n      for (int i = cur; i < sz; i++) {\n        pw[i] = mulmod(pw[i - 1], step);\n      }\n    }\n  }\n \n  vector<HT> pref;\n  int n;\n \n  template<typename T>\n  hash61(const T& s) {\n    n = (int) s.size();\n    ensure_pw(n + 1);\n    pref.resize(n + 1);\n    pref[0] = 1;\n    for (int i = 0; i < n; i++) {\n      pref[i + 1] = addmod(mulmod(pref[i], step), s[i]);\n    }\n  }\n \n  inline HT operator()(const int from, const int to) const {\n    assert(0 <= from && from <= to && to <= n - 1);\n    return submod(pref[to + 1], mulmod(pref[from], pw[to - from + 1]));\n  }\n};\n \nHT hash61::step = (md >> 2) + rng() % (md >> 1);\nvector<HT> hash61::pw = vector<HT>(1, 1);\n"],"description":"hash61"},"header":{"prefix":"header","body":["#include <vector>\r\n#include <list>\r\n#include <map>\r\n#include <unordered_map>\r\n#include <unordered_set>\r\n#include <set>\r\n#include <queue>\r\n#include <deque>\r\n#include <stack>\r\n#include <bitset>\r\n#include <algorithm>\r\n#include <functional>\r\n#include <numeric>\r\n#include <utility>\r\n#include <sstream>\r\n#include <iostream>\r\n#include <fstream>\r\n#include <iomanip>\r\n#include <cstdio>\r\n#include <cmath>\r\n#include <cstdlib>\r\n#include <ctime>\r\n#include <assert.h>"],"description":"header"},"heap":{"prefix":"heap","body":["template <typename T>\r\nstruct heap {\r\n  priority_queue<T> foo, bar;\r\n \r\n  void push(T x) {\r\n    foo.push(x);\r\n  }\r\n \r\n  void pop(T x) {\r\n    bar.push(x);\r\n  }\r\n \r\n  T top() {\r\n    while (!bar.empty() && foo.top() == bar.top()) {\r\n      foo.pop();\r\n      bar.pop();\r\n    }\r\n    return foo.top();\r\n  }\r\n};"],"description":"heap"},"hld_forest":{"prefix":"hld_forest","body":["template <typename T>\r\nclass hld_forest : public lca_forest<T> {\r\n public:\r\n  using lca_forest<T>::edges;\r\n  using lca_forest<T>::g;\r\n  using lca_forest<T>::n;\r\n  using lca_forest<T>::pv;\r\n  using lca_forest<T>::sz;\r\n  using lca_forest<T>::pos;\r\n  using lca_forest<T>::order;\r\n  using lca_forest<T>::depth;\r\n  using lca_forest<T>::dfs;\r\n  using lca_forest<T>::dfs_all;\r\n  using lca_forest<T>::lca;\r\n  using lca_forest<T>::build_lca;\r\n \r\n  vector<int> head;\r\n  vector<int> visited;\r\n \r\n  hld_forest(int _n) : lca_forest<T>(_n) {\r\n    visited.resize(n);\r\n  }\r\n \r\n  void build_hld(const vector<int> &vs) {\r\n    for (int tries = 0; tries < 2; tries++) {\r\n      if (vs.empty()) {\r\n        dfs_all();\r\n      } else {\r\n        order.clear();\r\n        for (int v : vs) {\r\n          dfs(v, false);\r\n        }\r\n        assert((int) order.size() == n);\r\n      }\r\n      if (tries == 1) {\r\n        break;\r\n      }\r\n      for (int i = 0; i < n; i++) {\r\n        if (g[i].empty()) {\r\n          continue;\r\n        }\r\n        int best = -1, bid = 0;\r\n        for (int j = 0; j < (int) g[i].size(); j++) {\r\n          int id = g[i][j];\r\n          int v = edges[id].from ^ edges[id].to ^ i;\r\n          if (pv[v] != i) {\r\n            continue;\r\n          }\r\n          if (sz[v] > best) {\r\n            best = sz[v];\r\n            bid = j;\r\n          }\r\n        }\r\n        swap(g[i][0], g[i][bid]);\r\n      }\r\n    }\r\n    build_lca();\r\n    head.resize(n);\r\n    for (int i = 0; i < n; i++) {\r\n      head[i] = i;\r\n    }\r\n    for (int i = 0; i < n - 1; i++) {\r\n      int x = order[i];\r\n      int y = order[i + 1];\r\n      if (pv[y] == x) {\r\n        head[y] = head[x];\r\n      }\r\n    }\r\n  }\r\n \r\n  void build_hld(int v) {\r\n    build_hld(vector<int>(1, v));\r\n  }\r\n \r\n  void build_hld_all() {\r\n    build_hld(vector<int>());\r\n  }\r\n \r\n  bool apply_on_path(int x, int y, bool with_lca, function<void(int,int,bool)> f) {\r\n    // f(x, y, up): up -- whether this part of the path goes up\r\n    assert(!head.empty());\r\n    int z = lca(x, y);\r\n    if (z == -1) {\r\n      return false;\r\n    }\r\n    {\r\n      int v = x;\r\n      while (v != z) {\r\n        if (depth[head[v]] <= depth[z]) {\r\n          f(pos[z] + 1, pos[v], true);\r\n          break;\r\n        }\r\n        f(pos[head[v]], pos[v], true);\r\n        v = pv[head[v]];\r\n      }\r\n    }\r\n    if (with_lca) {\r\n      f(pos[z], pos[z], false);\r\n    }\r\n    {\r\n      int v = y;\r\n      int cnt_visited = 0;\r\n      while (v != z) {\r\n        if (depth[head[v]] <= depth[z]) {\r\n          f(pos[z] + 1, pos[v], false);\r\n          break;\r\n        }\r\n        visited[cnt_visited++] = v;\r\n        v = pv[head[v]];\r\n      }\r\n      for (int at = cnt_visited - 1; at >= 0; at--) {\r\n        v = visited[at];\r\n        f(pos[head[v]], pos[v], false);\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n};\r\n\r\n/* usage\r\nhld_forest<int> g(n);\r\nfor (int i = 0; i < n - 1; i++) {\r\n  int x, y;\r\n  cin >> x >> y;\r\n  --x; --y;\r\n  g.add(x, y);\r\n}\r\ng.build_hld(0);\r\nvector<int> labels(n);\r\nfor (int i = 0; i < n; i++) {\r\n  cin >> labels[i];\r\n}\r\nvector<pair<int, int>> a(n);\r\nfor (int i = 0; i < n; i++) {\r\n  a[i] = make_pair(labels[g.order[i]], g.order[i]);\r\n}\r\nSparseTable<pair<int, int>> st(a, [&](pair<int, int> i, pair<int, int> j) { return max(i, j); });\r\n\r\n//queries\r\nwhile (q--) {\r\n  int x, y;\r\n  cin >> x >> y;\r\n  --x; --y;\r\n  pair<int, int> mx = make_pair(-1, -1);\r\n  g.apply_on_path(x, y, true, [&](int from, int to, bool up) {\r\n    mx = max(mx, st.get(from, to));\r\n  });\r\n}\r\n*/"],"description":"hld_forest"},"horner":{"prefix":"horner","body":["// coeff in form = C0 * x^0 + c1 * x^1 + c2 * x^2 .. . . . cn-1 * x^n-1\ntemplate <typename T>\nT horner(const vector<T>& coeff, T x) {\n  int n = (int) coeff.size();\n  T res = coeff[n - 1];\n  for (int i = n - 2; i >= 0; i--) {\n    res = coeff[i] + x * res;\n  } \n  \n  return res;\n}\n"],"description":"horner"},"hull":{"prefix":"hull","body":["vector <point> graham(vector <point> &arr) { \r\n  int n = arr.size();  \r\n  int ymin = arr[0].y, start = 0; \r\n  for (int i = 1; i < n; i++) { \r\n    int y = arr[i].y; \r\n    if ((y < ymin) || (ymin == y && arr[i].x < arr[start].x)) {\r\n      ymin = arr[i].y;\r\n      start = i; \r\n    }\r\n  }\r\n  auto swap = [&] (point &p1, point &p2) { \r\n    point temp = p1; \r\n    p1 = p2; \r\n    p2 = temp;\r\n  }; \r\n  swap(arr[0], arr[start]);\r\n  point p0 = arr[0]; \r\n  auto comp = [&](const point &p1, const point &p2) { \r\n    int o = orientation(p0, p1, p2); \r\n    if (o == S) return euclid(p0, p1) < euclid(p0, p2);\r\n    return o == L;\r\n  };\r\n  sort(arr.begin() + 1, arr.end(), comp); \r\n  stack<point> st; \r\n  st.push(arr[0]); \r\n  st.push(arr[1]); \r\n  auto prev = [&]() { \r\n    point p = st.top(); \r\n    st.pop(); \r\n    point res = st.top(); \r\n    st.push(p); \r\n    return res; \r\n  };  \r\n  for (int i = 2; i < n; i++) {  \r\n    while (st.size() > 1 && orientation(prev(), st.top(), arr[i]) == R) {\r\n      st.pop(); \r\n    }\r\n    st.push(arr[i]); \r\n  } \r\n  point left_top = st.top();\r\n  ...vector <point> left_wall;\r\n  for (int i = n - 2; i >= 1; i--) {\r\n    if (orientation(p0, left_top, arr[i]) == S) {\r\n      left_wall.push_back(arr[i]);\r\n    } \r\n  }\r\n  vector <point> ans;\r\n  while (!st.empty()) { \r\n    point p = st.top(); \r\n    ans.push_back(p);\r\n    st.pop(); \r\n  }\r\n  reverse(ans.begin(), ans.end());\r\n  for (point p : left_wall) {\r\n    ans.push_back(p);\r\n  }\r\n  return ans;\r\n  // returns convex hull in antic-clockwise order from starting left-bottom most point\r\n} "],"description":"hull"},"hungarian":{"prefix":"hungarian","body":["template<typename T>\r\nclass hungarian {\r\n  public:\r\n  int n;\r\n  int m;\r\n  vector< vector<T> > a;\r\n  vector<T> u;\r\n  vector<T> v;\r\n  vector<int> pa;\r\n  vector<int> pb;\r\n  vector<int> way;\r\n  vector<T> minv;\r\n  vector<bool> used;\r\n  T inf;\r\n \r\n  hungarian(int _n, int _m) : n(_n), m(_m) {\r\n    assert(n <= m);\r\n    a = vector< vector<T> >(n, vector<T>(m));\r\n    u = vector<T>(n + 1);\r\n    v = vector<T>(m + 1);\r\n    pa = vector<int>(n + 1, -1);\r\n    pb = vector<int>(m + 1, -1);\r\n    way = vector<int>(m, -1);\r\n    minv = vector<T>(m);\r\n    used = vector<bool>(m + 1);\r\n    inf = numeric_limits<T>::max();\r\n  }\r\n \r\n  inline void add_row(int i) {\r\n    fill(minv.begin(), minv.end(), inf);\r\n    fill(used.begin(), used.end(), false);\r\n    pb[m] = i;\r\n    pa[i] = m;\r\n    int j0 = m;\r\n    do {\r\n      used[j0] = true;\r\n      int i0 = pb[j0];\r\n      T delta = inf;\r\n      int j1 = -1;\r\n      for (int j = 0; j < m; j++) {\r\n        if (!used[j]) {\r\n          T cur = a[i0][j] - u[i0] - v[j];\r\n          if (cur < minv[j]) {\r\n            minv[j] = cur;\r\n            way[j] = j0;\r\n          }\r\n          if (minv[j] < delta) {\r\n            delta = minv[j];\r\n            j1 = j;\r\n          }\r\n        }\r\n      }\r\n      for (int j = 0; j <= m; j++) {\r\n        if (used[j]) {\r\n          u[pb[j]] += delta;\r\n          v[j] -= delta;\r\n        } else {\r\n          minv[j] -= delta;\r\n        }\r\n      }\r\n      j0 = j1;\r\n    } while (pb[j0] != -1);\r\n    do {\r\n      int j1 = way[j0];\r\n      pb[j0] = pb[j1];\r\n      pa[pb[j0]] = j0;\r\n      j0 = j1;\r\n    } while (j0 != m);\r\n  }\r\n \r\n  inline T current_score() {\r\n    return -v[m];\r\n  }\r\n \r\n \r\n  inline T solve() {\r\n    for (int i = 0; i < n; i++) {\r\n      add_row(i);\r\n    }\r\n    return current_score();\r\n  }\r\n};\r\n "],"description":"hungarian"},"in":{"prefix":"in","body":["  #ifdef LOCAL\r\n    freopen(\"sol.in\", \"rt\", stdin);\r\n  #endif"],"description":"in"},"input":{"prefix":"input","body":["from sys import stdin, stdout\r\nimport sys\r\nsys.stdout = open(\"sol.out\", \"w\") # for redirecting output to a file\r\n\r\nn = stdin.readline() \r\n# array input similar method \r\narr = [int(x) for x in stdin.readline().split()] \r\n\r\n#single n input followed by newline\r\nval = int(input())\r\nprint(val)\r\n\r\n#split expects newline, else error will come unlike cin in c++\r\na, b = [int(x) for x in input().split()]\r\nprint(a * b)\r\n\r\na, b = map(int, input().split())\r\nprint(a * b)\r\n\r\n#using stdin and stdout\r\na, b = [int(x) for x in stdin.readline().rstrip().split()]\r\nstdout.write(str(a * b) + \"\\n\")\r\n\r\narr = [2, 3, 4, 5]\r\n[print(i) for i in arr] temp"],"description":"input"},"inside":{"prefix":"inside","body":["inline bool inside(int x, int y, int n, int m) {\r\n  return (x >= 0 && x < n) && (y >= 0 && y < m);\r\n}"],"description":"inside"},"inv":{"prefix":"inv","body":["/*for mod not prime, but a and mod are co-prime\r\ninline int inv(int a) {\r\n  a %= mod;\r\n  if (a < 0) a += mod;\r\n  int b = mod, u = 0, v = 1;\r\n  while (a) {\r\n    int t = b / a;\r\n    b -= t * a; swap(a, b);\r\n    u -= t * v; swap(u, v);\r\n  }\r\n  assert(b == 1);\r\n  if (u < 0) u += mod;\r\n  return u;\r\n}\r\n\r\n//OR\r\nint inv(int a) {\r\n  int x, y;\r\n  int g = extended_gcd(a, mod, x, y);\r\n  if (g != 1) {\r\n    cerr << \"No inverse exists\" << endl;\r\n    return 0;\r\n  } else {\r\n    x = (x % mod + mod) % mod;\r\n    return x;\r\n  }  \r\n} \r\n*/\r\n//when mod is a prime number\r\ninline int inv(int x) {\r\n  return power(x, mod - 2);\r\n}"],"description":"inv"},"is_palindrome":{"prefix":"is_palindrome","body":["template <typename T>\r\nbool is_palindrome(const T &s) {\r\n  int n = s.size();\r\n  for (int i = 0; i < n / 2; i++) {\r\n    int j = n - i - 1;\r\n    if (s[i] != s[j]) return false;\r\n  } \r\n  return true;\r\n}"],"description":"is_palindrome"},"java":{"prefix":"java","body":["import java.io.OutputStream;\r\nimport java.io.InputStream;\r\nimport java.io.PrintWriter;\r\nimport java.util.StringTokenizer;\r\nimport java.io.IOException;\r\nimport java.io.BufferedReader;\r\nimport java.io.InputStreamReader;\r\n\r\npublic class Main {\r\n  \r\n  public static void main(String[] args) {\r\n    InputStream inputStream = System.in;\r\n    OutputStream outputStream = System.out;\r\n    InputReader in = new InputReader(inputStream);\r\n    PrintWriter out = new PrintWriter(outputStream);\r\n    Task solver = new Task();\r\n    solver.solve(in, out);\r\n    out.close();\r\n  }\r\n\r\n  static class Task {\r\n    public void solve(InputReader in, PrintWriter out) {\r\n      int n;\r\n      out.print(\"Enter a number : \");\r\n      n = in.nextInt();\r\n      out.println(\"You entered \" + n);\r\n      return;\r\n    }  \r\n  }\r\n\r\n  static class InputReader {\r\n    public BufferedReader reader;\r\n    public StringTokenizer tokenizer;\r\n    public InputReader(InputStream stream) {\r\n      reader = new BufferedReader(new InputStreamReader(stream), 32768);\r\n      tokenizer = null;\r\n    }\r\n    public String next() {\r\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\r\n        try {\r\n          tokenizer = new StringTokenizer(reader.readLine());\r\n        } catch (IOException e) {\r\n          throw new RuntimeException(e);\r\n        }\r\n      }\r\n      return tokenizer.nextToken();\r\n    }\r\n    public int nextInt() {\r\n      return Integer.parseInt(next());\r\n    }\r\n    public long nextLong() {\r\n      return Long.parseLong(next());\r\n    }\r\n    public float nextFloat() {\r\n      return Float.parseFloat(next());\r\n    }\r\n    public double nextDouble() {\r\n      return Double.parseDouble(next());\r\n    }\r\n    public String nextLine() {\r\n      try {\r\n        return reader.readLine();\r\n      } catch (IOException e) {\r\n        throw new RuntimeException(e);\r\n      }\r\n    }\r\n  }\r\n}"],"description":"java"},"jump":{"prefix":"jump","body":["auto min_jump = [&] (vector <int>& arr) {\r\n  int n = arr.size();\r\n  vector <int> dp(n);\r\n  int max_reach = arr[0];\r\n  int jumps = 1;\r\n  int steps = arr[0];\r\n  dp[0] = 0;\r\n  for (int i = 1; i < n; i++) {\r\n    if (i == n - 1) {\r\n      dp[i] = jumps;\r\n      return;\r\n    }\r\n    max_reach = max(max_reach, i + arr[i]);\r\n    steps--;\r\n    dp[i] = jumps;\r\n    if (steps == 0) {\r\n      jumps++;\r\n      steps = max_reach - i;\r\n    } \r\n  } \r\n};"],"description":"jump"},"kadane":{"prefix":"kadane","body":["template <typename T>\r\nT kadane(vector <T> &arr) {\r\n  T ans = numeric_limits<T>::min();\r\n  T sum = T{};\r\n  for (int v : arr) {\r\n    sum += v;\r\n    ans = max(ans, sum);\r\n    sum = max(0, sum);\r\n  }\r\n  return ans;\r\n  //returns only the maximum subarray sum\r\n} \r\n\r\ntemplate <typename T>\r\nT kadane(vector <T> &arr, int &l, int &h) {\r\n  l = h = 0;\r\n  T sum = T{};\r\n  T ans = numeric_limits<T>::min();\r\n  int n = arr.size();\r\n  int s = 0;\r\n  for (int i = 0; i < n; i++) {\r\n    sum += arr[i];\r\n    if (sum > ans) {\r\n      ans = sum;\r\n      l = s; h = i;\r\n    }\r\n    if (sum < 0) {\r\n      sum = 0;\r\n      s = i + 1;\r\n    }\r\n  }\r\n  return ans;\r\n  //returns maximum sum and the subarray[l - h]\r\n}\r\n\r\n"],"description":"kadane"},"kahn_toposort":{"prefix":"kahn_toposort","body":["//..verified against AOJ GRL_4_B\r\nclass Graph {\r\nprivate:\r\n  int V;\r\n  int E;\r\n  vector <vector <int>> adj;\r\npublic:\r\n  Graph(int n, int m);\r\n  void addEdge(int s, int t);\r\n  void topologicalSort();\r\n};\r\n\r\nGraph::Graph(int n, int m) {\r\n  this->V = n;\r\n  this->E = m;\r\n  adj.resize(n);\r\n}\r\n\r\nvoid Graph::addEdge(int s, int t) {\r\n  adj[s].push_back(t);\r\n}\r\n\r\nvoid Graph::topologicalSort() {\r\n  vector <int> order;\r\n  vector <int> deg(V, 0);\r\n  for (int u = 0; u < V; u++) {\r\n    for (int v : adj[u]) {\r\n      deg[v]++;\r\n    } \r\n  }\r\n  queue <int> from;\r\n  for (int u = 0; u < V; u++) {\r\n    if (deg[u] == 0) {\r\n      from.push(u);\r\n    } \r\n  } \r\n  while (!from.empty()) {\r\n    int u = from.front();\r\n    from.pop();\r\n    order.emplace_back(u);\r\n    for (int v : adj[u]) {\r\n      if (deg[v] == 1) {\r\n        from.push(v);\r\n      }\r\n      deg[v]--;\r\n    } \r\n  }\r\n  if ((int) order.size() != V) { //Cycle present\r\n    //TODO\r\n  }\r\n\r\n  //..print topo order\r\n  for (int node : order) cout << node << \" \";\r\n  cout << endl;\r\n}\r\n\r\nint main() {\r\n  int n, m;\r\n  cin >> n >> m;\r\n  Graph g(n, m);\r\n  int s, t;\r\n  for (int i = 0; i < m; i++) {\r\n    cin >> s >> t;\r\n    g.addEdge(s, t);\r\n  } \r\n  g.topologicalSort();\r\n  return 0;\r\n} "],"description":"kahn_toposort"},"klee":{"prefix":"klee","body":["// untested\r\ntemplate <typename T>\r\nT klee(const vector<pair<T, T>> &a) {\r\n  int n = a.size();\r\n  vector<pair<T, bool>> x(n * 2);\r\n  for (int i = 0; i < n; i++) {\r\n    x[i * 2] = {a[i].first, false};\r\n    x[i * 2 + 1] = {a[i].second, true};\r\n  }\r\n  sort(x.begin(), x.end());\r\n  T result = 0;\r\n  int cnt = 0;\r\n  for (int i = 0; i < n * 2; i++) {\r\n    if (cnt > 0) {\r\n      result += x[i].first - x[i - 1].first;\r\n    }\r\n    (x[i].second) ? cnt-- : cnt++;\r\n  }\r\n  return result;\r\n}\r\n\r\n//tested\r\nint klee(const vector<pair<int, int>> &a) {\r\n  int n = a.size();\r\n  vector<pair<int, bool>> x(n * 2);\r\n  for (int i = 0; i < n; i++) {\r\n    x[i * 2] = {a[i].first, false};\r\n    x[i * 2 + 1] = {a[i].second, true};\r\n  }\r\n  sort(x.begin(), x.end());\r\n  int result = 0;\r\n  int cnt = 0;\r\n  for (int i = 0; i < n * 2; i++) {\r\n    if (i > 0 && x[i].first > x[i - 1].first && cnt > 0) {\r\n      result += x[i].first - x[i - 1].first;\r\n    }\r\n    if (x[i].second) cnt--;\r\n    else cnt++;\r\n  }\r\n  return result;\r\n}\r\n"],"description":"klee"},"kmp":{"prefix":"kmp","body":["vector <int> kmp(const string& pat, const string& txt) {\r\n  int n = txt.length();\r\n  int m = pat.length();\r\n  int len = 0;\r\n  vector <int> lps = calc_lps(pat);\r\n  vector <int> pos;\r\n\r\n  for (int i = 0; i < n; i++) {\r\n    while (len > 0 && pat[len] != txt[i]) {\r\n      len = lps[len - 1];\r\n    }\r\n    if (pat[len] == txt[i]) {\r\n      len++;\r\n    }\r\n    if (len == m) {\r\n      int at = i - len + 1;\r\n      pos.emplace_back(at);\r\n      len = lps[len - 1];\r\n    }\r\n  }\r\n\r\n  return pos;\r\n  //.. starting indices of match\r\n}"],"description":"kmp"},"knight":{"prefix":"knight","body":["vector <int> dx = {-2, -2, -1, 1, 2, 2, 1, -1};\r\nvector <int> dy = {-1, 1, 2, 2, 1, -1, -2, -2};\r\n"],"description":"knight"},"kosaraju":{"prefix":"kosaraju","body":["template <typename T>\r\nvector<int> kosaraju(const digraph<T> &g, int &cnt) {\r\n  digraph<T> g_rev = g.reverse();\r\n  stack <int> order;\r\n  vector<bool> seen(g.n, false);\r\n  function<void(int)> dfs1 = [&](int v) {\r\n    seen[v] = true;\r\n    for (int id : g.g[v]) {\r\n      auto &e = g.edges[id];\r\n      int to = e.to;\r\n      if (!seen[to]) {\r\n        dfs1(to);\r\n      }\r\n    }\r\n    order.push(v);\r\n  };\r\n  for (int i = 0; i < g.n; i++) {\r\n    if (!seen[i]) {\r\n      dfs1(i);\r\n    }\r\n  }\r\n\r\n  vector<int> grp(g.n, -1);\r\n  cnt = 0;\r\n  function<void(int)> dfs2 = [&](int v) {\r\n    grp[v] = cnt;\r\n    for (int id : g_rev.g[v]) {\r\n      auto &e = g_rev.edges[id];\r\n      int to = e.to;\r\n      if (grp[to] == -1) {\r\n        dfs2(to);\r\n      }\r\n    }\r\n  };\r\n\r\n  while (!order.empty()) {\r\n    int u = order.top();\r\n    order.pop();\r\n    if (grp[u] != -1) {\r\n      continue;\r\n    }\r\n    dfs2(u);\r\n    cnt++;\r\n  }\r\n  return grp;\r\n  //.. grp[i] <= grp[j] for every edge i -> j\r\n}"],"description":"kosaraju"},"lca":{"prefix":"lca","body":["//..verified against AOJ GRL_5_C\r\nclass Graph {\r\nprivate:\r\n  int V;\r\n  vector <vector <int>> adj;\r\n  vector <int> first;\r\n  vector <int> height;\r\n  vector <int> euler;\r\n  void eulerUtil(int u, vector <bool> &visited, int h);\r\n  vector <int> seg;\r\n  void build(int idx, int ss, int se);\r\n  int lca_query(int idx, int ss, int se, int qs, int qe);\r\npublic:\r\n  Graph(int n);\r\n  void addEdge(int u, int v);    \r\n  void euler_tour();\r\n  void buildrmq();\r\n  int lca(int u, int v);\r\n};\r\n\r\nGraph::Graph(int n) {\r\n  this->V = n;\r\n  adj.resize(n);\r\n  first.resize(n);\r\n  height.resize(n);\r\n}\r\n\r\nvoid Graph::addEdge(int u, int v) {\r\n  adj[u].push_back(v);\r\n}\r\n\r\nvoid Graph::eulerUtil(int u, vector <bool> &visited, int h) {\r\n  visited[u] = true;\r\n  first[u] = euler.size();\r\n  height[u] = h;\r\n  euler.push_back(u);\r\n\r\n  for (int i = 0; i < (int) adj[u].size(); i++) {\r\n    int v = adj[u][i];\r\n    if (!visited[v]) {\r\n      eulerUtil(v, visited, h + 1);\r\n      euler.push_back(u);\r\n    }\r\n  }\r\n}\r\n\r\nvoid Graph::euler_tour() {\r\n  vector <bool> visited;\r\n  fill(visited.begin(), visited.begin() + V, false);\r\n  eulerUtil(0, visited, 0);\r\n}\r\n\r\n\r\nvoid Graph::build(int idx, int ss, int se) {\r\n  if (ss == se) {\r\n    seg[idx] = euler[ss];\r\n    return;\r\n  }\r\n\r\n  int m = (ss + se) / 2;\r\n  build(2 * idx, ss, m);\r\n  build(2 * idx + 1, m + 1, se);\r\n  //..store information based on the depth to be minimum in range\r\n  seg[idx] = height[seg[2 * idx]] < height[seg[2 * idx + 1]] ? seg[2 * idx] : seg[2 * idx + 1];\r\n}\r\n\r\nvoid Graph::buildrmq() {\r\n  int n = euler.size();\r\n  seg.resize(4 * n);\r\n  build(1, 0, n - 1);  \r\n} \r\n\r\nint Graph::lca_query(int idx, int ss, int se, int qs, int qe) {\r\n  if (qs > qe) {\r\n    return pinf;\r\n  }\r\n  if (ss == qs && se == qe) {\r\n    return seg[idx];\r\n  }\r\n  int m = (ss + se) / 2;\r\n  int l = lca_query(2 * idx, ss, m, qs, min(m, qe));\r\n  int r = lca_query(2 * idx + 1, m + 1, se, max(m + 1, qs), qe);\r\n  if (l == pinf) {\r\n    return r;\r\n  } else if (r == pinf) {\r\n    return l;\r\n  } else {\r\n    return height[l] < height[r] ? l : r;\r\n  }\r\n}\r\n\r\nint Graph::lca(int u, int v) {\r\n  int qs = first[u];\r\n  int qe = first[v];\r\n  if (qs > qe) {\r\n    swap(qs, qe);\r\n  }   \r\n  int n = euler.size();\r\n  return lca_query(1, 0, n - 1, qs, qe);\r\n}\r\n\r\nint main() {\r\n  int n;\r\n  cin >> n;\r\n  Graph g(n);\r\n  int k, v;\r\n  for (int u = 0; u < n; u++) {\r\n    cin >> k;\r\n    for (int j = 0; j < k; j++) {\r\n      cin >> v;\r\n      //..v is children of u and 0 is the root of this tree\r\n      g.addEdge(u, v);   \r\n    } \r\n  }\r\n  g.euler_tour();\r\n  g.buildrmq();\r\n\r\n  int q, ui, vi;\r\n  cin >> q;\r\n  for (int i = 0; i < q; i++) {\r\n    cin >> ui >> vi;\r\n    cout << g.lca(ui, vi) << '\\n';\r\n  } \r\n  return 0;\r\n}"],"description":"lca"},"lca_forest":{"prefix":"lca_forest","body":["template <typename T>\r\nclass lca_forest : public dfs_forest<T> {\r\n public:\r\n  using dfs_forest<T>::edges;\r\n  using dfs_forest<T>::g;\r\n  using dfs_forest<T>::n;\r\n  using dfs_forest<T>::pv;\r\n  using dfs_forest<T>::pos;\r\n  using dfs_forest<T>::end;\r\n  using dfs_forest<T>::depth;\r\n \r\n  int h;\r\n  vector<vector<int>> pr;\r\n \r\n  lca_forest(int _n) : dfs_forest<T>(_n) {\r\n  }\r\n \r\n  inline void build_lca() {\r\n    assert(!pv.empty());\r\n    int max_depth = 0;\r\n    for (int i = 0; i < n; i++) {\r\n      max_depth = max(max_depth, depth[i]);\r\n    }\r\n    h = 1;\r\n    while ((1 << h) <= max_depth) {\r\n      h++;\r\n    }\r\n    pr.resize(n);\r\n    for (int i = 0; i < n; i++) {\r\n      pr[i].resize(h);\r\n      pr[i][0] = pv[i];\r\n    }\r\n    for (int j = 1; j < h; j++) {\r\n      for (int i = 0; i < n; i++) {\r\n        pr[i][j] = (pr[i][j - 1] == -1 ? -1 : pr[pr[i][j - 1]][j - 1]);\r\n      }\r\n    }\r\n  }\r\n \r\n  inline bool anc(int x, int y) {\r\n    return (pos[x] <= pos[y] && end[y] <= end[x]);\r\n  }\r\n \r\n  inline int go_up(int x, int up) {\r\n    assert(!pr.empty());\r\n    up = min(up, (1 << h) - 1);\r\n    for (int j = h - 1; j >= 0; j--) {\r\n      if (up & (1 << j)) {\r\n        x = pr[x][j];\r\n        if (x == -1) {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    return x;\r\n  }\r\n \r\n  inline int lca(int x, int y) {\r\n    assert(!pr.empty());\r\n    if (anc(x, y)) {\r\n      return x;\r\n    }\r\n    if (anc(y, x)) {\r\n      return y;\r\n    }\r\n    for (int j = h - 1; j >= 0; j--) {\r\n      if (pr[x][j] != -1 && !anc(pr[x][j], y)) {\r\n        x = pr[x][j];\r\n      }\r\n    }\r\n    return pr[x][0];\r\n  }\r\n};"],"description":"lca_forest"},"lcm":{"prefix":"lcm","body":["template <typename T>\r\ninline T lcm(T a, T b) {\r\n  return a / gcd(a, b) * b;\r\n}"],"description":"lcm"},"lcp":{"prefix":"lcp","body":["/* tourist's template\r\ntemplate <typename T>\r\nvector<int> build_lcp(int n, const T &s, const vector<int> &sa) {\r\n  assert((int) sa.size() == n);\r\n  vector<int> rank(n);\r\n  for (int i = 0; i < n; i++) {\r\n      rank[sa[i]] = i;\r\n  }\r\n  vector<int> lcp(max(n - 1, 0));\r\n  int k = 0;\r\n  for (int i = 0; i < n; i++) {\r\n    k = max(k - 1, 0);\r\n    if (rank[i] == n - 1) {\r\n      k = 0;\r\n    } else {\r\n      int j = sa[rank[i] + 1];\r\n      while (i + k < n && j + k < n && s[i + k] == s[j + k]) {\r\n        k++;\r\n      }\r\n      lcp[rank[i]] = k;\r\n    }\r\n  }\r\n  return lcp;\r\n}\r\n \r\ntemplate <typename T>\r\nvector<int> build_lcp(const T &s, const vector<int> &sa) {\r\n  return build_lcp((int) s.size(), s, sa);\r\n}\r\n\r\n//..vector<int> sa = suffix_array(s);\r\n//..vector<int> lcp = build_lcp(s, sa);\r\n*/\r\n//..first calc lcp[sa[0]], then lcp[sa[1]] ans so on\r\nvector<int> build_lcp(const T &s, const vector<int> &sa) {\r\n  int n = s.length();\r\n  assert((int) sa.size() == n);\r\n  vector<int> rank(n);\r\n  for (int i = 0; i < n; i++) {\r\n    rank[sa[i]] = i;\r\n  }\r\n  vector<int> lcp(max(n - 1, 0));\r\n  int k = 0;\r\n  for (int i = 0; i < n; i++) {\r\n    if (rank[i] == n - 1) {\r\n      k = 0;\r\n    } else {\r\n      int j = sa[rank[i] + 1];\r\n      while (i + k < n && j + k < n && s[i + k] == s[j + k]) {\r\n        k++;\r\n      }\r\n      lcp[rank[i]] = k;\r\n      if (k > 0) k--;\r\n    }\r\n  }\r\n  return lcp;\r\n}"],"description":"lcp"},"leap":{"prefix":"leap","body":["bool leap(int year) {\r\n  if (((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0)) {\r\n    return true;\r\n  }\r\n  return false; \r\n}"],"description":"leap"},"leetcode":{"prefix":"leetcode","body":["namespace Leetcode {\r\nifstream in(\"sol.in\");\r\nstring line;\r\nbool done = false;\r\n\r\nstring Trim(string &s) {\r\n  int n = s.length();\r\n  int i = 0, j = n - 1;\r\n  while (i < n && s[i] == ' ') {\r\n    i++;\r\n  }\r\n  while (j >= 0 && s[j] == ' ') {\r\n    j--;\r\n  }  \r\n  return s.substr(i, j - i + 1);\r\n}\r\n\r\nvoid Pass() {\r\n  while (getline(in, line)) {\r\n    line = Trim(line);\r\n    if (line.empty()) continue;\r\n    break;\r\n  }\r\n}\r\n\r\nstring String() {\r\n  Pass();\r\n  return line;\r\n}\r\n\r\ntemplate <typename T>\r\nvector <T> Vector() {\r\n  if (!done) Pass();\r\n  int len = line.length();\r\n  line = line.substr(1, len - 2);\r\n  stringstream ss(line);\r\n  string token;\r\n  vector <T> arr;\r\n  while (getline(ss, token, ',')) {\r\n    int val;\r\n    if (token == \"null\") {\r\n      val = -1;\r\n    } else {\r\n      val = stoi(token);\r\n    }\r\n    arr.push_back(val);\r\n  } \r\n  return arr;\r\n}\r\n\r\ntemplate <typename T>\r\nvector <vector <T>> Matrix() { \r\n  Pass();\r\n  done = true;\r\n  int len = line.length();\r\n  string temp = line.substr(1, len - 2);\r\n  stringstream ss(temp);\r\n  string token;\r\n  vector <vector <T>> mat;\r\n  while (getline(ss, token, ']')) {\r\n    int i = 0;\r\n    int l = token.length();\r\n    while (token[i] != '[') i++;\r\n    line = token.substr(i, l - i) + ']';\r\n    vector <T> row = Vector<T>();\r\n    mat.push_back(row);\r\n  }\r\n  done = false;\r\n  return mat;\r\n}\r\n\r\n#ifdef LOCAL\r\nstruct TreeNode {\r\n  int val;\r\n  TreeNode *left;\r\n  TreeNode *right;\r\n  TreeNode(int x) : val(x), left(NULL), right(NULL) {}\r\n};\r\n#endif\r\n  \r\nusing Node = TreeNode;\r\n\r\ntemplate <typename T>\r\nvoid Serialize(Node* root) { \r\n  vector <T> tree;  \r\n  auto Bfs = [&](Node* from) {\r\n    queue <Node*> q;\r\n    q.push(from);\r\n    while (!q.empty()) {\r\n      int size = (int) q.size();\r\n      while (size--) {\r\n        Node* u = q.front(); q.pop();\r\n        if (u == NULL) tree.push_back(-1);\r\n        else {\r\n          tree.push_back(u->val);\r\n          q.push(u->left);\r\n          q.push(u->right);\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  Bfs(root);\r\n  cout << \"[\";\r\n  for (int i = 0; i < (int) tree.size(); i++) {\r\n    if (i > 0) cout << \", \";\r\n    if (tree[i] == -1) cout << \"null\";\r\n    else cout << tree[i];\r\n  }\r\n  cout << \"]\";\r\n}\r\n\r\ntemplate <typename T>\r\nNode* Deserialize(vector <T> &data) {\r\n  int n = data.size();\r\n  queue<Node*> q;\r\n  Node* root = new Node(data[0]);\r\n  bool is_left = true;\r\n  q.push(root);\r\n\r\n  Node* cur = NULL;\r\n  for (int i = 1; i < n; i++) {\r\n    Node *node = NULL;\r\n    if (data[i] != -1) {\r\n      node = new Node(data[i]);\r\n      q.push(node);\r\n    }\r\n\r\n    if (is_left) {\r\n      cur = q.front();\r\n      q.pop();\r\n      cur->left = node;\r\n      is_left = false;\r\n    } else {\r\n      cur->right = node;\r\n      is_left = true;\r\n    }\r\n  }\r\n  return root;\r\n} \r\n\r\ntemplate <typename T>\r\nNode* Tree() {\r\n  Pass();\r\n  done = true;\r\n  vector <T> arr = Vector<T>();\r\n  Node* root = Deserialize(arr);\r\n  done = false;\r\n  return root;\r\n}  \r\n\r\ntemplate <typename T>\r\nT Int() {\r\n  Pass();\r\n  stringstream ss(line);\r\n  T val;\r\n  ss >> val;\r\n  return val;\r\n}\r\n\r\n..........\r\n\r\nvoid read_write() {\r\n  int tt = Int<int>();\r\n  while (tt--) {\r\n    ....\r\n  }\r\n}}\r\n\r\nusing namespace Leetcode;\r\n\r\n#ifdef LOCAL\r\nint main() {\r\n  ios_base::sync_with_stdio(false);\r\n  cin.tie(0);\r\n  read_write();\r\n  return 0;\r\n}\r\n#endif"],"description":"leetcode"},"lis":{"prefix":"lis","body":["// short implementation\r\ntemplate<typename T>\r\nint lis(const vector<T>& a) {\r\n  vector<T> u;\r\n  for (const T& x : a) {\r\n    auto it = lower_bound(u.begin(), u.end(), x);\r\n    if (it == u.end()) {\r\n      u.push_back(x);\r\n    } else {\r\n      *it = x;\r\n    }\r\n  }\r\n  return (int) u.size();\r\n}\r\n\r\ntemplate <typename T>\r\nint lis(vector <T>& arr) {\r\n  int n = arr.size();\r\n  if (n == 0) {\r\n    return 0;  \r\n  }\r\n  vector <T> tail(n, 0);  \r\n  int length = 1; \r\n  tail[0] = arr[0];\r\n  for (int i = 1; i < n; i++) {  \r\n    auto b = tail.begin();\r\n    auto e = tail.begin() + length; \r\n    auto it = lower_bound(b, e, arr[i]);\r\n    if (it == tail.begin() + length) {\r\n      tail[length++] = arr[i];\r\n    } else {\r\n      *it = arr[i];\r\n    }\r\n  }  \r\n  return length;  \r\n}\r\n"],"description":"lis"},"ll":{"prefix":"ll","body":["using int64 = long long;"],"description":"ll"},"lli":{"prefix":"lli","body":["using int64 = long long;"],"description":"lli"},"long":{"prefix":"long","body":["using int64 = long long;"],"description":"long"},"lower_bound":{"prefix":"lower_bound","body":["template <typename T>\r\nint lower_bound(vector <T> arr, T x) {\r\n  int n = (int) arr.size();\r\n  int l = 0, h = n - 1;\r\n  int ans = -1;\r\n\r\n  while (l <= h) {\r\n    int m = l + (h - l) / 2;\r\n\r\n    if (x <= arr[m]) {  // a[m] can possibly be lower_bound\r\n      ans = m;\r\n      h = m - 1;\r\n    } else {\r\n      l = m + 1;\r\n    } \r\n  }\r\n\r\n  return ans == -1 ? n : ans;\r\n}\r\n"],"description":"lower_bound"},"lps":{"prefix":"lps","body":["vector <int> calc_lps(const string &pat) {\r\n  int n = pat.length();\r\n  vector <int> lps(n, 0);\r\n  int len = 0;\r\n  lps[0] = len;\r\n  for (int i = 1; i < n; i++) {\r\n    while (len > 0 && pat[len] != pat[i]) {\r\n      len = lps[len - 1];\r\n    }\r\n    if (pat[len] == pat[i]) {\r\n      len++;\r\n    }\r\n    lps[i] = len;\r\n  }\r\n  return lps;\r\n  //..lps[i] = the longest proper prefix of pat[0..i] which is also a suffix of pat[0..i].\r\n}\r\n"],"description":"lps"},"lucas":{"prefix":"lucas","body":["/// calculate nCk mod module with n, k is large number ~ 10^18, module is small number ~ 10^6\r\nstruct LucasTheorem {\r\n  long long mod;\r\n  vector<long long> fact, inv_fact;\r\n  const int limits = 4;\r\n  LucasTheorem(long long _mod) {\r\n    mod = _mod;\r\n    fact.assign(mod + 7, 0);\r\n    inv_fact.assign(mod + 7, 0);\r\n    fact[0] = 1;\r\n    for (int i = 1; i < mod; i++) {\r\n      fact[i] = fact[i - 1] * i % mod;\r\n    }\r\n    inv_fact[mod - 1] = inverse(fact[mod - 1]);\r\n    for (int i = mod - 2; i >= 0; i--) {\r\n      inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod;\r\n    }\r\n  }\r\n  long long power(long long b, long long e) {\r\n    long long res = 1;\r\n    b %= mod;\r\n    for (; e; e >>= 1, b = b * b % mod) {\r\n      if (e & 1) res = res * b % mod;\r\n    }\r\n    return res;\r\n  }\r\n\r\n  long long inverse(long long a) {\r\n    return power(a, mod - 2);\r\n  }\r\n  vector<int> modRepresent(long long n) {\r\n    vector<int> res;\r\n    while (n) {\r\n      res.push_back(n % mod);\r\n      n /= mod;\r\n    }\r\n    while (res.size() < limits) res.push_back(0);\r\n    return res;\r\n  }\r\n  long long nCk(long long n, long long k) {\r\n    if (k > n) return 0;\r\n    long long res = fact[n] * inv_fact[k] % mod;\r\n    res = res * inv_fact[n - k] % mod;\r\n    return res;\r\n  }\r\n  long long mod_nCk(long long n, long long k) {\r\n    vector<int> repN = modRepresent(n);\r\n    vector<int> repK = modRepresent(k);\r\n    long long res = 1;\r\n    for (int i = 0; i < limits; i++) {\r\n      res = res * nCk(repN[i], repK[i]) % mod;\r\n    }\r\n    return res;\r\n  }\r\n};"],"description":"lucas"},"main":{"prefix":"main","body":["import java.io.OutputStream;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.PrintWriter;\r\nimport java.util.StringTokenizer;\r\nimport java.io.IOException;\r\nimport java.io.BufferedReader;\r\nimport java.io.InputStreamReader;\r\n\r\npublic class Main {\r\n  \r\n  public static void main(String[] args) {\r\n    InputStream inputStream = System.in;\r\n    OutputStream outputStream = System.out;\r\n    InputReader in = new InputReader(inputStream);\r\n    PrintWriter out = new PrintWriter(outputStream);\r\n    Task solver = new Task();\r\n    solver.solve(in, out);\r\n    out.close();\r\n  }\r\n\r\n  static class Task {\r\n    public void solve(InputReader in, PrintWriter out) {\r\n      int n;\r\n      out.print(\"Enter a number : \");\r\n      n = in.nextInt();\r\n      out.println(\"You entered \" + n);\r\n      return;\r\n    }  \r\n  }\r\n\r\n  static class InputReader {\r\n    public BufferedReader reader;\r\n    public StringTokenizer tokenizer;\r\n    public InputReader(InputStream stream) {\r\n      reader = new BufferedReader(new InputStreamReader(stream), 32768);\r\n      tokenizer = null;\r\n    }\r\n    public String next() {\r\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\r\n        try {\r\n          tokenizer = new StringTokenizer(reader.readLine());\r\n        } catch (IOException e) {\r\n          throw new RuntimeException(e);\r\n        }\r\n      }\r\n      return tokenizer.nextToken();\r\n    }\r\n    public int nextInt() {\r\n      return Integer.parseInt(next());\r\n    }\r\n  }\r\n}"],"description":"main"},"manacher":{"prefix":"manacher","body":["template <typename T>\r\nvector<int> manacher(int n, const T &s) {\r\n  if (n == 0) {\r\n    return vector<int>();\r\n  }\r\n  vector<int> res(2 * n - 1, 0);\r\n  int l = -1, r = -1;\r\n  for (int z = 0; z < 2 * n - 1; z++) {\r\n    int i = (z + 1) >> 1;\r\n    int j = z >> 1;\r\n    int p = (i >= r ? 0 : min(r - i, res[2 * (l + r) - z]));\r\n    while (j + p + 1 < n && i - p - 1 >= 0) {\r\n      if (!(s[j + p + 1] == s[i - p - 1])) {\r\n        break;\r\n      }\r\n      p++;\r\n    }\r\n    if (j + p > r) {\r\n      l = i - p;\r\n      r = j + p;\r\n    }\r\n    res[z] = p;\r\n  }\r\n  return res;\r\n}\r\n \r\ntemplate <typename T>\r\nvector<int> manacher(const T &s) {\r\n  return manacher((int) s.size(), s);\r\n}\r\n\r\n// based on ideserve youtube channel\r\n// a   b   c   d   e\r\n// 0 1 2 3 4 5 6 7 8 9\r\ntemplate <typename T>\r\nvector<int> manacher(const T &s) {\r\n  int n = (int) s.length();\r\n  vector<int> lps(n, 0);\r\n  int c = 0, r = 0;\r\n  for (int i = 1; i < n; i++) {\r\n    if (r > i) {\r\n      lps[i] = min(r - i, lps[c - (i - c)]);\r\n    }\r\n    while (i + (lps[i] + 1) < n && i - (lps[i] + 1) >= 0) {\r\n      if (s[i + (lps[i] + 1)] !=  s[i - (lps[i] + 1)]) {\r\n        break;\r\n      }\r\n      lps[i]++; \r\n    } \r\n    if (i + lps[i] > r) {\r\n      c = i;\r\n      r = i + lps[i];\r\n    } \r\n  }\r\n  return lps; \r\n}\r\n\r\npair <int, int> Odd(vector <int>& lps, int i) {\r\n  int l = i - lps[2 * i] / 2;\r\n  int r = i + lps[2 * i] / 2;\r\n  return make_pair(l, r);            \r\n}\r\n\r\npair <int, int> Even(vector <int>& lps, int i) {\r\n  if (lps[2 * i + 1] > 0) {\r\n    int l = i - (lps[2 * i + 1] - 1) / 2;\r\n    int r = i + (lps[2 * i + 1] - 1) / 2 + 1;\r\n    return make_pair(l, r);\r\n  }\r\n  return make_pair(-1, -1);\r\n};\r\n\r\n\r\n//Mine\r\nvoid manacher(const string& str) {\r\n  int idx = 0;\r\n  int len = 2 * (int) str.length() + 1;\r\n  vector <char> arr(len);\r\n  //arr looks like : $b$a$b.....$\r\n\r\n  for (int i = 0; i < len; i++) {\r\n    if (i % 2 != 0) {\r\n      arr[i] = str[idx++];\r\n    } else {\r\n      arr[i] = '$';\r\n    }\r\n  }\r\n                               \r\n  vector <int> lps(len, 0);\r\n  int l = 0;\r\n  int h = 0;\r\n  //here m is the center.\r\n  for (int m = 0; m < len; ) {\r\n    while (l > 0 && h < len - 1 && arr[l - 1] == arr[h + 1]) {\r\n      l--;\r\n      h++;\r\n    }\r\n    lps[m] = h - l + 1;\r\n\r\n    if (h == len - 1) {\r\n      //we could simply break here if remaining lps is not required\r\n      for (int j = m + 1; j <= h; j++) {\r\n        lps[j] = min(lps[m - (j - m)], 2 * (h - j) + 1);\r\n      }    \r\n      break;\r\n    }\r\n\r\n    //center : even m => h + 1, odd m => h\r\n    int center = h + 1; //(m % 2 == 0 ? 1 : 0);\r\n    for (int j = m + 1; j <= h; j++) {\r\n      lps[j] = min(lps[m - (j - m)], 2 * (h - j) + 1);\r\n      if (j + lps[m - (j - m)] / 2 == h) {\r\n        center = j;\r\n        break;\r\n      }\r\n    }\r\n\r\n    m = center;\r\n    h = m + lps[m] / 2;\r\n    l = m - lps[m] / 2;\r\n  }\r\n\r\n  vector <int> even; \r\n  vector <int> odd;\r\n\r\n  //lps value of last '$' is useless\r\n  //for even count mid taken at left of i\r\n      \r\n  for (int i = 0; i < len - 1; i++) {\r\n    if (i % 2 == 0) even.push_back(lps[i] / 2);\r\n    else odd.push_back(lps[i] / 2);\r\n  } \r\n\r\n  //form longest palindromic substring \r\n  int cnt = INT_MIN;\r\n  int from = 0;\r\n  for (int i = 0; i < len; i++) {\r\n    int val = lps[i];\r\n    if (val > cnt) {\r\n      cnt = val;\r\n      from = i;\r\n    } \r\n  }\r\n  \r\n  //form longest palindromic substring\r\n  int s = from - cnt / 2;\r\n  int e = from + cnt / 2;\r\n  string ans;\r\n  for (int i = s; i <= e; i++) {\r\n    if (arr[i] == '$') continue;\r\n    ans.push_back(arr[i]);\r\n  } \r\n  cout << ans << endl;\r\n}\r\n"],"description":"manacher"},"mat":{"prefix":"mat","body":["for (int i = 0; i < n; i++) {\r\n  for (int j = 0; j < m; j++) {\r\n  \r\n  } \r\n} \r\n"],"description":"mat"},"mat_sum":{"prefix":"mat_sum","body":["auto get = [&](int x, int y, int xx, int yy) {\r\n  int h = mat[xx][yy];\r\n  int l = 0;\r\n  l += x - 1 >= 0 ? mat[x - 1][yy] : 0;\r\n  l += y - 1 >= 0 ? mat[xx][y - 1] : 0;\r\n  l -= (x - 1 >= 0 && y - 1 >= 0) ? mat[x - 1][y - 1] : 0;\r\n  return h - l; \r\n};"],"description":"mat_sum"},"matching":{"prefix":"matching","body":["/**\r\n1) Initialize Maximal Matching M as empty.\r\n2) While there exists an Augmenting Path p\r\n     Remove matching edges of p from M and add not-matching edges of p to M\r\n     (This increases size of M by 1 as p starts and ends with a free vertex)\r\n3) Return M. \r\nverified agaist AOJ GRL_7_A\r\n*/\r\n/*\r\nclass Graph {\r\nprivate:\r\n  int L;\r\n  int R;\r\n  vector <vector <int>> adj;\r\n  vector <int> level;\r\n  vector <int> mate;\r\n  bool levelize();\r\n  bool dfs(int u);\r\n\r\npublic:\r\n  Graph(int L, int R);    \r\n  void addEdge(int u, int v);\r\n  int matching(); \r\n};\r\n\r\nGraph::Graph(int L, int R) {\r\n  this->L = L;\r\n  this->R = R;\r\n  adj.resize(L + R);\r\n  level.resize(L);\r\n  mate.resize(L + R);\r\n}\r\n\r\n\r\nvoid Graph::addEdge(int u, int v) {\r\n  adj[u].push_back(v + L);\r\n  adj[v + L].push_back(u);\r\n}\r\n\r\nbool Graph::levelize() {\r\n  queue <int> q;\r\n  for (int u = 0; u < L; u++) {\r\n    level[u] = -1;\r\n    if (mate[u] == -1) {\r\n      level[u] = 0;\r\n      q.push(u);\r\n    }\r\n  }\r\n         \r\n  while (!q.empty()) {\r\n    int u = q.front();\r\n    q.pop();\r\n\r\n    for (int w : adj[u]) {\r\n      int v = mate[w];\r\n      if (v == -1) {\r\n        return true;\r\n      }\r\n\r\n      if (level[v] == -1) {\r\n        level[v] = level[u] + 1;\r\n        q.push(v);\r\n      } \r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nbool Graph::dfs(int u) {\r\n  for (int w : adj[u]) {\r\n    int v = mate[w];\r\n    if (v == -1 || (level[v] == level[u] + 1 && dfs(v))) {\r\n      mate[u] = w;\r\n      mate[w] = u;\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nint Graph::matching() {\r\n  int match = 0;\r\n  fill(mate.begin(), mate.end(), -1);\r\n\r\n  while (levelize()) {\r\n    for (int u = 0; u < L; u++) {\r\n      if (mate[u] == -1 && dfs(u)) {\r\n        match++;\r\n      }\r\n    }\r\n  }\r\n  return match; \r\n} \r\n\r\nint main() {\r\n  int L, R, E;\r\n  cin >> L >> R >> E;\r\n  int u, v; \r\n  Graph g(L, R);\r\n  for (int i = 0; i < E; i++) {\r\n    cin >> u >> v;\r\n    g.addEdge(u, v);\r\n  }\r\n  cout << g.matching() << '\\n';\r\n  return 0;\r\n} \r\n*/\r\n\r\n//Hoftcoft-Karp Mathing Algorithm\r\nclass matching {\r\n public:\r\n  vector<vector<int>> g;\r\n  vector<int> pa;\r\n  vector<int> pb;\r\n  vector<int> was;\r\n  int n, m;\r\n  int res;\r\n  int iter;\r\n \r\n  matching(int _n, int _m) : n(_n), m(_m) {\r\n    assert(0 <= n && 0 <= m);\r\n    pa = vector<int>(n, -1);\r\n    pb = vector<int>(m, -1);\r\n    was = vector<int>(n, 0);\r\n    g.resize(n);\r\n    res = 0;\r\n    iter = 0;\r\n  }\r\n \r\n  void add(int from, int to) {\r\n    assert(0 <= from && from < n && 0 <= to && to < m);\r\n    g[from].push_back(to);\r\n  }\r\n \r\n  bool dfs(int v) {\r\n    was[v] = iter;\r\n    for (int u : g[v]) {\r\n      if (pb[u] == -1) {\r\n        pa[v] = u;\r\n        pb[u] = v;\r\n        return true;\r\n      }\r\n    }\r\n    for (int u : g[v]) {\r\n      if (was[pb[u]] != iter && dfs(pb[u])) {\r\n        pa[v] = u;\r\n        pb[u] = v;\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n \r\n  int solve() {\r\n    while (true) {\r\n      iter++;\r\n      int add = 0;\r\n      for (int i = 0; i < n; i++) {\r\n        if (pa[i] == -1 && dfs(i)) {\r\n          add++;\r\n        }\r\n      }\r\n      if (add == 0) {\r\n        break;\r\n      }\r\n      res += add;\r\n    }\r\n    return res;\r\n  }\r\n \r\n  int run_one(int v) {\r\n    if (pa[v] != -1) {\r\n      return 0;\r\n    }\r\n    iter++;\r\n    return (int) dfs(v);\r\n  }\r\n};"],"description":"matching"},"matrix":{"prefix":"matrix","body":["template <typename T> \r\nstring to_string(vector <vector<T>> &mat) {\r\n  string res = \"\";\r\n  char temp[32];\r\n  int n = mat.size();\r\n  if (n == 0) return res;\r\n  res += \"\\n\";\r\n  for (int i = 0; i < n; i++) {\r\n    for (int j = 0; j < (int) mat[i].size(); j++) {\r\n      sprintf(temp, \"%-2s\", to_string(mat[i][j]).c_str());\r\n      res += string(temp);\r\n    }\r\n    res += \"\\n\";\r\n  }\r\n  return res;\r\n}\r\n"],"description":"matrix"},"max":{"prefix":"max","body":["#define max(...) max({__VA_ARGS__})"],"description":"max"},"max_flow":{"prefix":"max_flow","body":["/*\r\n// ..Mine\r\nusing Dinic's maxflow (V * V * E) uses BFS : dinic\r\nusing push-relabel method (V * V * E) : push_relabel\r\nusing Ford-Fulkerson maxflow (E * F) uses DFS : ford_fulkerson\r\nusing Endmond-Karp (V * E * E) uses BFS : endmond_karp\r\n*/\r\n\r\ntemplate <typename T>\r\nclass flow_graph {\r\n public:\r\n  static constexpr T eps = (T) 1e-9;\r\n \r\n  struct edge {\r\n    int from;\r\n    int to;\r\n    T c;\r\n    T f;\r\n  };\r\n \r\n  vector<vector<int>> g;\r\n  vector<edge> edges;\r\n  int n;\r\n  int st;\r\n  int fin;\r\n  T flow;\r\n \r\n  flow_graph(int _n, int _st, int _fin) : n(_n), st(_st), fin(_fin) {\r\n    assert(0 <= st && st < n && 0 <= fin && fin < n && st != fin);\r\n    g.resize(n);\r\n    flow = 0;\r\n  }\r\n \r\n  void clear_flow() {\r\n    for (const edge &e : edges) {\r\n      e.f = 0;\r\n    }\r\n    flow = 0;\r\n  }\r\n   \r\n  int add(int from, int to, T forward_cap, T backward_cap) {\r\n    assert(0 <= from && from < n && 0 <= to && to < n);\r\n    int id = (int) edges.size();\r\n    g[from].push_back(id);\r\n    edges.push_back({from, to, forward_cap, 0});\r\n    g[to].push_back(id + 1);\r\n    edges.push_back({to, from, backward_cap, 0});\r\n    return id;\r\n  }\r\n};\r\n \r\ntemplate <typename T>\r\nclass dinic {\r\n public:\r\n  flow_graph<T> &g;\r\n \r\n  vector<int> ptr;\r\n  vector<int> d;\r\n  vector<int> q;\r\n \r\n  dinic(flow_graph<T> &_g) : g(_g) {\r\n    ptr.resize(g.n);\r\n    d.resize(g.n);\r\n    q.resize(g.n);\r\n  }\r\n \r\n  bool expath() {\r\n    fill(d.begin(), d.end(), -1);\r\n    q[0] = g.fin;\r\n    d[g.fin] = 0;\r\n    int beg = 0, end = 1;\r\n    while (beg < end) {\r\n      int i = q[beg++];\r\n      for (int id : g.g[i]) {\r\n        const auto &e = g.edges[id];\r\n        const auto &back = g.edges[id ^ 1];\r\n        if (back.c - back.f > g.eps && d[e.to] == -1) {\r\n          d[e.to] = d[i] + 1;\r\n          if (e.to == g.st) {\r\n            return true;\r\n          }\r\n          q[end++] = e.to;\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n   \r\n  T dfs(int v, T w) {\r\n    if (v == g.fin) {\r\n      return w;\r\n    }\r\n    int &j = ptr[v];\r\n    while (j >= 0) {\r\n      int id = g.g[v][j];\r\n      const auto &e = g.edges[id];\r\n      if (e.c - e.f > g.eps && d[e.to] == d[v] - 1) {\r\n        T t = dfs(e.to, min(e.c - e.f, w));\r\n        if (t > g.eps) {\r\n          g.edges[id].f += t;\r\n          g.edges[id ^ 1].f -= t;\r\n          return t;\r\n        }\r\n      }\r\n      j--;\r\n    }\r\n    return 0;\r\n  }\r\n \r\n  T max_flow() {\r\n    while (expath()) {\r\n      for (int i = 0; i < g.n; i++) {\r\n        ptr[i] = (int) g.g[i].size() - 1;\r\n      }\r\n      T big_add = 0;\r\n      while (true) {\r\n        T add = dfs(g.st, numeric_limits<T>::max());\r\n        if (add <= g.eps) {\r\n          break;\r\n        }\r\n        big_add += add;\r\n      }\r\n      if (big_add <= g.eps) {\r\n        break;\r\n      }\r\n      g.flow += big_add;\r\n    }\r\n    return g.flow;\r\n  }\r\n \r\n  vector<bool> min_cut() {\r\n    max_flow();\r\n    vector<bool> ret(g.n);\r\n    for (int i = 0; i < g.n; i++) {\r\n      ret[i] = (d[i] != -1);\r\n    }\r\n    return ret;\r\n  }\r\n};"],"description":"max_flow"},"mcmf":{"prefix":"mcmf","body":["template <typename T, typename C>\r\nclass MCMF {\r\n public:\r\n  static constexpr T eps = (T) 1e-9;\r\n \r\n  struct edge {\r\n    int from;\r\n    int to;\r\n    T c;\r\n    T f;\r\n    C cost;\r\n  };\r\n \r\n  int n;\r\n  vector<vector<int>> g;\r\n  vector<edge> edges;\r\n  vector<C> d;\r\n  vector<C> pot;\r\n  __gnu_pbds::priority_queue<pair<C, int>> q;\r\n  vector<typename decltype(q)::point_iterator> its;\r\n  vector<int> pe;\r\n  const C INF_C = numeric_limits<C>::max() / 2;\r\n \r\n  explicit MCMF(int n_) : n(n_), g(n), d(n), pot(n, 0), its(n), pe(n) {}\r\n \r\n  int add(int from, int to, T forward_cap, T backward_cap, C edge_cost) {\r\n    assert(0 <= from && from < n && 0 <= to && to < n);\r\n    assert(forward_cap >= 0 && backward_cap >= 0);\r\n    int id = static_cast<int>(edges.size());\r\n    g[from].push_back(id);\r\n    edges.push_back({from, to, forward_cap, 0, edge_cost});\r\n    g[to].push_back(id + 1);\r\n    edges.push_back({to, from, backward_cap, 0, -edge_cost});\r\n    return id;\r\n  }\r\n \r\n  void expath(int st) {\r\n    fill(d.begin(), d.end(), INF_C);\r\n    q.clear();\r\n    fill(its.begin(), its.end(), q.end());\r\n    its[st] = q.push({pot[st], st});\r\n    d[st] = 0;\r\n    while (!q.empty()) {\r\n      int i = q.top().second;\r\n      q.pop();\r\n      its[i] = q.end();\r\n      for (int id : g[i]) {\r\n        const edge &e = edges[id];\r\n        int j = e.to;\r\n        if (e.c - e.f > eps && d[i] + e.cost < d[j]) {\r\n          d[j] = d[i] + e.cost;\r\n          pe[j] = id;\r\n          if (its[j] == q.end()) {\r\n            its[j] = q.push({pot[j] - d[j], j});\r\n          } else {\r\n            q.modify(its[j], {pot[j] - d[j], j});\r\n          }\r\n        }\r\n      }\r\n    }\r\n    swap(d, pot);\r\n  }\r\n   \r\n  pair<T, C> max_flow_min_cost(int st, int fin) {\r\n    T flow = 0;\r\n    C cost = 0;\r\n    bool ok = true;\r\n    for (auto& e : edges) {\r\n      if (e.c - e.f > eps && e.cost + pot[e.from] - pot[e.to] < 0) {\r\n        ok = false;\r\n        break;\r\n      }\r\n    }\r\n    if (ok) {\r\n      expath(st);\r\n    } else {\r\n      vector<int> deg(n, 0);\r\n      for (int i = 0; i < n; i++) {\r\n        for (int eid : g[i]) {\r\n          auto& e = edges[eid];\r\n          if (e.c - e.f > eps) {\r\n            deg[e.to] += 1;\r\n          }\r\n        }\r\n      }\r\n      vector<int> que;\r\n      for (int i = 0; i < n; i++) {\r\n        if (deg[i] == 0) {\r\n          que.push_back(i);\r\n        }\r\n      }\r\n      for (int b = 0; b < (int) que.size(); b++) {\r\n        for (int eid : g[que[b]]) {\r\n          auto& e = edges[eid];\r\n          if (e.c - e.f > eps) {\r\n            deg[e.to] -= 1;\r\n            if (deg[e.to] == 0) {\r\n              que.push_back(e.to);\r\n            }\r\n          }\r\n        }\r\n      }\r\n      fill(pot.begin(), pot.end(), INF_C);\r\n      pot[st] = 0;\r\n      if (static_cast<int>(que.size()) == n) {\r\n        for (int v : que) {\r\n          if (pot[v] < INF_C) {\r\n            for (int eid : g[v]) {\r\n              auto& e = edges[eid];\r\n              if (e.c - e.f > eps) {\r\n                if (pot[v] + e.cost < pot[e.to]) {\r\n                  pot[e.to] = pot[v] + e.cost;\r\n                  pe[e.to] = eid;\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      } else {\r\n        que.assign(1, st);\r\n        vector<bool> in_queue(n, false);\r\n        in_queue[st] = true;\r\n        for (int b = 0; b < (int) que.size(); b++) {\r\n          int i = que[b];\r\n          in_queue[i] = false;\r\n          for (int id : g[i]) {\r\n            const edge &e = edges[id];\r\n            if (e.c - e.f > eps && pot[i] + e.cost < pot[e.to]) {\r\n              pot[e.to] = pot[i] + e.cost;\r\n              pe[e.to] = id;\r\n              if (!in_queue[e.to]) {\r\n                que.push_back(e.to);\r\n                in_queue[e.to] = true;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    while (pot[fin] < INF_C) {\r\n      T push = numeric_limits<T>::max();\r\n      int v = fin;\r\n      while (v != st) {\r\n        const edge &e = edges[pe[v]];\r\n        push = min(push, e.c - e.f);\r\n        v = e.from;\r\n      }\r\n      v = fin;\r\n      while (v != st) {\r\n        edge &e = edges[pe[v]];\r\n        e.f += push;\r\n        edge &back = edges[pe[v] ^ 1];\r\n        back.f -= push;\r\n        v = e.from;\r\n      }\r\n      flow += push;\r\n      cost += push * pot[fin];\r\n      expath(st);\r\n    }\r\n    return {flow, cost};\r\n  }\r\n};\r\n\r\n\r\n/*\r\n * initial implementation\r\n\r\ntemplate <typename T, typename C>\r\nclass mcmf {\r\n public:\r\n  static constexpr T eps = (T) 1e-9;\r\n \r\n  struct edge {\r\n    int from;\r\n    int to;\r\n    T c;\r\n    T f;\r\n    C cost;\r\n  };\r\n \r\n  vector<vector<int>> g;\r\n  vector<edge> edges;\r\n  vector<C> d;\r\n  vector<int> q;\r\n  vector<bool> in_queue;\r\n  vector<int> pe;\r\n  int n;\r\n  int st, fin;\r\n  T flow;\r\n  C cost;\r\n \r\n  mcmf(int _n, int _st, int _fin) : n(_n), st(_st), fin(_fin) {\r\n    assert(0 <= st && st < n && 0 <= fin && fin < n && st != fin);\r\n    g.resize(n);\r\n    d.resize(n);\r\n    in_queue.resize(n);\r\n    pe.resize(n);\r\n    flow = 0;\r\n    cost = 0;\r\n  }\r\n \r\n  void clear_flow() {\r\n    for (const edge &e : edges) {\r\n      e.f = 0;\r\n    }\r\n    flow = 0;\r\n  }\r\n   \r\n  void add(int from, int to, T forward_cap, T backward_cap, C cost) {\r\n    assert(0 <= from && from < n && 0 <= to && to < n);\r\n    g[from].push_back((int) edges.size());\r\n    edges.push_back({from, to, forward_cap, 0, cost});\r\n    g[to].push_back((int) edges.size());\r\n    edges.push_back({to, from, backward_cap, 0, -cost});\r\n  }\r\n \r\n  bool expath() {\r\n    fill(d.begin(), d.end(), numeric_limits<C>::max());\r\n    q.clear();\r\n    q.push_back(st);\r\n    d[st] = 0;\r\n    in_queue[st] = true;\r\n    int beg = 0;\r\n    bool found = false;\r\n    while (beg < (int) q.size()) {\r\n      int i = q[beg++];\r\n      if (i == fin) {\r\n        found = true;\r\n      }\r\n      in_queue[i] = false;\r\n      for (int id : g[i]) {\r\n        const edge &e = edges[id];\r\n        if (e.c - e.f > eps && d[i] + e.cost < d[e.to]) {\r\n          d[e.to] = d[i] + e.cost;\r\n          pe[e.to] = id;\r\n          if (!in_queue[e.to]) {\r\n            q.push_back(e.to);\r\n            in_queue[e.to] = true;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    if (found) {\r\n      T push = numeric_limits<T>::max();\r\n      int v = fin;\r\n      while (v != st) {\r\n        const edge &e = edges[pe[v]];\r\n        push = min(push, e.c - e.f);\r\n        v = e.from;\r\n      }\r\n      v = fin;\r\n      while (v != st) {\r\n        edge &e = edges[pe[v]];\r\n        e.f += push;\r\n        edge &back = edges[pe[v] ^ 1];\r\n        back.f -= push;\r\n        v = e.from;\r\n      }\r\n      flow += push;\r\n      cost += push * d[fin];\r\n    }\r\n    return found;\r\n  }\r\n   \r\n  pair<T, C> max_flow_min_cost() {\r\n    while (expath()) {}\r\n    return {flow, cost};\r\n  }\r\n};\r\n* /\r\n"],"description":"mcmf"},"merge":{"prefix":"merge","body":["template <typename T>\r\nvector <pair <T, T>> merge(vector<pair<T, T>> &gap) {\r\n  int n = gap.size();\r\n  vector <pair <T, T> > ans;\r\n  sort(gap.begin(), gap.end());  \r\n  T l = gap[0].first, h = gap[0].second;\r\n  for (int i = 0; i< n; i++) {\r\n    if (gap[i].first <= h) {\r\n      h = max(h, gap[i].second);\r\n    } else {\r\n      ans.push_back(make_pair(l, h));\r\n      l = gap[i].first, h = gap[i].second;\r\n    } \r\n  }\r\n  ans.push_back(make_pair(l, h));\r\n  return ans;  \r\n  //returns the merged intervals in sorted order\r\n}"],"description":"merge"},"min":{"prefix":"min","body":["#define min(...) min({__VA_ARGS__})"],"description":"min"},"mint":{"prefix":"mint","body":["template <typename T>\r\nT power(T a, long long b) {\r\n  T r = 1;\r\n  while (b > 0) {\r\n    if (b & 1) {\r\n      r *= a;\r\n    }\r\n    a *= a;\r\n    b >>= 1;\r\n  }\r\n  return r;\r\n}\r\n \r\ntemplate <typename T>\r\nT inverse(T a, T m) {\r\n  a %= m;\r\n  if (a < 0) {\r\n    a += m;\r\n  }\r\n  T b = m, u = 0, v = 1;\r\n  while (a) {\r\n    T t = b / a;\r\n    b -= a * t;\r\n    swap(a, b);\r\n    u -= v * t;\r\n    swap(u, v);\r\n  }\r\n  if (u < 0) {\r\n    u += m;\r\n  }\r\n  return u;\r\n}\r\n \r\ntemplate <int _P>\r\nstruct modnum {\r\n  static constexpr int P = _P;\r\n private:\r\n  int v;\r\n public:\r\n  modnum() : v(0) { }\r\n  modnum(long long _v) {\r\n    v = (int) (_v % P);\r\n    if (v < 0) {\r\n      v += P;\r\n    }\r\n  }\r\n  explicit operator int() const {\r\n    return v;\r\n  }\r\n  bool operator==(const modnum& o) const {\r\n    return v == o.v;\r\n  }\r\n  bool operator!=(const modnum& o) const {\r\n    return v != o.v;\r\n  }\r\n  modnum inverse() const {\r\n    return modnum(::inverse(v, P));\r\n  }\r\n  modnum operator-() const {\r\n    return modnum(v ? P - v : 0);\r\n  }\r\n  modnum operator+() const {\r\n    return *this;\r\n  }\r\n  modnum& operator++() {\r\n    v++;\r\n    if (v == P) {\r\n      v = 0;\r\n    }\r\n    return *this;\r\n  }\r\n  modnum& operator--() {\r\n    if (v == 0) {\r\n      v = P;\r\n    }\r\n    v--;\r\n    return *this;\r\n  }\r\n  modnum operator++(int) {\r\n    modnum r = *this;\r\n    ++*this;\r\n    return r;\r\n  }\r\n  modnum operator--(int) {\r\n    modnum r = *this;\r\n    --*this;\r\n    return r;\r\n  }\r\n  modnum& operator+=(const modnum& o) {\r\n    v += o.v;\r\n    if (v >= P) {\r\n      v -= P;\r\n    }\r\n    return *this;\r\n  }\r\n  modnum operator+(const modnum& o) const {\r\n    return modnum(*this) += o;\r\n  }\r\n  modnum& operator-=(const modnum& o) {\r\n    v -= o.v;\r\n    if (v < 0) {\r\n      v += P;\r\n    }\r\n    return *this;\r\n  }\r\n  modnum operator-(const modnum& o) const {\r\n    return modnum(*this) -= o;\r\n  }\r\n  modnum& operator*=(const modnum& o) {\r\n    v = (int) ((long long) v * o.v % P);\r\n    return *this;\r\n  }\r\n  modnum operator*(const modnum& o) const {\r\n    return modnum(*this) *= o;\r\n  }\r\n  modnum& operator/=(const modnum& o) {\r\n    return *this *= o.inverse();\r\n  }\r\n  modnum operator/(const modnum& o) const {\r\n    return modnum(*this) /= o;\r\n  }\r\n};\r\n\r\ntemplate <int _P>\r\nstring to_string(const modnum<_P>& n) {\r\n  return to_string((int)n);\r\n}\r\n \r\ntemplate <int _P>\r\nostream& operator<<(ostream& out, const modnum<_P>& n) {\r\n  return out << int(n);\r\n}\r\n \r\ntemplate <int _P>\r\nistream& operator>>(istream& in, modnum<_P>& n) {\r\n  long long _v;\r\n  in >> _v;\r\n  n = modnum<_P>(_v);\r\n  return in;\r\n}\r\n\r\nconst int mod = (int) (1e9 + 7); \r\nusing mint = modnum<mod>;"],"description":"mint"},"mo":{"prefix":"mo","body":["struct query {\r\n  int when;\r\n  int L;\r\n  int H;\r\n};\r\n\r\ntemplate <typename T>\r\nclass mo {\r\n public:\r\n  map <int, int> mp...\r\n  set <int> st...\r\n  vector <int> fre...\r\n  int ans = ...\r\n  inline void _init() {\r\n    ..init above variables\r\n  }  \r\n  inline void add(int i) {\r\n    ...add arr[i]\r\n  }\r\n\r\n  inline void rem(int i) {\r\n    ...remove arr[i]\r\n  }\r\n  inline ... get() {\r\n    ... get answer\r\n  } \r\n\r\n  vector <T> arr;\r\n  int size;\r\n\r\n  mo(vector <T> &_arr) {\r\n    arr = _arr;\r\n    int n = _arr.size();\r\n    size = (int) sqrt(n + 0.1) + 1;\r\n  } \r\n  \r\n  vector <...> get(vector <query>& queries) {  \r\n    int qq = queries.size();\r\n    int n = arr.size();\r\n    auto comp = [&](auto &a, auto &b) ->bool {\r\n      int ax = a.L / size;\r\n      int bx = b.L / size;\r\n      if (ax == bx) {\r\n        return a.H < b.H;\r\n      }  \r\n      return ax < bx;\r\n    };\r\n    sort(queries.begin(), queries.end(), comp);\r\n    int L = 0, H = -1;\r\n    vector <...> ret(qq);\r\n    _init();\r\n    for (query &q : queries) {\r\n      assert(0 <= q.L && q.L < n && 0 <= q.H && q.H < n);\r\n      while (L > q.L) { L--; add(L); }\r\n      while (H < q.H) { H++; add(H); }\r\n      while (L < q.L) { rem(L); L++; }\r\n      while (H > q.H) { rem(H); H--; }\r\n      ret[q.when] = get();\r\n    }\r\n    return ret;\r\n  } \r\n};\r\n\r\n...mo<int> m(arr)\r\n...vector <...> ans = m.get(queries);"],"description":"mo"},"mod":{"prefix":"mod","body":["const int mod = (int) (1e9 + 7);"],"description":"mod"},"modi":{"prefix":"modi","body":["/*for mod not prime, but a and mod are co-prime\r\ninline int inv(int a, int md) {\r\n  a %= md;\r\n  if (a < 0) a += md;\r\n  int b = md, u = 0, v = 1;\r\n  while (a) {\r\n    int t = b / a;\r\n    b -= t * a; swap(a, b);\r\n    u -= t * v; swap(u, v);\r\n  }\r\n  assert(b == 1);\r\n  if (u < 0) u += md;\r\n  return u;\r\n}\r\n\r\n//OR\r\nint inv(int a, int md) {\r\n  int x, y;\r\n  int g = extended_gcd(a, md, x, y);\r\n  if (g != 1) {\r\n    cerr << \"No inverse exists\" << endl;\r\n    return 0;\r\n  } else {\r\n    x = (x % md + md) % md;\r\n    return x;\r\n  }  \r\n} \r\n*/\r\n"],"description":"modi"},"mst":{"prefix":"mst","body":["//prims spanning tree. very much similar to dijkstra\r\ntemplate <typename T>\r\nvector <int> mst(const undigraph<T> &g, T &ans) {\r\n  priority_queue<pair<T, int>, vector<pair<T, int> >, greater<pair<T, int> > > s;\r\n  vector<T> dist(g.n, numeric_limits<T>::max());\r\n  vector <bool> in_mst(g.n, false);\r\n  vector <int> ans_list(g.n - 1);\r\n  \r\n  int start = 0;\r\n  dist[start] = 0;\r\n  s.emplace(dist[start], start);\r\n  while (!s.empty()) {\r\n    pair <T, int> pr = s.top(); \r\n    s.pop();\r\n    int u = pr.second;\r\n    in_mst[u] = true;\r\n    for (int id : g.g[u]) {\r\n      auto &e = g.edges[id];\r\n      int v = e.from ^ e.to ^ u;\r\n      if (!in_mst[v] && e.cost < dist[v]) {\r\n        dist[v] = e.cost;\r\n        ans_list[v - 1] = id;\r\n        s.emplace(dist[v], v);\r\n      } \r\n    }\r\n  }\r\n\r\n  ans = 0;\r\n  for (int i = 0; i < g.n; i++) {\r\n    ans += dist[i];\r\n  } \r\n  return ans_list;\r\n  //returns edge ids of minimum \"spanning\" forest\r\n}\r\n\r\n//kruskal's mst using disjoint set union\r\ntemplate <typename T>\r\nvector<int> mst(const undigraph<T> &g, T &ans) {\r\n  vector<int> order(g.edges.size());\r\n  iota(order.begin(), order.end(), 0);\r\n  sort(order.begin(), order.end(), [&g](int a, int b) {\r\n    return g.edges[a].cost < g.edges[b].cost;\r\n  });\r\n  dsu d(g.n);\r\n  vector<int> ans_list;\r\n  ans = 0;\r\n  for (int id : order) {\r\n    auto &e = g.edges[id];\r\n    if (d.get(e.from) != d.get(e.to)) {\r\n      d.unite(e.from, e.to);\r\n      ans_list.push_back(id);\r\n      ans += e.cost;\r\n    }\r\n  }\r\n  return ans_list;\r\n  //returns edge ids of minimum \"spanning\" forest\r\n}\r\n \r\n"],"description":"mst"},"mul":{"prefix":"mul","body":["inline int mul(int a, int b) {\r\n  long long res = (long long) a * b;\r\n  a = (int) (res % mod);\r\n  if (a < 0) {\r\n    a += mod;\r\n  }\r\n  return a;\r\n}\r\n"],"description":"mul"},"ncr":{"prefix":"ncr","body":["//..ncr table for variable n and r\r\nconst int N = ...;\r\nint C[N + 1][N + 1];\r\nint calc_C() {\r\n  C[0][0] = 1;\r\n  for (int n = 1; n <= N; n++) {\r\n    C[n][0] = C[n][n] = 1;\r\n    for (int k = 1; k < n; k++) {\r\n      C[n][k] = C[n - 1][k - 1] + C[n - 1][k];\r\n    }\r\n  }\r\n}\r\n\r\n//..ncr table for fixed n and variable r\r\nconst int N = ...;\r\nint C[N + 1];\r\nvoid calc_C(int n = N) {\r\n  memset(C, 0, sizeof(C));\r\n  C[0] = 1; \r\n  for (int i = 1; i <= n; i++) {\r\n    for (int j = i; j > 0; j--) {\r\n      C[j] = C[j] + C[j - 1];\r\n    }\r\n  }\r\n} \r\n\r\n\r\n//..ncr value for specific n and specific r\r\ninline int C(int n, int r) {\r\n  if (r < 0 || r > n) {\r\n    return 0;\r\n  }\r\n  r = min(r, n - r);\r\n  int res = 1;\r\n  for (int i = 0; i < r; i++) {\r\n    res *= (n - i);\r\n    res /= (i + 1);\r\n  }\r\n  return res;\r\n}\r\n\r\n//..under mod using ncr = n! / ((n - r) ! * r!)\r\ntemplate< typename T >\r\nclass combination {\r\n public:\r\n  vector <T> fact;\r\n  vector <T> ifact;\r\n  combination(int N) : fact(N + 1), ifact(N + 1) {\r\n    fact[0] = 1;\r\n    for (int i = 1; i <= N; i++) {\r\n      fact[i] = fact[i - 1] * i;\r\n    }\r\n    ifact[N] = 1 / fact[N];\r\n    for (int i = N - 1; i >= 0; i--) {\r\n      ifact[i] = ifact[i + 1] * (i + 1);\r\n    }\r\n  } \r\n  T P(int n, int r) const {\r\n    if (r < 0 || n < r) return 0;\r\n    return fact[n] * ifact[n - r];\r\n  }\r\n \r\n  T C(int n, int r) const {\r\n    if (r < 0 || n < r) return 0;\r\n    return fact[n] * ifact[r] * ifact[n - r];\r\n  }\r\n \r\n  T H(int n, int r) const {\r\n    if (n < 0 || r < 0) return 0;\r\n    return r == 0 ? 1 : C(n + r - 1, r);\r\n  }\r\n};"],"description":"ncr"},"ninf":{"prefix":"ninf","body":["const int ninf = numeric_limits<int>::min();"],"description":"ninf"},"nm":{"prefix":"nm","body":["for (int i = 0; i < n; i++) {\r\n  for (int j = 0; j < m; j++) {\r\n    \r\n  } \r\n} "],"description":"nm"},"node":{"prefix":"node","body":["struct TreeNode {\r\n  int val;\r\n  TreeNode *left;\r\n  TreeNode *right;\r\n  TreeNode(int x) : val(x), left(NULL), right(NULL) {}\r\n};\r\n\r\nusing Node = TreeNode;"],"description":"node"},"ntt":{"prefix":"ntt","body":["template <typename T>\r\nclass NTT {\r\n public:\r\n  using Type = typename decay<decltype(T::value)>::type;\r\n \r\n  static Type md;\r\n  static Modular<T> root;\r\n  static int base;\r\n  static int max_base;\r\n  static vector<Modular<T>> roots;\r\n  static vector<int> rev;\r\n \r\n  static void clear() {\r\n    root = 0;\r\n    base = 0;\r\n    max_base = 0;\r\n    roots.clear();\r\n    rev.clear();\r\n  }\r\n \r\n  static void init() {\r\n    md = T::value;\r\n    assert(md >= 3 && md % 2 == 1);\r\n    auto tmp = md - 1;\r\n    max_base = 0;\r\n    while (tmp % 2 == 0) {\r\n      tmp /= 2;\r\n      max_base++;\r\n    }\r\n    root = 2;\r\n    while (power(root, (md - 1) >> 1) == 1) {\r\n      root++;\r\n    }\r\n    assert(power(root, md - 1) == 1);\r\n    root = power(root, (md - 1) >> max_base);\r\n    base = 1;\r\n    rev = {0, 1};\r\n    roots = {0, 1};\r\n  }\r\n \r\n  static void ensure_base(int nbase) {\r\n    if (md != T::value) {\r\n      clear();\r\n    }\r\n    if (roots.empty()) {\r\n      init();\r\n    }\r\n    if (nbase <= base) {\r\n      return;\r\n    }\r\n    assert(nbase <= max_base);\r\n    rev.resize(1 << nbase);\r\n    for (int i = 0; i < (1 << nbase); i++) {\r\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\r\n    }\r\n    roots.resize(1 << nbase);\r\n    while (base < nbase) {\r\n      Modular<T> z = power(root, 1 << (max_base - 1 - base));\r\n      for (int i = 1 << (base - 1); i < (1 << base); i++) {\r\n        roots[i << 1] = roots[i];\r\n        roots[(i << 1) + 1] = roots[i] * z;\r\n      }\r\n      base++;\r\n    }\r\n  }\r\n \r\n  static void fft(vector<Modular<T>> &a) {\r\n    int n = (int) a.size();\r\n    assert((n & (n - 1)) == 0);\r\n    int zeros = __builtin_ctz(n);\r\n    ensure_base(zeros);\r\n    int shift = base - zeros;\r\n    for (int i = 0; i < n; i++) {\r\n      if (i < (rev[i] >> shift)) {\r\n        swap(a[i], a[rev[i] >> shift]);\r\n      }\r\n    }\r\n    for (int k = 1; k < n; k <<= 1) {\r\n      for (int i = 0; i < n; i += 2 * k) {\r\n        for (int j = 0; j < k; j++) {\r\n          Modular<T> x = a[i + j];\r\n          Modular<T> y = a[i + j + k] * roots[j + k];\r\n          a[i + j] = x + y;\r\n          a[i + j + k] = x - y;\r\n        }\r\n      }\r\n    }\r\n  }\r\n \r\n  static vector<Modular<T>> multiply(vector<Modular<T>> a, vector<Modular<T>> b) {\r\n    if (a.empty() || b.empty()) {\r\n      return {};\r\n    }\r\n    int eq = (a.size() == b.size() && a == b);\r\n    int need = (int) a.size() + (int) b.size() - 1;\r\n    int nbase = 0;\r\n    while ((1 << nbase) < need) nbase++;\r\n    ensure_base(nbase);\r\n    int sz = 1 << nbase;\r\n    a.resize(sz);\r\n    b.resize(sz);\r\n    fft(a);\r\n    if (eq) b = a; else fft(b);\r\n    Modular<T> inv_sz = 1 / static_cast<Modular<T>>(sz);\r\n    for (int i = 0; i < sz; i++) {\r\n      a[i] *= b[i] * inv_sz;\r\n    }\r\n    reverse(a.begin() + 1, a.end());\r\n    fft(a);\r\n    a.resize(need);\r\n    return a;\r\n  }\r\n};\r\n \r\ntemplate <typename T> typename NTT<T>::Type NTT<T>::md;\r\ntemplate <typename T> Modular<T> NTT<T>::root;\r\ntemplate <typename T> int NTT<T>::base;\r\ntemplate <typename T> int NTT<T>::max_base;\r\ntemplate <typename T> vector<Modular<T>> NTT<T>::roots;\r\ntemplate <typename T> vector<int> NTT<T>::rev;\r\n \r\ntemplate <typename T>\r\nvector<Modular<T>> inverse(vector<Modular<T>> a) {\r\n  int n = (int) a.size();\r\n  if (n == 1) {\r\n    return {1 / a[0]};\r\n  }\r\n  int m = (n + 1) >> 1;\r\n  vector<Modular<T>> b = inverse(vector<Modular<T>>(a.begin(), a.begin() + m));\r\n  int need = n << 1;\r\n  int nbase = 0;\r\n  while ((1 << nbase) < need) {\r\n    ++nbase;\r\n  }\r\n  NTT<T>::ensure_base(nbase);\r\n  int size = 1 << nbase;\r\n  a.resize(size);\r\n  b.resize(size);\r\n  NTT<T>::fft(a);\r\n  NTT<T>::fft(b);\r\n  Modular<T> inv = 1 / static_cast<Modular<T>>(size);\r\n  for (int i = 0; i < size; ++i) {\r\n    a[i] = (2 - a[i] * b[i]) * b[i] * inv;\r\n  }\r\n  reverse(a.begin() + 1, a.end());\r\n  NTT<T>::fft(a);\r\n  a.resize(n);\r\n  return a;\r\n}\r\n \r\ntemplate <typename T>\r\nvector<Modular<T>>& operator*=(vector<Modular<T>>& a, const vector<Modular<T>>& b) {\r\n  if (a.empty() || b.empty()) {\r\n    a.clear();\r\n  } else {\r\n    if (min(a.size(), b.size()) < 150) {\r\n      vector<Modular<T>> c = a;\r\n      a.assign(a.size() + b.size() - 1, 0);\r\n      for (int i = 0; i < (int) c.size(); i++) {\r\n        for (int j = 0; j < (int) b.size(); j++) {\r\n          a[i + j] += c[i] * b[j];\r\n        }\r\n      }\r\n    } else {\r\n      a = NTT<T>::multiply(a, b);\r\n    }\r\n  }\r\n  return a;\r\n}\r\n \r\ntemplate <typename T>\r\nvector<Modular<T>> operator*(const vector<Modular<T>>& a, const vector<Modular<T>>& b) {\r\n  vector<Modular<T>> c = a;\r\n  return c *= b;\r\n}\r\n \r\ntemplate <typename T>\r\nvector<T>& operator+=(vector<T>& a, const vector<T>& b) {\r\n  if (a.size() < b.size()) {\r\n    a.resize(b.size());\r\n  }\r\n  for (int i = 0; i < (int) b.size(); i++) {\r\n    a[i] += b[i];\r\n  }\r\n  return a;\r\n}\r\n \r\ntemplate <typename T>\r\nvector<T> operator+(const vector<T>& a, const vector<T>& b) {\r\n  vector<T> c = a;\r\n  return c += b;\r\n}\r\n \r\ntemplate <typename T>\r\nvector<T>& operator-=(vector<T>& a, const vector<T>& b) {\r\n  if (a.size() < b.size()) {\r\n    a.resize(b.size());\r\n  }\r\n  for (int i = 0; i < (int) b.size(); i++) {\r\n    a[i] -= b[i];\r\n  }\r\n  return a;\r\n}\r\n \r\ntemplate <typename T>\r\nvector<T> operator-(const vector<T>& a, const vector<T>& b) {\r\n  vector<T> c = a;\r\n  return c -= b;\r\n}\r\n \r\ntemplate <typename T>\r\nvector<T>& operator*=(vector<T>& a, const vector<T>& b) {\r\n  if (a.empty() || b.empty()) {\r\n    a.clear();\r\n  } else {\r\n    vector<T> c = a;\r\n    a.assign(a.size() + b.size() - 1, 0);\r\n    for (int i = 0; i < (int) c.size(); i++) {\r\n      for (int j = 0; j < (int) b.size(); j++) {\r\n        a[i + j] += c[i] * b[j];\r\n      }\r\n    }\r\n  }\r\n  return a;\r\n}\r\n \r\ntemplate <typename T>\r\nvector<T> operator*(const vector<T>& a, const vector<T>& b) {\r\n  vector<T> c = a;\r\n  return c *= b;\r\n}\r\n \r\ntemplate <typename T>\r\nvector<T> inverse(const vector<T>& a) {\r\n  assert(!a.empty());\r\n  int n = (int) a.size();\r\n  vector<T> b = {1 / a[0]};\r\n  while ((int) b.size() < n) {\r\n    vector<T> a_cut(a.begin(), a.begin() + min(a.size(), b.size() << 1));\r\n    vector<T> x = b * b * a_cut;\r\n    b.resize(b.size() << 1);\r\n    for (int i = (int) b.size() >> 1; i < (int) min(x.size(), b.size()); i++) {\r\n      b[i] = -x[i];\r\n    }\r\n  }\r\n  b.resize(n);\r\n  return b;\r\n}\r\n \r\ntemplate <typename T>\r\nvector<T>& operator/=(vector<T>& a, const vector<T>& b) {\r\n  int n = (int) a.size();\r\n  int m = (int) b.size();\r\n  if (n < m) {\r\n    a.clear();\r\n  } else {\r\n    vector<T> d = b;\r\n    reverse(a.begin(), a.end());\r\n    reverse(d.begin(), d.end());\r\n    d.resize(n - m + 1);\r\n    a *= inverse(d);\r\n    a.erase(a.begin() + n - m + 1, a.end());\r\n    reverse(a.begin(), a.end());\r\n  }\r\n  return a;\r\n}\r\n \r\ntemplate <typename T>\r\nvector<T> operator/(const vector<T>& a, const vector<T>& b) {\r\n  vector<T> c = a;\r\n  return c /= b;\r\n}\r\n \r\ntemplate <typename T>\r\nvector<T>& operator%=(vector<T>& a, const vector<T>& b) {\r\n  int n = (int) a.size();\r\n  int m = (int) b.size();\r\n  if (n >= m) {\r\n    vector<T> c = (a / b) * b;\r\n    a.resize(m - 1);\r\n    for (int i = 0; i < m - 1; i++) {\r\n      a[i] -= c[i];\r\n    }\r\n  }\r\n  return a;\r\n}\r\n \r\ntemplate <typename T>\r\nvector<T> operator%(const vector<T>& a, const vector<T>& b) {\r\n  vector<T> c = a;\r\n  return c %= b;\r\n}\r\n \r\ntemplate <typename T, typename U>\r\nvector<T> power(const vector<T>& a, const U& b, const vector<T>& c) {\r\n  assert(b >= 0);\r\n  vector<U> binary;\r\n  U bb = b;\r\n  while (bb > 0) {\r\n    binary.push_back(bb & 1);\r\n    bb >>= 1;\r\n  }\r\n  vector<T> res = vector<T> {1} % c;\r\n  for (int j = (int) binary.size() - 1; j >= 0; j--) {\r\n    res = res * res % c;\r\n    if (binary[j] == 1) {\r\n      res = res * a % c;\r\n    }\r\n  }\r\n  return res;\r\n}\r\n \r\ntemplate <typename T>\r\nvector<T> derivative(const vector<T>& a) {\r\n  vector<T> c = a;\r\n  for (int i = 0; i < (int) c.size(); i++) {\r\n    c[i] *= i;    \r\n  }\r\n  if (!c.empty()) {\r\n    c.erase(c.begin());\r\n  }\r\n  return c;\r\n}\r\n \r\ntemplate <typename T>\r\nvector<T> primitive(const vector<T>& a) {\r\n  vector<T> c = a;\r\n  c.insert(c.begin(), 0);\r\n  for (int i = 1; i < (int) c.size(); i++) {\r\n    c[i] /= i;\r\n  }\r\n  return c;\r\n}\r\n \r\ntemplate <typename T>\r\nvector<T> logarithm(const vector<T>& a) {\r\n  assert(!a.empty() && a[0] == 1);\r\n  vector<T> u = primitive(derivative(a) * inverse(a));\r\n  u.resize(a.size());\r\n  return u;\r\n}\r\n \r\ntemplate <typename T>\r\nvector<T> exponent(const vector<T>& a) {\r\n  assert(!a.empty() && a[0] == 0);\r\n  int n = (int) a.size();\r\n  vector<T> b = {1};\r\n  while ((int) b.size() < n) {\r\n    vector<T> x(a.begin(), a.begin() + min(a.size(), b.size() << 1));\r\n    x[0] += 1;\r\n    vector<T> old_b = b;\r\n    b.resize(b.size() << 1);\r\n    x -= logarithm(b);\r\n    x *= old_b;\r\n    for (int i = (int) b.size() >> 1; i < (int) min(x.size(), b.size()); i++) {\r\n      b[i] = x[i];\r\n    }\r\n  }\r\n  b.resize(n);\r\n  return b;\r\n}\r\n \r\ntemplate <typename T>\r\nvector<T> sqrt(const vector<T>& a) {\r\n  assert(!a.empty() && a[0] == 1);\r\n  int n = (int) a.size();\r\n  vector<T> b = {1};\r\n  while ((int) b.size() < n) {\r\n    vector<T> x(a.begin(), a.begin() + min(a.size(), b.size() << 1));\r\n    vector<T> old_b = b;\r\n    b.resize(b.size() << 1);\r\n    x *= inverse(b);\r\n    T inv2 = 1 / static_cast<T>(2);\r\n    for (int i = (int) b.size() >> 1; i < (int) min(x.size(), b.size()); i++) {\r\n      b[i] = x[i] * inv2;\r\n    }\r\n  }\r\n  b.resize(n);\r\n  return b;\r\n}"],"description":"ntt"},"orientation":{"prefix":"orientation","body":["const int L = -1;\r\nconst int S =  0;\r\nconst int R =  1; \r\nint orientation(const point &p, const point &q, const point &r) { \r\n  int val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y); \r\n  if (val == 0) return S;\r\n  return (val > 0) ? R : L;\r\n} \r\n"],"description":"orientation"},"pal":{"prefix":"pal","body":["bool can_palin(const string &str, int n) {\r\n  vector <int> fre(26, 0);\r\n  for (int i = 0; i < n; i++) {\r\n    fre[str[i] - 'a']++;\r\n  }\r\n  pair <char, int> odd = {'0', 0};\r\n  for (int i = 0; i < 26; i++) {\r\n    if (fre[i] > 0) {\r\n      if (fre[i] % 2 == 1) {\r\n        if (odd.second == 0) {\r\n          odd.second = 1;\r\n          odd.first = (char)(i + 'a');\r\n        } else {\r\n          return false;\r\n        } \r\n      }\r\n    } \r\n  }\r\n  if (odd.second == 1) {\r\n    if (n % 2 == 0) return false; \r\n  } \r\n  return true;\r\n}\r\n\r\ntemplate <typename T>\r\nbool palin(const string &T) {\r\n  int n = s.size();\r\n  for (int i = 0; i < n / 2; i++) {\r\n    int j = n - i - 1;\r\n    if (s[i] != s[j]) return false;\r\n  } \r\n  return true;\r\n} "],"description":"pal"},"palin":{"prefix":"palin","body":["bool can_palin(const string &str, int n) {\r\n  vector <int> fre(26, 0);\r\n  for (int i = 0; i < n; i++) {\r\n    fre[str[i] - 'a']++;\r\n  }\r\n  pair <char, int> odd = {'0', 0};\r\n  for (int i = 0; i < 26; i++) {\r\n    if (fre[i] > 0) {\r\n      if (fre[i] % 2 == 1) {\r\n        if (odd.second == 0) {\r\n          odd.second = 1;\r\n          odd.first = (char)(i + 'a');\r\n        } else {\r\n          return false;\r\n        } \r\n      }\r\n    } \r\n  }\r\n  if (odd.second == 1) {\r\n    if (n % 2 == 0) return false; \r\n  } \r\n  return true;\r\n}\r\n\r\ntemplate <typename T>\r\nbool palin(const T &s) {\r\n  int n = s.size();\r\n  for (int i = 0; i < n / 2; i++) {\r\n    int j = n - i - 1;\r\n    if (s[i] != s[j]) return false;\r\n  } \r\n  return true;\r\n} "],"description":"palin"},"palindrome":{"prefix":"palindrome","body":["bool can_palin(const string &str, int n) {\r\n  vector <int> fre(26, 0);\r\n  for (int i = 0; i < n; i++) {\r\n    fre[str[i] - 'a']++;\r\n  }\r\n  pair <char, int> odd = {'0', 0};\r\n  for (int i = 0; i < 26; i++) {\r\n    if (fre[i] > 0) {\r\n      if (fre[i] % 2 == 1) {\r\n        if (odd.second == 0) {\r\n          odd.second = 1;\r\n          odd.first = (char)(i + 'a');\r\n        } else {\r\n          return false;\r\n        } \r\n      }\r\n    } \r\n  }\r\n  if (odd.second == 1) {\r\n    if (n % 2 == 0) return false; \r\n  } \r\n  return true;\r\n}\r\n\r\ntemplate <typename T>\r\nbool palin(const T &s) {\r\n  int n = s.size();\r\n  for (int i = 0; i < n / 2; i++) {\r\n    int j = n - i - 1;\r\n    if (s[i] != s[j]) return false;\r\n  } \r\n  return true;\r\n} "],"description":"palindrome"},"parse":{"prefix":"parse","body":["namespace parse {\r\n  bool delim(char c) {\r\n    return c == ' ';\r\n  }\r\n  bool is_op(char c) {\r\n    return c == '+' || c == '-' || c == '*' || c == '/';\r\n  }\r\n  bool is_unary(char c) {\r\n    return c == '+' || c == '-';\r\n  }\r\n  int priority(char op) {\r\n    if (op < 0) return 3; // unary operator\r\n    if (op == '+' || op == '-') return 1;\r\n    if (op == '*' || op == '/') return 2;\r\n    return -1;\r\n  }\r\n  void process_op(stack<int>& st, char op) {\r\n    if (op < 0) {\r\n      int l = st.top(); st.pop();\r\n      switch (-op) {\r\n        case '+': st.push(l); break;\r\n        case '-': st.push(-l); break;\r\n      }\r\n    } else {\r\n      int r = st.top(); st.pop();\r\n      int l = st.top(); st.pop();\r\n      switch (op) {\r\n        case '+': st.push(l + r); break;\r\n        case '-': st.push(l - r); break;\r\n        case '*': st.push(l * r); break;\r\n        case '/': st.push(l / r); break;\r\n      }\r\n    }\r\n  }\r\n  int evaluate(string& s) {\r\n    stack <int> st;\r\n    stack <char> op;\r\n    bool may_be_unary = true;\r\n    for (int i = 0; i < (int) s.size(); i++) {\r\n      if (delim(s[i])) continue;\r\n      if (s[i] == '(') {\r\n        op.push('(');\r\n        may_be_unary = true;\r\n      } else if (s[i] == ')') {\r\n        while (op.top() != '(') {\r\n          process_op(st, op.top());\r\n          op.pop();\r\n        }\r\n        op.pop();\r\n        may_be_unary = false;\r\n      } else if (is_op(s[i])) {\r\n        char cur_op = s[i];\r\n        if (may_be_unary && is_unary(cur_op)) {\r\n          cur_op = -cur_op;\r\n        }\r\n        while (!op.empty() && ((cur_op >= 0 && priority(op.top()) >= priority(cur_op)) || (cur_op < 0 && priority(op.top()) > priority(cur_op)))) {\r\n          process_op(st, op.top());\r\n          op.pop();\r\n        }\r\n        op.push(cur_op);\r\n        may_be_unary = true;\r\n      } else {\r\n        int number = 0;\r\n        while (i < (int)s.size() && isalnum(s[i])) {\r\n          number = number * 10 + s[i++] - '0';\r\n        }\r\n        --i;\r\n        st.push(number);\r\n        may_be_unary = false;\r\n      }\r\n    }\r\n\r\n    while (!op.empty()) {\r\n      process_op(st, op.top());\r\n      op.pop();\r\n    }\r\n    return st.top();\r\n  }\r\n}\r\n//parse::evaluate(s);"],"description":"parse"},"permute":{"prefix":"permute","body":["//..when repeated characters exist\r\nbool swap_allow(string &str, int idx, int i) {\r\n  for (int j = idx; j < i; j++) {\r\n    if (str[j] == str[i]) return false;\r\n  }\r\n  return true;\r\n}\r\n\r\nvoid permute(string &str, int idx, int len) {\r\n  if (idx == len) {\r\n    cout << str << endl;\r\n    return;    \r\n  }\r\n  for (int i = idx; i < len; i++) {\r\n    if (swap_allow(str, idx, i)) {\r\n      swap(str[idx], str[i]);\r\n      permute(str, idx + 1, len);\r\n      swap(str[idx], str[i]);\r\n    }\r\n  }  \r\n} \r\n\r\n//..when all characters are distinct\r\nvoid permute(string &str, int idx, int len) {\r\n  if (idx == len) {\r\n    cout << str << endl;\r\n    return;\r\n  } \r\n  for (int i = idx; i < len; i++) {\r\n    swap(str[idx], str[i]);\r\n    permute(str, idx + 1, len);\r\n    swap(str[idx], str[i]);\r\n  } \r\n} \r\n\r\n"],"description":"permute"},"phi":{"prefix":"phi","body":["const int N = (int) 1e5;\r\n\r\nint phi[N + 1];\r\n\r\n//for many phi(n) query\r\nvoid calc_phi() {\r\n  for (int i = 1; i <= N; i++) {\r\n    phi[i] = i;\r\n  }\r\n  for (int i = 2; i <= N; i++) {\r\n    if (phi[i] == i) {\r\n      for (int j = i; j <= N; j += i) {\r\n        phi[j] *= i - 1;\r\n        phi[j] /= i;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n//for specific n\r\nint calc_phi(int n) {\r\n  int res = n;\r\n  for (int i = 2; i * i <= n; i++) {\r\n    if (n % i == 0) {\r\n      while (n % i == 0) {\r\n        n /= i;\r\n      }\r\n      res -= res / i;\r\n    }\r\n  }\r\n  if (n > 1) {\r\n    res -= res / n;\r\n  }\r\n  return res;\r\n}\r\n"],"description":"phi"},"pi":{"prefix":"pi","body":["const double pi = acos(-1.0);"],"description":"pi"},"pinf":{"prefix":"pinf","body":["const int pinf = numeric_limits<int>::max();"],"description":"pinf"},"point":{"prefix":"point","body":["struct point {\r\n  int x;\r\n  int y;\r\n  point() : x(0), y(0) { }\r\n  point(int _x, int _y) : x(_x), y(_y) { }\r\n  bool operator < (const point &b) const {\r\n    return x < b.x || (x == b.x && y < b.y);\r\n  } \r\n};\r\n\r\nstring to_string(const point& p) {\r\n  return \"{\" + to_string(p.x) + \", \" + to_string(p.y) + \"}\";\r\n}\r\n\r\nostream& operator<<(ostream& out, const point& p) {\r\n  out << to_string(p);\r\n  return out;\r\n}\r\n \r\nistream& operator>>(istream& in, point& p) {\r\n  in >> p.x >> p.y;\r\n  return in;\r\n}\r\n\r\ninline int dot(point& a, point& b) {\r\n  return a.x * b.x + a.y * b.y;\r\n}\r\n\r\ninline int cross(point& a, point& b) {\r\n  return a.x * b.y - a.y * b.x;\r\n}\r\n\r\ninline int norm(point& a) {\r\n  return dot(a, a);\r\n}\r\n\r\ninline double abs(point& a) {\r\n  return sqrt(norm(a));\r\n}\r\n\r\ninline double proj(point& a, point& b) {\r\n  return dot(a, b) / abs(b);\r\n}\r\n\r\ninline double angle(point& a, point& b) {\r\n  return acos(dot(a, b) / abs(a) / abs(b));\r\n}\r\n\r\n\r\ntemplate <typename T>\r\nstruct TPoint {\r\n  T x;\r\n  T y;\r\n  int id;\r\n\r\n  TPoint() : x(0), y(0), id(-1) {}\r\n  TPoint(const T& x_, const T& y_) : x(x_), y(y_), id(-1) {}\r\n  TPoint(const T& x_, const T& y_, int id_) : x(x_), y(y_), id(id_) {}\r\n\r\n  static constexpr T eps = static_cast<T>(1e-9);\r\n\r\n  inline TPoint operator+(const TPoint& rhs) const { return TPoint(x + rhs.x, y + rhs.y); }\r\n  inline TPoint operator-(const TPoint& rhs) const { return TPoint(x - rhs.x, y - rhs.y); }\r\n  inline TPoint operator*(const T& rhs) const { return TPoint(x * rhs, y * rhs); }\r\n  inline TPoint operator/(const T& rhs) const { return TPoint(x / rhs, y / rhs); }\r\n\r\n  friend T smul(const TPoint& a, const TPoint& b) {\r\n    return a.x * b.x + a.y * b.y;\r\n  }\r\n\r\n  friend T vmul(const TPoint& a, const TPoint& b) {\r\n    return a.x * b.y - a.y * b.x;\r\n  }\r\n\r\n  inline T abs2() const {\r\n    return x * x + y * y;\r\n  }\r\n\r\n  inline bool operator<(const TPoint& rhs) const {\r\n    return (y < rhs.y || (y == rhs.y && x < rhs.x));\r\n  }\r\n\r\n  inline bool is_upper() const {\r\n    return (y > eps || (abs(y) <= eps && x > eps));\r\n  }\r\n\r\n  inline int cmp_polar(const TPoint& rhs) const {\r\n    assert(abs(x) > eps || abs(y) > eps);\r\n    assert(abs(rhs.x) > eps || abs(rhs.y) > eps);\r\n    bool a = is_upper();\r\n    bool b = rhs.is_upper();\r\n    if (a != b) {\r\n      return (a ? -1 : 1);\r\n    }\r\n    long long v = x * rhs.y - y * rhs.x;\r\n    return (v > eps ? -1 : (v < -eps ? 1 : 0));\r\n  }\r\n};\r\n\r\nusing Point = TPoint<long long>;\r\n//using Point = TPoint<long double>;\r\n\r\ntemplate <typename T>\r\nstring to_string(const TPoint<T>& p) {\r\n  return \"(\" + to_string(p.x) + \", \" + to_string(p.y) + \")\";\r\n}\r\n"],"description":"point"},"policy":{"prefix":"policy","body":["#include <ext/pb_ds/assoc_container.hpp>\r\n#include <ext/pb_ds/tree_policy.hpp>\r\nusing namespace __gnu_pbds;\r\ntypedef tree<int, null_type, less< int>, rb_tree_tag, tree_order_statistics_node_update> st;\r\n//use st.insert(1), *st.find_by_order(1), st.order_of_key(1) in O(logn) time"],"description":"policy"},"power":{"prefix":"power","body":["const int mod = (int) (1e9 + 7);\r\n\r\ninline int power(int a, int b) {\r\n  int res = 1;\r\n  while (b > 0) {\r\n    if (b & 1) {\r\n      res = mul(res, a);\r\n    }\r\n    b >>= 1;\r\n    a = mul(a, a);\r\n  }\r\n  return res;\r\n}"],"description":"power"},"prec":{"prefix":"prec","body":["  cout << fixed << setprecision(17);\r\n  cerr << fixed << setprecision(17);"],"description":"prec"},"prims_mst":{"prefix":"prims_mst","body":["template <typename T>\r\nvector <int> mst(const undigraph<T> &g, T &ans) {\r\n  priority_queue<pair<T, int>, vector<pair<T, int> >, greater<pair<T, int> > > pq;\r\n  vector<T> dist(g.n, numeric_limits<T>::max());\r\n  vector <bool> in_mst(g.n, false);\r\n  vector <int> ans_list(g.n - 1);\r\n  \r\n  int start = 0;\r\n  dist[start] = 0;\r\n  pq.emplace(dist[start], start);\r\n  while (!pq.empty()) {\r\n    pair <T, int> pr = pq.top(); \r\n    pq.pop();\r\n    int u = pr.second;\r\n    in_mst[u] = true;\r\n    for (int id : g.g[u]) {\r\n      auto &e = g.edges[id];\r\n      int v = e.from ^ e.to ^ u;\r\n      if (!in_mst[v] && e.cost < dist[v]) {\r\n        dist[v] = e.cost;\r\n        ans_list[v - 1] = id;\r\n        pq.emplace(dist[v], v);\r\n      } \r\n    }\r\n  }\r\n\r\n  ans = 0;\r\n  for (int i = 0; i < g.n; i++) {\r\n    ans += dist[i];\r\n  } \r\n  return ans_list;\r\n  //returns edge ids of minimum \"spanning\" forest\r\n}\r\n"],"description":"prims_mst"},"push_relabel":{"prefix":"push_relabel","body":["//..verfied against AOJ GRL_6_A\r\nstruct Vertex {\r\n  int height;\r\n  int excess;\r\n};\r\n\r\nstruct Edge {\r\n  int dst, rev;\r\n  int cap, flow;\r\n};\r\n\r\nclass Graph {\r\nprivate:\r\n  int V;\r\n  int E;\r\n  vector <Vertex> ver;\r\n  vector <vector <Edge>> adj;\r\n  void preFlow(int s);\r\n  int overFlow(int s, int t);\r\n  bool push(int u);\r\n  void relabel(int u);\r\npublic:\r\n  Graph(int n, int m);\r\n  void addEdge(int src, int dst, int cap);\r\n  int maxFlow(int s, int t);\r\n};\r\n\r\nGraph::Graph(int n, int m) {\r\n  this->V = n;\r\n  this->E = m;\r\n  adj.resize(n);\r\n  ver.resize(n);\r\n  for (int i = 0; i < n; i++) {\r\n    ver[i] = {0, 0};\r\n  } \r\n}\r\n\r\nvoid Graph::addEdge(int src, int dst, int cap) {\r\n  Edge a = {dst, (int) adj[dst].size(), cap, 0};\r\n  Edge b = {src, (int) adj[src].size(), 0, 0};\r\n\r\n  adj[src].push_back(a);\r\n  adj[dst].push_back(b);\r\n} \r\n\r\nvoid Graph::preFlow(int s) {\r\n  ver[s].height = V;\r\n  for (Edge &e : adj[s]) {\r\n    e.flow += e.cap;                      //..flow the whole capacity\r\n    ver[e.dst].excess += e.cap;\r\n\r\n    adj[e.dst][e.rev].flow -= e.cap;      //..flow in reverse\r\n  }\r\n}\r\n\r\n//..overflow at vertices other than s and t. They could have been queued as well\r\nint Graph::overFlow(int s, int t) {\r\n  for (int i = 0; i < V; i++) {\r\n    if (i == s || i == t) {\r\n      continue;\r\n    }\r\n    if (ver[i].excess > 0) {\r\n      return i;\r\n    }\r\n  }\r\n  return -1; \r\n}\r\n\r\nbool Graph::push(int u) {\r\n  for (Edge &e : adj[u]) {\r\n    if (e.flow == e.cap) {\r\n      continue;\r\n    } \r\n    int v = e.dst;\r\n    if (ver[v].height < ver[u].height) {\r\n      int flow = min(ver[u].excess, e.cap - e.flow);\r\n      ver[u].excess -= flow;\r\n      ver[v].excess += flow;\r\n\r\n      e.flow += flow;\r\n      adj[v][e.rev].flow -= flow;\r\n\r\n      return true;\r\n    }    \r\n  }\r\n  return false;\r\n}\r\n\r\nvoid Graph::relabel(int u) {\r\n  int min_h = pinf;\r\n  for (Edge e : adj[u]) {\r\n    if (e.flow == e.cap) {\r\n      continue;\r\n    }\r\n    int v = e.dst;\r\n    min_h = min(min_h, ver[v].height);\r\n    ver[u].height = min_h + 1;      \r\n  }\r\n}\r\n\r\nint Graph::maxFlow(int s, int t) {\r\n  preFlow(s);\r\n  //..until overflow is not over\r\n  while (1) {\r\n    int node = overFlow(s, t);\r\n    if (node == -1) break;\r\n\r\n    if (!push(node)) {\r\n      relabel(node);\r\n    }\r\n  }\r\n  \r\n  int total = 0;\r\n  for (Edge e : adj[s]) {\r\n    total += e.flow;    \r\n  }\r\n  return total;\r\n} \r\n\r\nint main() {\r\n  int n, m;\r\n  cin >> n >> m;\r\n\r\n  Graph g(n, m);\r\n\r\n  int src, dst, cap;\r\n  for (int i = 0; i < m; i++) {\r\n    cin >> src >> dst >> cap;\r\n    g.addEdge(src, dst, cap);\r\n  }\r\n  cout << g.maxFlow(0, n - 1) << '\\n';\r\n\r\n  return 0;\r\n} "],"description":"push_relabel"},"queue":{"prefix":"queue","body":["template <typename T> \r\nstring to_string(queue <T> &q) {\r\n  bool first = true;\r\n  string res = \"{\";\r\n  queue <T> temp = q;\r\n  while (!temp.empty()) {\r\n    T x = temp.front();\r\n    temp.pop();\r\n    if (!first) {\r\n      res += \", \";\r\n    }    \r\n    first = false;\r\n    res += to_string(x);\r\n  } \r\n  res += \"}\";\r\n  return res;\r\n}"],"description":"queue"},"rabin_karp":{"prefix":"rabin_karp","body":["//verfied against NHAY spoj\r\n//..both p and mod are primes\r\nconst int p = 31;\r\nconst int mod = (int) (1e9 + 9);\r\n\r\ninline long long mul(long long a, long long b) {\r\n  long long res = a * b;\r\n  a = res % mod;\r\n  return a;\r\n}\r\n\r\ninline void add(long long &a, long long b) {\r\n  a += b;\r\n  if (a >= mod) {\r\n    a -= mod;\r\n  }\r\n}\r\n\r\ninline void sub(long long &a, long long b) {\r\n  a -= b;\r\n  if (a < 0) {\r\n    a += mod;\r\n  }\r\n}\r\n \r\nlong long power(long long a, long long b) {\r\n  long long res = 1;\r\n  while (b > 0) {\r\n    if (b & 1) {\r\n      res = mul(res, a);\r\n    }\r\n    b >>= 1;\r\n    a = mul(a, a);\r\n  }\r\n  return res;\r\n}\r\n\r\ninline long long inv(long long x) {\r\n  return power(x, mod - 2);\r\n}\r\n\r\n//..polynomial rolling hashing of form : str[0] * (p ^ 0) + str[1] * (p ^ 1) + str[2] * (p ^ 2)\r\n//..complete hash value at end of hash array\r\nvector <long long> hashing(const string &str) {\r\n  long long val = 0;\r\n  long long exp = 1;\r\n  int len = str.length();\r\n  vector <long long> hash(len);\r\n  for (int i = 0; i < len; i++) {   \r\n    char ch = str[i];\r\n    int coef = ch - 'a' + 1;\r\n    add(val, mul(coef, exp));\r\n    exp = mul(exp, p);\r\n\r\n    hash[i] = val;\r\n  }\r\n\r\n  return hash;\r\n}\r\n\r\n//..hash[i..j] = (hash[0...j] - hash[0...i - 1]) / (p ^ i) under mod\r\nvector <int> rabin_karp(const string& pat, const string &txt) {\r\n  int n = pat.length();\r\n  int m = txt.length();\r\n  vector <int> pos;   \r\n  vector <long long> a = hashing(pat);\r\n  vector <long long> b = hashing(txt);\r\n  \r\n  //..block hashing in text, windowing...\r\n  long long match = a[n - 1];\r\n  for (int i = 0; i <= m - n; i++) { \r\n    int j = i + n - 1;\r\n    long long val = b[j];\r\n    if (i - 1 >= 0) {\r\n      sub(val, b[i - 1]);\r\n      val = mul(val, inv(power(p, i)));\r\n    }\r\n    if (val == match) {\r\n      pos.emplace_back(i);\r\n    } \r\n  }\r\n  return pos;\r\n  //..first positions of pattern match\r\n}"],"description":"rabin_karp"},"radix":{"prefix":"radix","body":["namespace radix {\n \nvector<int> p(65537);\n \ntemplate<typename T>\nvoid SortShift(vector<T>& a, vector<T>& new_a, int shift) {\n  assert(a.size() == new_a.size());\n  int n = static_cast<int>(a.size());\n  fill(p.begin(), p.end(), 0);\n  for (int i = 0; i < n; i++) p[1 + ((a[i] >> shift) & 0xffff)]++;\n  for (int i = 1; i <= 65536; i++) p[i] += p[i - 1];\n  for (int i = 0; i < n; i++) new_a[p[(a[i] >> shift) & 0xffff]++] = a[i];\n}\n \nvoid Sort(vector<int32_t>& a) {\n  constexpr int32_t flip = static_cast<int32_t>(1) << 31;\n  for (auto& aa : a) aa ^= flip;\n  vector<int32_t> b(a.size());\n  SortShift(a, b, 0);\n  SortShift(b, a, 16);\n  for (auto& aa : a) aa ^= flip;\n}\n \nvoid Sort(vector<uint32_t>& a) {\n  vector<uint32_t> b(a.size());\n  SortShift(a, b, 0);\n  SortShift(b, a, 16);\n}\n \nvoid Sort(vector<int64_t>& a) {\n  constexpr int64_t flip = static_cast<int64_t>(1) << 63;\n  for (auto& aa : a) aa ^= flip;\n  vector<int64_t> b(a.size());\n  SortShift(a, b, 0);\n  SortShift(b, a, 16);\n  SortShift(a, b, 32);\n  SortShift(b, a, 48);\n  for (auto& aa : a) aa ^= flip;\n}\n \nvoid Sort(vector<uint64_t>& a) {\n  vector<uint64_t> b(a.size());\n  SortShift(a, b, 0);\n  SortShift(b, a, 16);\n  SortShift(a, b, 32);\n  SortShift(b, a, 48);\n}\n \n}  // namespace radix\n"],"description":"radix"},"rand":{"prefix":"rand","body":["mt19937 rng((unsigned int) chrono::system_clock::now().time_since_epoch().count());\ntemplate <typename T>\nT rand(T L, T H) {\n  return uniform_int_distribution<T> (L, H)(rng);\n}"],"description":"rand"},"rank":{"prefix":"rank","body":["template <typename T>\r\nvector <int> ranking(vector <T> &arr) {\r\n  int n = arr.size();\r\n  vector <pair <T, int>> pr(n);\r\n  for (int i = 0; i < n; i++) {\r\n    pr[i] = make_pair(arr[i], i);\r\n  } \r\n  sort(pr.begin(), pr.end());\r\n  int rank = 0;\r\n  int h = 0;\r\n  vector <int> r(n);\r\n  while (h < n) {\r\n    int l = h;\r\n    while (h + 1 < n && pr[h + 1].first == pr[l].first) {\r\n      h += 1;\r\n    }\r\n    for (int i = l; i <= h; i++) {\r\n      r[pr[i].second] = rank;\r\n    } \r\n    rank += 1;\r\n    l = h + 1;\r\n    h = h + 1;\r\n  }\r\n  return r; \r\n  //..r[i] is the rank of arr[i] if arr was sorted\r\n}"],"description":"rank"},"ranking":{"prefix":"ranking","body":["template <typename T>\r\nvector <int> ranking(vector <T> &arr) {\r\n  int n = arr.size();\r\n  vector <pair <T, int>> pr(n);\r\n  for (int i = 0; i < n; i++) {\r\n    pr[i] = make_pair(arr[i], i);\r\n  } \r\n  stable_sort(pr.begin(), pr.end());\r\n  int rank = 0;\r\n  int h = 0;\r\n  vector <int> r(n);\r\n  while (h < n) {\r\n    int l = h;\r\n    while (h + 1 < n && pr[h + 1].first == pr[l].first) {\r\n      h += 1;\r\n    }\r\n    for (int i = l; i <= h; i++) {\r\n      r[pr[i].second] = rank;\r\n    } \r\n    rank += 1;\r\n    l = h + 1;\r\n    h = h + 1;\r\n  }\r\n  return r; \r\n  //..r[i] is the rank of arr[i] if arr was sorted\r\n} \r\n"],"description":"ranking"},"read":{"prefix":"read","body":["template <typename T> \r\ninline void read(T &x) {\r\n  char c = (char) getchar();\r\n  bool f = false;\r\n  for (x = 0; !isdigit(c); c = (char) getchar()) {\r\n    if (c == '-') {\r\n      f = true;\r\n    }\r\n  }\r\n  for (; isdigit(c); c = (char) getchar()) {\r\n    x = x * 10 + c - '0';\r\n  }\r\n  if (f) {\r\n    x = -x;\r\n  }\r\n}"],"description":"read"},"rng":{"prefix":"rng","body":["mt19937 rng((unsigned int) chrono::system_clock::now().time_since_epoch().count());\r\n"],"description":"rng"},"rotate":{"prefix":"rotate","body":["/*\r\ninline void rotate(int& x, int& y, int n) {\r\n  x = n - 1 - y;\r\n  y = x;\r\n}\r\n*/\r\n//rotate string s by amt to L or R\r\nauto rotateL = [&](string &s, int k) {\r\n  int len = s.length();\r\n  k = k % len;\r\n  string t(len, '0');\r\n  int idx = k;\r\n  for (int i = 0; i < len; i++) {\r\n    t[i] = s[idx];\r\n    idx = idx + 1;\r\n    if (idx == len) idx = 0;\r\n  } \r\n  s = t;\r\n};\r\nauto rotateR = [&](string &s, int k) {\r\n  int len = s.length();\r\n  k = k % len;\r\n  rotateL(s, len - k);\r\n};"],"description":"rotate"},"sa":{"prefix":"sa","body":["/* tourist's template\r\ntemplate <typename T>\r\nvector<int> suffix_array(int n, const T &s, int char_bound) {\r\n  vector<int> a(n);\r\n  if (n == 0) {\r\n    return a;\r\n  }\r\n  if (char_bound != -1) {\r\n    vector<int> aux(char_bound, 0);\r\n    for (int i = 0; i < n; i++) {\r\n      aux[s[i]]++;\r\n    }\r\n    int sum = 0;\r\n    for (int i = 0; i < char_bound; i++) {\r\n      int add = aux[i];\r\n      aux[i] = sum;\r\n      sum += add;\r\n    }\r\n    for (int i = 0; i < n; i++) {\r\n      a[aux[s[i]]++] = i;\r\n    }\r\n  } else {\r\n    iota(a.begin(), a.end(), 0);\r\n    sort(a.begin(), a.end(), [&s](int i, int j) { return s[i] < s[j]; });\r\n  }\r\n  vector<int> sorted_by_second(n);\r\n  vector<int> ptr_group(n);\r\n  vector<int> new_group(n);\r\n  vector<int> group(n);\r\n  group[a[0]] = 0;\r\n  for (int i = 1; i < n; i++) {\r\n    group[a[i]] = group[a[i - 1]] + (!(s[a[i]] == s[a[i - 1]]));\r\n  }\r\n  int cnt = group[a[n - 1]] + 1;\r\n  int step = 1;\r\n  while (cnt < n) {\r\n    int at = 0;\r\n    for (int i = n - step; i < n; i++) {\r\n      sorted_by_second[at++] = i;\r\n    }\r\n    for (int i = 0; i < n; i++) {\r\n      if (a[i] - step >= 0) {\r\n        sorted_by_second[at++] = a[i] - step;\r\n      }\r\n    }\r\n    for (int i = n - 1; i >= 0; i--) {\r\n      ptr_group[group[a[i]]] = i;\r\n    }\r\n    for (int i = 0; i < n; i++) {\r\n      int x = sorted_by_second[i];\r\n      a[ptr_group[group[x]]++] = x;\r\n    }\r\n    new_group[a[0]] = 0;\r\n    for (int i = 1; i < n; i++) {\r\n      if (group[a[i]] != group[a[i - 1]]) {\r\n        new_group[a[i]] = new_group[a[i - 1]] + 1;\r\n      } else {\r\n        int pre = (a[i - 1] + step >= n ? -1 : group[a[i - 1] + step]);\r\n        int cur = (a[i] + step >= n ? -1 : group[a[i] + step]);\r\n        new_group[a[i]] = new_group[a[i - 1]] + (pre != cur);\r\n      }\r\n    }\r\n    swap(group, new_group);\r\n    cnt = group[a[n - 1]] + 1;\r\n    step <<= 1;\r\n  }\r\n  return a;\r\n}\r\n \r\ntemplate <typename T>\r\nvector<int> suffix_array(const T &s, int char_bound) {\r\n  return suffix_array((int) s.size(), s, char_bound);\r\n}\r\n//..vector <int> sa = suffix_array(str, 256);\r\n*/\r\n\r\n//Mine\r\nnamespace suffix {\r\n  int char_bound = 256;\r\n  struct suf { \r\n    int idx;\r\n    vector <int> rank;\r\n    suf() { rank.resize(2); }\r\n  }; \r\n\r\n  void radix_sort(vector <suf>& sufs, int idx = 1) { \r\n    int n = sufs.size();\r\n    vector <int> bucket(char_bound + 1, 0);\r\n    vector <suf> temp(n);\r\n    for (int i = 0; i < n; i++) {\r\n      bucket[sufs[i].rank[idx] + 1]++;\r\n    }\r\n    for (int i = 1; i < char_bound; i++) {\r\n      bucket[i] += bucket[i - 1];\r\n    }\r\n    for (int i = n - 1; i >= 0; i--) {\r\n      temp[bucket[sufs[i].rank[idx] + 1] - 1] = sufs[i];\r\n      bucket[sufs[i].rank[idx] + 1]--;\r\n    }\r\n    for (int i = 0; i < n; i++) {\r\n      sufs[i] = temp[i];\r\n    }\r\n    temp.clear();\r\n    if (idx == 0) return;\r\n    else radix_sort(sufs, 0);\r\n  } \r\n\r\n  vector <int> suffix_array(const string &str) {\r\n    int n = str.length();\r\n    vector <suf> sufs(n);\r\n    for (int i = 0; i < n; i++) { \r\n      sufs[i].idx = i;\r\n      sufs[i].rank[0] = str[i];\r\n      sufs[i].rank[1] = ((i + 1) < n) ? str[i + 1] : -1;\r\n    }\r\n    radix_sort(sufs);\r\n    vector <int> ind(n);\r\n    for (int k = 4; k < 2 * n; k = k * 2) { \r\n      int rank = 0; \r\n      int prev_rank = sufs[0].rank[0];\r\n      sufs[0].rank[0] = rank;\r\n      ind[sufs[0].idx] = 0;\r\n      for (int i = 1; i < n; i++) {\r\n        if (sufs[i].rank[0] == prev_rank && sufs[i].rank[1] == sufs[i - 1].rank[1]) { \r\n          prev_rank = sufs[i].rank[0]; \r\n          sufs[i].rank[0] = rank; \r\n        } else {\r\n          prev_rank = sufs[i].rank[0]; \r\n          sufs[i].rank[0] = ++rank; \r\n        } \r\n        ind[sufs[i].idx] = i; \r\n      } \r\n      for (int i = 0; i < n; i++) { \r\n        int next = sufs[i].idx + k / 2; \r\n        sufs[i].rank[1] = (next < n) ? sufs[ind[next]].rank[0] : -1; \r\n      } \r\n      radix_sort(sufs);\r\n    } \r\n    vector <int> a(n);\r\n    for (int i = 0; i < n; i++) { \r\n      a[i] = sufs[i].idx; \r\n    }\r\n    return a; \r\n  } \r\n}\r\n\r\nusing suffix::suffix_array;"],"description":"sa"},"scc":{"prefix":"scc","body":["/*\r\n//..Mine\r\nusing Kosaraju Algo uses reverse graph  : kosaraju\r\nusing Tarjan uses dicovery and low time : tarjan\r\n*/\r\n\r\ntemplate <typename T>\r\nvector<int> find_scc(const digraph<T> &g, int &cnt) {\r\n  digraph<T> g_rev = g.reverse();\r\n  vector<int> order;\r\n  vector<bool> was(g.n, false);\r\n  function<void(int)> dfs1 = [&](int v) {\r\n    was[v] = true;\r\n    for (int id : g.g[v]) {\r\n      auto &e = g.edges[id];\r\n      int to = e.to;\r\n      if (!was[to]) {\r\n        dfs1(to);\r\n      }\r\n    }\r\n    order.push_back(v);\r\n  };\r\n  for (int i = 0; i < g.n; i++) {\r\n    if (!was[i]) {\r\n      dfs1(i);\r\n    }\r\n  }\r\n  vector<int> c(g.n, -1);\r\n  function<void(int)> dfs2 = [&](int v) {\r\n    for (int id : g_rev.g[v]) {\r\n      auto &e = g_rev.edges[id];\r\n      int to = e.to;\r\n      if (c[to] == -1) {\r\n        c[to] = c[v];\r\n        dfs2(to);\r\n      }\r\n    }\r\n  };\r\n  cnt = 0;\r\n  for (int id = g.n - 1; id >= 0; id--) {\r\n    int i = order[id];\r\n    if (c[i] != -1) {\r\n      continue;\r\n    }\r\n    c[i] = cnt++;\r\n    dfs2(i);\r\n  }\r\n  return c;\r\n  // c[i] <= c[j] for every edge i -> j\r\n}\r\n\r\n// import dfs_undigraph first\r\n\r\ntemplate <typename T>\r\nvector<bool> find_bridges(dfs_undigraph<T> &g) {\r\n  g.dfs_all();\r\n  vector<bool> bridge(g.edges.size(), false);\r\n  for (int i = 0; i < g.n; i++) {\r\n    if (g.pv[i] != -1 && g.min_depth[i] == g.depth[i]) {\r\n      bridge[g.pe[i]] = true;\r\n    }\r\n  }\r\n  return bridge;\r\n}\r\n\r\n// delete above when this is tested\r\ntemplate <typename T>\r\nvector<bool> find_bridges(dfs_undigraph<T> &g) {\r\n  g.dfs_all();\r\n  vector<bool> bridge(g.edges.size(), false);\r\n  for (int v = 0; v < g.n; v++) {\r\n    int u = g.pv[v];\r\n    if (u == -1) continue;\r\n    \r\n    if (g.min_depth[v] > g.depth[u]) {\r\n      bridge[g.pe[v]] = true;\r\n    }\r\n  }\r\n  return bridge;\r\n}\r\n\r\n\r\ntemplate <typename T>\r\nvector <int> bridge(const undigraph <T> &g) {\r\n  vector <bool> seen(g.n, false);\r\n  vector <int> low(g.n, 0);\r\n  vector <int> dis(g.n, 0);\r\n  vector <int> pv(g.n, -1);\r\n  int timer = 0;\r\n  vector <int> ans;\r\n  function <void(int)> dfs = [&](int u) {\r\n    seen[u] = true;\r\n    dis[u] = low[u] = ++timer;\r\n    for (int id : g.g[u]) {\r\n      int v = g.edges[id].from ^ g.edges[id].to ^ u;\r\n      if (!seen[v]) {\r\n        pv[v] = u;\r\n        dfs(v);\r\n        low[u] = min(low[u], low[v]);\r\n        if (low[v] > dis[u]) {\r\n          ans.push_back(id);\r\n        }\r\n      } else if (v != pv[u]) {\r\n        low[u] = min(low[u], dis[v]);\r\n      }\r\n    }\r\n  };\r\n  dfs(0);\r\n  return ans;\r\n  // return edge id's of bridges\r\n} \r\n\r\n\r\ntemplate <typename T>\r\nvector <bool> articulation(dfs_undigraph<T> &g) {\r\n  g.dfs_all();\r\n  vector<bool> art(g.n, false);\r\n  \r\n  for (int v = 0; v < g.n; v++) {\r\n    int u = g.pv[v];\r\n    if (u == -1) continue;\r\n    \r\n    // u -- root node, check child cnt\r\n    if (g.pv[u] == -1) {\r\n      if (g.cnt[u] > 1) {\r\n        art[u] = true;\r\n      }\r\n      continue;\r\n    }\r\n    // u -- v is a proper edge\r\n    if (g.min_depth[v] >= g.depth[u]) {\r\n      art[u] = true;\r\n    } \r\n  }\r\n  \r\n  return art;\r\n}\r\n\r\ntemplate <typename T>\r\nvector <int> articulation(const undigraph <T> &g) {\r\n  vector <bool> seen(g.n, false);\r\n  vector <int> low(g.n, 0);\r\n  vector <int> dis(g.n, 0);\r\n  vector <int> pv(g.n, -1);\r\n  vector <bool> art(g.n, false);\r\n  int timer = 0;\r\n\r\n  function <void(int)> dfs = [&](int u) {\r\n    seen[u] = true;\r\n    dis[u] = low[u] = ++timer;\r\n    int child_cnt = 0;\r\n    for (int id : g.g[u]) {\r\n      int v = g.edges[id].from ^ g.edges[id].to ^ u;\r\n      if (!seen[v]) {\r\n        child_cnt++;\r\n        pv[v] = u;\r\n        dfs(v);\r\n        low[u] = min(low[u], low[v]);\r\n        if (pv[u] == -1 && child_cnt > 1) {\r\n          art[u] = true;\r\n        }\r\n        if (pv[u] != -1 && low[v] >= dis[u]) {\r\n          art[u] = true;\r\n        }\r\n      } else if (v != pv[u]) {\r\n        low[u] = min(low[u], dis[v]);\r\n      }\r\n    }\r\n  };\r\n  dfs(0);\r\n  vector <int> ans;\r\n  for (int i = 0; i < g.n; i++) {\r\n    if (art[i]) {\r\n      ans.push_back(i);\r\n    } \r\n  } \r\n\r\n  return ans;\r\n  // returns sorted list of weak vertices\r\n} \r\n\r\ntemplate <typename T>\r\nvector <T> bellman_ford(const graph<T> &g, int from, bool& neg) {\r\n  neg = false;\r\n  T inf = numeric_limits<T>::max();\r\n  vector <T> dist(g.n, inf);\r\n  dist[from] = 0;\r\n\r\n  auto relax = [&](auto &e) -> bool {\r\n    bool done = false;\r\n    int u = e.from;\r\n    int v = e.to;\r\n    int w = e.cost;\r\n    if (dist[u] != inf && dist[u] + w < dist[v]) {\r\n      dist[v] = dist[u] + w;\r\n      done = true;\r\n    }\r\n    return done;\r\n  };\r\n\r\n  //relax all edges g.n - 1 times\r\n  for (int qq = 1; qq <= g.n - 1; qq++) {\r\n    for (auto &e : g.edges) {\r\n      relax(e);\r\n    }\r\n  } \r\n\r\n  //if it relaxes more, then it contains negative cycle\r\n  for (auto &e : g.edges) {\r\n    if (relax(e)) {\r\n      neg = true;\r\n      goto end;\r\n    } \r\n  }\r\n end : {\r\n    return dist;\r\n  }\r\n  //dist[i] = distance to 'i' from 'from', inf if not reachable\r\n  //neg = true if negative cycle is present\r\n}\r\n"],"description":"scc"},"segtree":{"prefix":"segtree","body":["class segtree {\r\n public:\r\n  struct node {\r\n    // don't forget to set default value (used for leaves)\r\n    // not necessarily neutral element!\r\n    ...\r\n    // variable holding the temporarily cumulative range updates\r\n    T add = 0; \r\n    bool mark = false;\r\n    // the query result = node property, leaf property\r\n    T sum = 0;     \r\n    ...\r\n\r\n    void apply(int l, int h, ... v) {\r\n      assert(l <= h); // l == h for point update\r\n      ...\r\n      add += v;\r\n      sum += (h - l + 1) * v; // set query variable = query[l - h], Also for point-update one variable is required\r\n      mark = true;\r\n      ...\r\n    }\r\n  };\r\n \r\n  node unite(const node &a, const node &b) const {\r\n    node res;\r\n    res.sum = a.sum + b.sum; // do nothing for point query, simlply return res\r\n    // don't merge the temporary holdings of child since they're responsible in different range\r\n    return res;\r\n    ...\r\n  }\r\n \r\n  inline void push(int i, int l, int h) {\r\n    int m = (l + h) >> 1;\r\n    // push from i into left child and right child, Also no push in point-update\r\n    // only bother about pushing and not about pulling (uniting)\r\n   /*\r\n    if (tree[i].mark) {\r\n      tree[i << 1].apply(l, m, tree[i].add);\r\n      tree[(i << 1) + 1].apply(m + 1, h, tree[i].add);\r\n      tree[i].add = 0;\r\n      tree[i].mark = false;\r\n    }\r\n    */\r\n  }\r\n \r\n  inline void pull(int i) {\r\n    tree[i] = unite(tree[i << 1], tree[(i << 1) + 1]);\r\n  }\r\n \r\n  int n;\r\n  vector<node> tree;\r\n  \r\n  template <typename M>\r\n  void build(int i, int l, int h, const vector<M> &v) {\r\n    if (l == h) {\r\n      tree[i].apply(l, h, v[l]);\r\n      return;\r\n    }\r\n    int m = (l + h) >> 1;\r\n    build(i << 1, l, m, v);\r\n    build((i << 1) + 1, m + 1, h, v);\r\n    pull(i);\r\n  }\r\n \r\n  node get(int i, int l, int h, int ql, int qh) {\r\n    if (ql <= l && h <= qh) {\r\n      return tree[i];\r\n    }\r\n    int m = (l + h) >> 1;\r\n    push(i, l, h);\r\n    node res{};\r\n    if (qh <= m) {\r\n      res = get(i << 1, l, m, ql, qh);\r\n    } else {\r\n      if (ql > m) {\r\n        res = get((i << 1) + 1, m + 1, h, ql, qh);\r\n      } else {\r\n        res = unite(get(i << 1, l, m, ql, qh), get((i << 1) + 1, m + 1, h, ql, qh));\r\n      }\r\n    }\r\n    pull(i);\r\n    return res;\r\n  }\r\n \r\n  template <typename... M>\r\n  void modify(int i, int l, int h, int ql, int qh, const M&... v) {\r\n    if (ql <= l && h <= qh) {\r\n      tree[i].apply(l, h, v...);\r\n      return;\r\n    }\r\n    push(i, l, h);\r\n    int m = (l + h) >> 1;\r\n    if (qh <= m) {\r\n      modify(i << 1, l, m, ql, qh, v...);\r\n    } else {\r\n      if (ql > m) {\r\n        modify((i << 1) + 1, m + 1, h, ql, qh, v...);\r\n      } else {\r\n        modify(i << 1, l, m, ql, qh, v...);\r\n        modify((i << 1) + 1, m + 1, h, ql, qh, v...);\r\n      }\r\n    }\r\n    pull(i);\r\n  }\r\n \r\n  template <typename M>\r\n  segtree(const vector<M> &v) {\r\n    n = (int) v.size();\r\n    assert(n > 0);\r\n    tree.resize(4 * n);\r\n    build(1, 0, n - 1, v);\r\n  }\r\n \r\n  node get(int ql, int qh) {\r\n    assert(0 <= ql && ql <= qh && qh <= n - 1);\r\n    return get(1, 0, n - 1, ql, qh);\r\n  }\r\n \r\n  template <typename... M>\r\n  void modify(int ql, int qh, const M&... v) {\r\n    assert(0 <= ql && ql <= qh && qh <= n - 1);\r\n    modify(1, 0, n - 1, ql, qh, v...);\r\n  }\r\n};\r\n"],"description":"segtree"},"segtree_tourist":{"prefix":"segtree_tourist","body":["class segtree {\n public:\n  struct node {\n    // don't forget to set default value (used for leaves)\n    // not necessarily neutral element!\n    ...\n    // variable holding the temporarily cumulative range updates\n    T add = 0; \n    bool mark = false;\n    // node property, leaf property\n    T sum = 0;     \n    ...\n\n    void apply(int l, int h, ... v) {\n      ...\n      add += v;\n      sum += (h - l + 1) * v; // set query variable = query[l - h], Also for point-update one variable is required\n      mark = true;\n      ...\n    }\n  };\n \n  node unite(const node &a, const node &b) const {\n    ...\n    node res;\n    res.sum = a.sum + b.sum; // do nothing for point query, simlply return res\n    return res;\n    ...\n  }\n \n  inline void push(int i, int l, int h) {\n    int m = (l + h) >> 1;\n    // push from i into left child and right child, Also no push in point-update\n   /*\n    if (tree[i].mark) {\n      tree[i << 1].apply(l, m, tree[i].add);\n      tree[(i << 1) + 1].apply(m + 1, h, tree[i].add);\n      tree[i].add = 0;\n      tree[i].mark = false;\n    }\n    */\n  }\n \n  inline void pull(int i) {\n    tree[i] = unite(tree[i << 1], tree[(i << 1) + 1]);\n  }\n \n  int n;\n  vector<node> tree;\n \n  void build(int i, int l, int h) {\n    if (l == h) {\n      return;\n    }\n    int m = (l + h) >> 1;\n    build(i << 1, l, m);\n    build((i << 1) + 1, m + 1, h);\n    pull(i);\n  }\n \n  template <typename M>\n  void build(int i, int l, int h, const vector<M> &v) {\n    if (l == h) {\n      tree[i].apply(l, h, v[l]);\n      return;\n    }\n    int m = (l + h) >> 1;\n    build(i << 1, l, m, v);\n    build((i << 1) + 1, m + 1, h, v);\n    pull(i);\n  }\n \n  node get(int i, int l, int h, int ql, int qh) {\n    if (ql <= l && h <= qh) {\n      return tree[i];\n    }\n    int m = (l + h) >> 1;\n    push(i, l, h);\n    node res{};\n    if (qh <= m) {\n      res = get(i << 1, l, m, ql, qh);\n    } else {\n      if (ql > m) {\n        res = get((i << 1) + 1, m + 1, h, ql, qh);\n      } else {\n        res = unite(get(i << 1, l, m, ql, qh), get((i << 1) + 1, m + 1, h, ql, qh));\n      }\n    }\n    pull(i);\n    return res;\n  }\n \n  template <typename... M>\n  void modify(int i, int l, int h, int ql, int qh, const M&... v) {\n    if (ql <= l && h <= qh) {\n      tree[i].apply(l, h, v...);\n      return;\n    }\n    push(i, l, h);\n    int m = (l + h) >> 1;\n    if (qh <= m) {\n      modify(i << 1, l, m, ql, qh, v...);\n    } else {\n      if (ql > m) {\n        modify((i << 1) + 1, m + 1, h, ql, qh, v...);\n      } else {\n        modify(i << 1, l, m, ql, qh, v...);\n        modify((i << 1) + 1, m + 1, h, ql, qh, v...);\n      }\n    }\n    pull(i);\n  }\n \n  int find_first_knowingly(int i, int l, int h, const function<bool(const node&)> &f) {\n    if (l == h) {\n      return l;\n    }\n    push(i, l, h);\n    int m = (l + h) >> 1;\n    int res;\n    if (f(tree[i << 1])) {\n      res = find_first_knowingly(i << 1, l, m, f);\n    } else {\n      res = find_first_knowingly((i << 1) + 1, m + 1, h, f);\n    }\n    pull(i);\n    return res;\n  }\n \n  int find_first(int i, int l, int h, int ql, int qh, const function<bool(const node&)> &f) {\n    if (ql <= l && h <= qh) {\n      if (!f(tree[i])) {\n        return -1;\n      }\n      return find_first_knowingly(i, l, h, f);\n    }\n    push(i, l, h);\n    int m = (l + h) >> 1;\n    int res = -1;\n    if (ql <= m) {\n      res = find_first(i << 1, l, m, ql, qh, f);\n    }\n    if (qh > m && res == -1) {\n      res = find_first((i << 1) + 1, m + 1, h, ql, qh, f);\n    }\n    pull(i);\n    return res;\n  }\n \n  int find_last_knowingly(int i, int l, int h, const function<bool(const node&)> &f) {\n    if (l == h) {\n      return l;\n    }\n    push(i, l, h);\n    int m = (l + h) >> 1;\n    int res;\n    if (f(tree[(i << 1) + 1])) {\n      res = find_last_knowingly((i << 1) + 1, m + 1, h, f);\n    } else {\n      res = find_last_knowingly(i << 1, l, m, f);\n    }\n    pull(i);\n    return res;\n  }\n \n  int find_last(int i, int l, int h, int ql, int qh, const function<bool(const node&)> &f) {\n    if (ql <= l && h <= qh) {\n      if (!f(tree[i])) {\n        return -1;\n      }\n      return find_last_knowingly(i, l, h, f);\n    }\n    push(i, l, h);\n    int m = (l + h) >> 1;\n    int res = -1;\n    if (qh > m) {\n      res = find_last((i << 1) + 1, m + 1, h, ql, qh, f);\n    }\n    if (ql <= m && res == -1) {\n      res = find_last(i << 1, l, m, ql, qh, f);\n    }\n    pull(i);\n    return res;\n  }\n \n  segtree(int _n) : n(_n) {\n    assert(n > 0);\n    tree.resize(4 * n);\n    build(1, 0, n - 1);\n  }\n \n  template <typename M>\n  segtree(const vector<M> &v) {\n    n = v.size();\n    assert(n > 0);\n    tree.resize(4 * n);\n    build(1, 0, n - 1, v);\n  }\n \n  node get(int ql, int qh) {\n    assert(0 <= ql && ql <= qh && qh <= n - 1);\n    return get(1, 0, n - 1, ql, qh);\n  }\n \n  node get(int p) {\n    assert(0 <= p && p <= n - 1);\n    return get(1, 0, n - 1, p, p);\n  }\n \n  template <typename... M>\n  void modify(int ql, int qh, const M&... v) {\n    assert(0 <= ql && ql <= qh && qh <= n - 1);\n    modify(1, 0, n - 1, ql, qh, v...);\n  }\n\n  // find_first and find_last call all FALSE elements\n  // to the left (right) of the sought position exactly once\n \n  int find_first(int ql, int qh, const function<bool(const node&)> &f) {\n    assert(0 <= ql && ql <= qh && qh <= n - 1);\n    return find_first(1, 0, n - 1, ql, qh, f);\n  }\n \n  int find_last(int ql, int qh, const function<bool(const node&)> &f) {\n    assert(0 <= ql && ql <= qh && qh <= n - 1);\n    return find_last(1, 0, n - 1, ql, qh, f);\n  }\n};\n"],"description":"segtree_tourist"},"sieve":{"prefix":"sieve","body":["//calc upto SQRT(n) = m primes using simple_sieve then calc remaining primes using segmented_sieve\r\nconst int N = (int) 1e8;\r\nconst int M = (int) 1e4;\r\nvector <int> primes;\r\nvector <bool> isprime(M + 1);\r\n\r\nvoid simple_sieve() {\r\n  fill(isprime.begin(), isprime.end(), true);\r\n\r\n  for (int i = 2; i * i <= M; i++) {\r\n    if (isprime[i]) {\r\n      for (int j = i * i; j <= M; j += i) {\r\n        isprime[j] = false;\r\n      }\r\n    }\r\n  }\r\n\r\n  primes.push_back(2);\r\n  for (int i = 3; i <= M; i += 2) {\r\n    if (isprime[i]) {\r\n      primes.push_back(i);\r\n    }\r\n  }\r\n}\r\n\r\nvoid segmented_sieve() {  \r\n  int limit = M + 1;\r\n  int low = limit;\r\n  int high = 2 * limit;\r\n\r\n  while (low < N) {\r\n    if (high >= N) high = N;\r\n    bool mark[limit + 1];\r\n    fill(mark, mark + limit + 1, true);\r\n\r\n    for (int i = 0; i < (int) primes.size(); i++) {\r\n      int lolimit = (low / primes[i]) * primes[i];\r\n      if (lolimit < low) {\r\n        lolimit += primes[i];\r\n      }\r\n      for (int j = lolimit; j < high; j += primes[i]) {\r\n        mark[j - low] = false;\r\n      }\r\n    }\r\n\r\n    for (int i = low; i < high; i++) {\r\n      if (mark[i - low]) {\r\n        primes.push_back(i);\r\n      } \r\n    }\r\n\r\n    low = high;\r\n    high += limit;\r\n  }  \r\n}"],"description":"sieve"},"sparse":{"prefix":"sparse","body":["//function must be overlapping friendly e.g min, max, gcd, lcm\r\ntemplate <typename T, class F = function<T(const T&, const T&)>>\r\nclass SparseTable {\r\n public:\r\n  int n;\r\n  vector<vector<T>> mat;\r\n  F func;\r\n \r\n  SparseTable(const vector<T>& a, const F& f) : func(f) {\r\n    n = static_cast<int>(a.size());\r\n    int max_log = 32 - __builtin_clz(n);\r\n    mat.resize(max_log);\r\n    mat[0] = a;\r\n    for (int i = 1; i < max_log; i++) {\r\n      mat[i].resize(n - (1 << i) + 1);\r\n      for (int j = 0; j <= n - (1 << i); j++) {\r\n        mat[i][j] = func(mat[i - 1][j], mat[i - 1][j + (1 << (i - 1))]);\r\n      }\r\n    }\r\n  }\r\n \r\n  T get(int from, int to) const {\r\n    assert(0 <= from && from <= to && to <= n - 1);\r\n    int lg = 32 - __builtin_clz(to - from + 1) - 1;\r\n    return func(mat[lg][from], mat[lg][to - (1 << lg) + 1]);\r\n  }\r\n};\r\n\r\n...vector <int> arr;\r\n...SparseTable <int> st(arr, [&](const int& a, const int& b) { return min(a, b); });"],"description":"sparse"},"splay":{"prefix":"splay","body":["class node {\r\n public:\r\n  node* l;\r\n  node* r;\r\n  node* p;\r\n  bool rev;\r\n  // declare extra variables:\r\n  int tl;\r\n  int tr;\r\n  int tv;\r\n  int ml;\r\n  int mr;\r\n  int mv;\r\n  int sm;\r\n  int id;\r\n \r\n  void init(int _tl, int _tr, int _tv, int _id) {\r\n    l = r = p = NULL;\r\n    rev = false;\r\n    // init extra variables:\r\n    tl = _tl;\r\n    tr = _tr;\r\n    tv = _tv;\r\n    ml = tl;\r\n    mr = tr;\r\n    mv = tv;\r\n    sm = tv;\r\n    id = _id;\r\n  }\r\n \r\n  void unsafe_reverse() {\r\n    rev ^= 1;\r\n    swap(l, r);\r\n    pull();\r\n  }\r\n \r\n  // apply changes:\r\n  void unsafe_apply() {\r\n  }\r\n \r\n  void push() {\r\n    if (rev) {\r\n      if (l != NULL) {\r\n        l->unsafe_reverse();\r\n      }\r\n      if (r != NULL) {\r\n        r->unsafe_reverse();\r\n      }\r\n      rev = 0;\r\n    }\r\n    // now push everything else:\r\n  }\r\n \r\n  void pull() {\r\n    // now init from self:\r\n    ml = tl;\r\n    mr = tr;\r\n    mv = tv;\r\n    sm = tv;\r\n    if (l != NULL) {\r\n      l->p = this;\r\n      // now pull from l:\r\n      ml = min(ml, l->ml);\r\n      mr = max(mr, l->mr);\r\n      mv = max(mv, l->mv);\r\n      sm += l->sm;\r\n    }\r\n    if (r != NULL) {\r\n      r->p = this;\r\n      // now pull from r:\r\n      ml = min(ml, r->ml);\r\n      mr = max(mr, r->mr);\r\n      mv = max(mv, r->mv);\r\n      sm += r->sm;\r\n    }\r\n  }\r\n};\r\n\r\nnamespace splay_tree {\r\n  bool is_bst_root(node* v) {\r\n    if (v == NULL) {\r\n      return false;\r\n    }\r\n    return (v->p == NULL || (v->p->l != v && v->p->r != v));\r\n  }\r\n   \r\n  void rotate(node* v) {\r\n    node* u = v->p;\r\n    assert(u != NULL);\r\n    u->push();\r\n    v->push();\r\n    v->p = u->p;\r\n    if (v->p != NULL) {\r\n      if (v->p->l == u) {\r\n        v->p->l = v;\r\n      }\r\n      if (v->p->r == u) {\r\n        v->p->r = v;\r\n      }\r\n    }\r\n    if (v == u->l) {\r\n      u->l = v->r;\r\n      v->r = u;\r\n    } else {\r\n      u->r = v->l;\r\n      v->l = u;\r\n    }\r\n    u->pull();\r\n    v->pull();\r\n  }\r\n   \r\n  void splay(node* v) {\r\n    if (v == NULL) {\r\n      return;\r\n    }\r\n    while (!is_bst_root(v)) {\r\n      node* u = v->p;\r\n      if (!is_bst_root(u)) {\r\n        if ((u->l == v) ^ (u->p->l == u)) {\r\n          rotate(v);\r\n        } else {\r\n          rotate(u);\r\n        }\r\n      }\r\n      rotate(v);\r\n    }\r\n  }\r\n   \r\n  pair<node*, int> find(node* v, const function<int(node*)> &go_to) {\r\n    // go_to returns: 0 -- found; -1 -- go left; 1 -- go right\r\n    // find returns the last vertex on the descent and its go_to\r\n    if (v == NULL) {\r\n      return {NULL, 0};\r\n    }\r\n    splay(v);\r\n    int dir;\r\n    while (true) {\r\n      v->push();\r\n      dir = go_to(v);\r\n      if (dir == 0) {\r\n        break;\r\n      }\r\n      node* u = (dir == -1 ? v->l : v->r);\r\n      if (u == NULL) {\r\n        break;\r\n      }\r\n      v = u;\r\n    }\r\n    splay(v);\r\n    return {v, dir};\r\n  }\r\n   \r\n  node* get_leftmost(node* v) {\r\n    return find(v, [&](node*) {\r\n      return -1;\r\n    }).first;\r\n  }\r\n   \r\n  node* get_rightmost(node* v) {\r\n    return find(v, [&](node*) {\r\n      return 1;\r\n    }).first;\r\n  }\r\n   \r\n  node* get_bst_root(node* v) {\r\n    splay(v);\r\n    return v;\r\n  }\r\n   \r\n  pair<node*, node*> split(node* v, const function<bool(node*)> &is_right) {\r\n    if (v == NULL) {\r\n      return {NULL, NULL};\r\n    }\r\n    pair<node*, int> p = find(v, [&](node * u) {\r\n      return is_right(u) ? -1 : 1;\r\n    });\r\n    v = p.first;\r\n    v->push();\r\n    if (p.second == -1) {\r\n      node* u = v->l;\r\n      if (u == NULL) {\r\n        return {NULL, v};\r\n      }\r\n      v->l = NULL;\r\n      u->p = v->p;\r\n      u = get_rightmost(u);\r\n      v->p = u;\r\n      v->pull();\r\n      return {u, v};\r\n    } else {\r\n      node* u = v->r;\r\n      if (u == NULL) {\r\n        return {v, NULL};\r\n      }\r\n      v->r = NULL;\r\n      v->pull();\r\n      return {v, u};\r\n    }\r\n  }\r\n   \r\n  node* merge(node* v, node* u) {\r\n    if (v == NULL) {\r\n      return u;\r\n    }\r\n    if (u == NULL) {\r\n      return v;\r\n    }\r\n    v = get_rightmost(v);\r\n    assert(v->r == NULL);\r\n    splay(u);\r\n    v->push();\r\n    v->r = u;\r\n    v->pull();\r\n    return v;\r\n  }\r\n   \r\n  node* add(node* r, node* v, const function<bool(node*)> &go_left) {\r\n    pair<node*, node*> p = split(r, go_left);\r\n    return merge(p.first, merge(v, p.second));\r\n  }\r\n   \r\n  node* remove(node* v) { // returns the new root\r\n    splay(v);\r\n    v->push();\r\n    node* x = v->l;\r\n    node* y = v->r;\r\n    v->l = v->r = NULL;\r\n    node* z = merge(x, y);\r\n    if (z != NULL) {\r\n      z->p = v->p;\r\n    }\r\n    v->p = NULL;\r\n    v->push();\r\n    v->pull(); // now v might be reusable...\r\n    return z;\r\n  }\r\n   \r\n  node* next(node* v) {\r\n    splay(v);\r\n    v->push();\r\n    if (v->r == NULL) {\r\n      return NULL;\r\n    }\r\n    v = v->r;\r\n    while (v->l != NULL) {\r\n      v->push();\r\n      v = v->l;\r\n    }\r\n    splay(v);\r\n    return v;\r\n  }\r\n   \r\n  node* prev(node* v) {\r\n    splay(v);\r\n    v->push();\r\n    if (v->l == NULL) {\r\n      return NULL;\r\n    }\r\n    v = v->l;\r\n    while (v->r != NULL) {\r\n      v->push();\r\n      v = v->r;\r\n    }\r\n    splay(v);\r\n    return v;\r\n  }\r\n   \r\n  template<typename... T>\r\n  void apply(node* v, T... args) {\r\n    splay(v);\r\n    v->unsafe_apply(args...);\r\n  }\r\n   \r\n  void reverse(node* v) {\r\n    splay(v);\r\n    v->unsafe_reverse();\r\n  }\r\n}\r\n \r\nusing namespace splay_tree;"],"description":"splay"},"sqrd":{"prefix":"sqrd","body":["template <typename T>\r\nclass sqrd {\r\n public:\r\n  struct block {\r\n    //set variables with default values\r\n    int ans = ...\r\n  };\r\n  vector <T> arr;\r\n  vector <block> b;\r\n  int size;\r\n  void unite(block &u, T val) const {\r\n    ... u = u + val\r\n  }\r\n  void remove(block &u, T val) const {\r\n    ... u = u - val\r\n  } \r\n\r\n  sqrd(vector <T> &_arr) {\r\n    arr = _arr;\r\n    int n = _arr.size();\r\n    size = (int) sqrt(n + 0.1) + 1;\r\n    b = vector <block> (size);\r\n    for (int i = 0; i < n; i++) {\r\n      unite(b[i / size], _arr[i]);\r\n    } \r\n  }\r\n  void modify(int i, T val) {\r\n    remove(b[i / size], arr[i]);\r\n    unite(b[i / size], val);\r\n    arr[i] = val;\r\n  } \r\n  ... get(int L, int H) {\r\n    int ans = ...\r\n    for (int i = L; i <= H; ) {\r\n      if (i % size == 0 && i + size - 1 <= H) {\r\n        block u = b[i / size];\r\n        ...ans = ans + u\r\n        i += size;\r\n      } else {\r\n        ...ans = ans + arr[i]\r\n        i++;\r\n      }\r\n    }\r\n    return ans;\r\n  } \r\n};\r\n"],"description":"sqrd"},"stack":{"prefix":"stack","body":["template <typename T> \r\nstring to_string(stack <T> &st) {\r\n  bool first = true;\r\n  string res = \"}\";\r\n  stack <T> temp = st;\r\n  while (!temp.empty()) {\r\n    T x = temp.top();\r\n    temp.pop();\r\n    if (!first) {\r\n      res += \" ,\";\r\n    }\r\n    first = false;\r\n    res += to_string(x); \r\n  } \r\n  res += \"{\";\r\n  reverse(res.begin(), res.end());\r\n  return res;\r\n}"],"description":"stack"},"sub":{"prefix":"sub","body":["inline void sub(int &a, int b) {\r\n  a -= b;\r\n  if (a < 0) {\r\n    a += mod;\r\n  }\r\n}"],"description":"sub"},"subset":{"prefix":"subset","body":["//..iterative\r\ntemplate <typename T>\r\nvector <vector <T>> subset(vector <T>& arr) {\r\n  int n = arr.size();\r\n  int total = ((1 << n) - 1);\r\n  vector <vector <T>> ss(total);\r\n\r\n  for (int mask = 1; mask <= total; mask++) {\r\n    for (int sh = 0; sh < n; sh++) {\r\n      if ((mask & (1 << sh)) != 0) {\r\n        ss[mask - 1].push_back(arr[sh]);\r\n      } \r\n    }\r\n  }\r\n  ...ss.push_back(vector <T>());\r\n  return ss;\r\n}\r\n\r\n//..recursive\r\ntemplate <typename T>\r\nvoid subsetUtil(int idx, int n, vector <T> &temp, vector <vector <T>> &ss, vector <T> &arr) {\r\n  if (idx == n) {\r\n    ss.push_back(temp);\r\n    return;\r\n  } \r\n  //..including  \r\n  temp.push_back(arr[idx]);\r\n  subsetUtil(idx + 1, n, temp, ss, arr);\r\n  temp.pop_back();\r\n  //..excluding\r\n  subsetUtil(idx + 1, n, temp, ss, arr);\r\n} \r\n\r\ntemplate <typename T>\r\nvector <vector <T>> subset(vector <T>& arr) {\r\n  vector <vector <T>> ss;\r\n  int n = arr.size();\r\n  vector <T> temp;\r\n  subsetUtil(0, n, temp, ss, arr);\r\n  ...ss.push_back(vector <T>());\r\n  return ss;\r\n}  "],"description":"subset"},"suffix_array":{"prefix":"suffix_array","body":["/* tourist's template\r\ntemplate <typename T>\r\nvector<int> suffix_array(int n, const T &s, int char_bound) {\r\n  vector<int> a(n);\r\n  if (n == 0) {\r\n    return a;\r\n  }\r\n  if (char_bound != -1) {\r\n    vector<int> aux(char_bound, 0);\r\n    for (int i = 0; i < n; i++) {\r\n      aux[s[i]]++;\r\n    }\r\n    int sum = 0;\r\n    for (int i = 0; i < char_bound; i++) {\r\n      int add = aux[i];\r\n      aux[i] = sum;\r\n      sum += add;\r\n    }\r\n    for (int i = 0; i < n; i++) {\r\n      a[aux[s[i]]++] = i;\r\n    }\r\n  } else {\r\n    iota(a.begin(), a.end(), 0);\r\n    sort(a.begin(), a.end(), [&s](int i, int j) { return s[i] < s[j]; });\r\n  }\r\n  vector<int> sorted_by_second(n);\r\n  vector<int> ptr_group(n);\r\n  vector<int> new_group(n);\r\n  vector<int> group(n);\r\n  group[a[0]] = 0;\r\n  for (int i = 1; i < n; i++) {\r\n    group[a[i]] = group[a[i - 1]] + (!(s[a[i]] == s[a[i - 1]]));\r\n  }\r\n  int cnt = group[a[n - 1]] + 1;\r\n  int step = 1;\r\n  while (cnt < n) {\r\n    int at = 0;\r\n    for (int i = n - step; i < n; i++) {\r\n      sorted_by_second[at++] = i;\r\n    }\r\n    for (int i = 0; i < n; i++) {\r\n      if (a[i] - step >= 0) {\r\n        sorted_by_second[at++] = a[i] - step;\r\n      }\r\n    }\r\n    for (int i = n - 1; i >= 0; i--) {\r\n      ptr_group[group[a[i]]] = i;\r\n    }\r\n    for (int i = 0; i < n; i++) {\r\n      int x = sorted_by_second[i];\r\n      a[ptr_group[group[x]]++] = x;\r\n    }\r\n    new_group[a[0]] = 0;\r\n    for (int i = 1; i < n; i++) {\r\n      if (group[a[i]] != group[a[i - 1]]) {\r\n        new_group[a[i]] = new_group[a[i - 1]] + 1;\r\n      } else {\r\n        int pre = (a[i - 1] + step >= n ? -1 : group[a[i - 1] + step]);\r\n        int cur = (a[i] + step >= n ? -1 : group[a[i] + step]);\r\n        new_group[a[i]] = new_group[a[i - 1]] + (pre != cur);\r\n      }\r\n    }\r\n    swap(group, new_group);\r\n    cnt = group[a[n - 1]] + 1;\r\n    step <<= 1;\r\n  }\r\n  return a;\r\n}\r\n \r\ntemplate <typename T>\r\nvector<int> suffix_array(const T &s, int char_bound) {\r\n  return suffix_array((int) s.size(), s, char_bound);\r\n}\r\n//..vector <int> sa = suffix_array(str, 256);\r\n*/\r\n\r\n//Mine\r\nnamespace suffix {\r\n  int char_bound = 256;\r\n  struct suf { \r\n    int idx;\r\n    vector <int> rank;\r\n    suf() { rank.resize(2); }\r\n  }; \r\n\r\n  void radix_sort(vector <suf>& sufs, int idx = 1) { \r\n    int n = sufs.size();\r\n    vector <int> bucket(char_bound + 1, 0);\r\n    vector <suf> temp(n);\r\n    for (int i = 0; i < n; i++) {\r\n      bucket[sufs[i].rank[idx] + 1]++;\r\n    }\r\n    for (int i = 1; i < char_bound; i++) {\r\n      bucket[i] += bucket[i - 1];\r\n    }\r\n    for (int i = n - 1; i >= 0; i--) {\r\n      temp[bucket[sufs[i].rank[idx] + 1] - 1] = sufs[i];\r\n      bucket[sufs[i].rank[idx] + 1]--;\r\n    }\r\n    for (int i = 0; i < n; i++) {\r\n      sufs[i] = temp[i];\r\n    }\r\n    temp.clear();\r\n    if (idx == 0) return;\r\n    else radix_sort(sufs, 0);\r\n  } \r\n\r\n  vector <int> suffix_array(const string &str) {\r\n    int n = str.length();\r\n    vector <suf> sufs(n);\r\n    for (int i = 0; i < n; i++) { \r\n      sufs[i].idx = i;\r\n      sufs[i].rank[0] = str[i];\r\n      sufs[i].rank[1] = ((i + 1) < n) ? str[i + 1] : -1;\r\n    }\r\n    radix_sort(sufs);\r\n    vector <int> ind(n);\r\n    for (int k = 4; k < 2 * n; k = k * 2) { \r\n      int rank = 0; \r\n      int prev_rank = sufs[0].rank[0];\r\n      sufs[0].rank[0] = rank;\r\n      ind[sufs[0].idx] = 0;\r\n      for (int i = 1; i < n; i++) {\r\n        if (sufs[i].rank[0] == prev_rank && sufs[i].rank[1] == sufs[i - 1].rank[1]) { \r\n          prev_rank = sufs[i].rank[0]; \r\n          sufs[i].rank[0] = rank; \r\n        } else {\r\n          prev_rank = sufs[i].rank[0]; \r\n          sufs[i].rank[0] = ++rank; \r\n        } \r\n        ind[sufs[i].idx] = i; \r\n      } \r\n      for (int i = 0; i < n; i++) { \r\n        int next = sufs[i].idx + k / 2; \r\n        sufs[i].rank[1] = (next < n) ? sufs[ind[next]].rank[0] : -1; \r\n      } \r\n      radix_sort(sufs);\r\n    } \r\n    vector <int> a(n);\r\n    for (int i = 0; i < n; i++) { \r\n      a[i] = sufs[i].idx; \r\n    }\r\n    return a; \r\n  } \r\n}\r\n\r\nusing suffix::suffix_array;"],"description":"suffix_array"},"suffix_automaton":{"prefix":"suffix_automaton","body":["class suffix_automaton {\r\n public:\r\n  struct state {\r\n    int len;\r\n    int link;\r\n    int fpos;\r\n    map<char, int> next;\r\n  };\r\n\r\n  string str;\r\n  int n;\r\n  vector <state> st;\r\n  int size;\r\n  int last;\r\n  vector <bool> terminals;\r\n\r\n  suffix_automaton(const string &istr) {\r\n    str = istr + ...//'$' or istr (for min_shift;\r\n    n = istr.length();\r\n    st.resize(2 * n);\r\n    st[0].len = 0;\r\n    st[0].link = -1;\r\n    size++;\r\n    last = 0;\r\n  }\r\n\r\n  suffix_automaton() {\r\n\r\n  }\r\n\r\n  void add(char c) {\r\n    int cur = size++;\r\n    st[cur].len = st[last].len + 1;\r\n    st[cur].fpos = st[cur].len - 1;\r\n    int p = last;\r\n    while (p != -1 && !st[p].next.count(c)) {\r\n      st[p].next[c] = cur;\r\n      p = st[p].link;\r\n    }\r\n    if (p == -1) {\r\n      st[cur].link = 0;\r\n      st[cur].fpos = st[cur].len - 1;\r\n    } else {\r\n      int q = st[p].next[c];\r\n      if (st[p].len + 1 == st[q].len) {\r\n        st[cur].link = q;\r\n        st[cur].fpos = st[cur].len - 1;\r\n      } else {\r\n        int clone = size++;\r\n        st[clone].len = st[p].len + 1;\r\n        st[clone].next = st[q].next;\r\n        st[clone].link = st[q].link;\r\n        st[clone].fpos = st[q].fpos;\r\n        while (p != -1 && st[p].next[c] == q) {\r\n          st[p].next[c] = clone;\r\n          p = st[p].link;\r\n        }\r\n        st[q].link = st[cur].link = clone;\r\n      }\r\n    }\r\n    last = cur;\r\n  }\r\n\r\n  vector <int> topo_sort() {\r\n    vector <int> order;\r\n    vector <int> deg(last + 1, 0);\r\n    for (int u = 0; u < last + 1; u++) {\r\n      for (int ch = 0; ch <= 256; ch++) {\r\n        if (st[u].next.count(ch)) {\r\n          int v = st[u].next[ch];\r\n          deg[v]++;\r\n        } \r\n      } \r\n    }\r\n    queue <int> from;\r\n    for (int u = 0; u < last + 1; u++) {\r\n      if (deg[u] == 0) {\r\n        from.push(u);\r\n      } \r\n    } \r\n    while (!from.empty()) {\r\n      int u = from.front();\r\n      from.pop();\r\n      order.emplace_back(u);\r\n      for (int ch = 0; ch <= 256; ch++) {\r\n        if (st[u].next.count(ch)) {\r\n          int v = st[u].next[ch];\r\n          if (deg[v] == 1) {\r\n            from.push_back(v);\r\n          }\r\n          deg[v]--;\r\n        } \r\n      } \r\n    }\r\n    return order;\r\n  } \r\n  \r\n  void build() {\r\n    for (char ch : str) {\r\n      add(ch);\r\n    } \r\n    terminals.resize(last + 1);\r\n    fill(terminals.begin(), terminals.end(), false);\r\n    int p = last;\r\n    while(p > 0) {\r\n      terminals[p] = true;  \r\n      p = st[p].link;\r\n    }\r\n  }\r\n\r\n  vector <int> dp;\r\n  int different() {\r\n    dp.resize(last + 1);\r\n    fill(dp.begin(), dp.end(), -1);\r\n    auto Dfs = [&](auto Self, int u) {\r\n      if (dp[u] != -1) return dp[u];\r\n      int cnt = 0;\r\n      for (int ch = 0; ch <= 256; ch++) {\r\n        if (st[u].next.count(ch)) {\r\n          cnt += Self(Self, st[u].next[ch]);\r\n        } \r\n      } \r\n      return dp[u] = cnt + 1;\r\n    };\r\n\r\n    int ret = 0;\r\n    for (int ch = 0; ch <= 256; ch++) {\r\n      if (st[0].next.count(ch)) {\r\n        ret += Dfs(Dfs, st[0].next[ch]);\r\n      }\r\n    }     \r\n    return ret;\r\n  }\r\n\r\n  int length_sum() {\r\n    different();\r\n\r\n    vector <int> ans(last + 1, -1);\r\n    auto Dfs = [&](auto Self, int u) {\r\n      if (ans[u] != -1) return ans[u];\r\n      int cnt = 0;\r\n      for (int ch = 0; ch <= 256; ch++) {\r\n        if (st[u].next.count(ch)) {\r\n          cnt += Self(Self, st[u].next[ch]) + dp[st[u].next[ch]];\r\n        } \r\n      } \r\n      return ans[u] = cnt;\r\n    };\r\n\r\n    int ret = 0;\r\n    for (int ch = 0; ch <= 256; ch++) {\r\n      if (st[0].next.count(ch)) {\r\n        ret += Dfs(Dfs, st[0].next[ch]);\r\n      }\r\n    }     \r\n    return ret;\r\n  } \r\n\r\n  string kthlex(int k) {\r\n    string ans;\r\n    int path = 0;\r\n    bool found = false;\r\n    auto Dfs = [&](auto Self, int u) {\r\n      for (int ch = 0; ch <= 256; ch++) {\r\n        if (st[u].next.count(ch)) {\r\n          path++;\r\n          if (path == k) {\r\n            found = true;            \r\n            ans.push_back(ch);\r\n            return;\r\n          }\r\n          Self(Self, st[u].next[ch]);\r\n          if (path == k) { \r\n            ans.push_back(ch);\r\n            return;\r\n          }\r\n        } \r\n      }\r\n    }\r\n\r\n    for (int ch = 0; ch <= 256; ch++) {\r\n      if (st[0].next.count(ch)) {\r\n        Dfs(Dfs, st[0].next[ch]);\r\n        if (found) break;\r\n      }\r\n    }\r\n    return ans;\r\n  }\r\n\r\n  //..minimum shift to obtain smallest (lexico)\r\n  int min_shift() {\r\n    int t = n / 2;\r\n    int tp = 0;\r\n    bool found = false;\r\n    auto Dfs = [&](auto Self, int u) {\r\n      for (int ch = 0; ch <= 256; ch++) {\r\n        if (st[u].next.count(ch)) {\r\n          tp++;\r\n          if (tp == t) {\r\n            found = true;\r\n            //..cout << st[u].fpos - t + 2 << endl;\r\n            break;\r\n          }\r\n          Self(Self, st[u].next[ch]);\r\n          if (found) break;\r\n        } \r\n      }\r\n    }\r\n\r\n    for (int ch = 0; ch <= 256; ch++) {\r\n      if (st[0].next.count(ch)) {\r\n        Dfs(Dfs, st[0].next[ch]);\r\n        if (found) break;\r\n      }\r\n    }\r\n  } \r\n\r\n  bool occurs(const string &pat) {\r\n    int pos = 0;\r\n    for (char c : pat) {\r\n      int found = st[pos].next.count[c];\r\n      if (!found) return false;\r\n      pos = st[pos].next[c];\r\n    } \r\n    return true;\r\n  }\r\n  \r\n  //..contruct using suffix_automaton st();\r\n  string lcs(string s, string t) {\r\n    str = s;\r\n    n = s.length();\r\n    st.resize(2 * n);\r\n    st[0].len = 0;\r\n    st[0].link = -1;\r\n    size++;\r\n    last = 0;\r\n    \r\n    int v = 0, l = 0,\r\n    int best = 0, bestpos = 0;\r\n    for (int i = 0; i < (int)t.length(); i++) {\r\n      while (v && !st[v].next.count(t[i])) {\r\n        v = st[v].link;\r\n        l = st[v].len;\r\n      }\r\n      if (st[v].next.count(t[i])) {\r\n        v = st[v].next[t[i]];\r\n        ++l;\r\n      }\r\n      if (l > best) {\r\n        best = l;\r\n        bestpos = i;\r\n      }\r\n    }\r\n    return t.substr(bestpos - best + 1, best);\r\n  } \r\n\r\n  vector <int> match(const string &pat) {\r\n    \r\n  } \r\n}; \r\n"],"description":"suffix_automaton"},"swap":{"prefix":"swap","body":["inline void swap(int& a, int& b) {\r\n  a = a ^ b;\r\n  b = a ^ b;\r\n  a = a ^ b;\r\n}"],"description":"swap"},"tarjan":{"prefix":"tarjan","body":["template <typename T>\r\nvector<int> tarjan(const digraph<T> &g, int &cnt) {\r\n  vector <bool> seen(g.n, false);\r\n  vector <int> low(g.n, 0);\r\n  vector <int> dis(g.n, 0);\r\n  vector <bool> active(g.n, false);\r\n  stack <int> st;\r\n  vector <int> grp(g.n, -1);\r\n  int timer = 0;\r\n  cnt = 0;\r\n  \r\n  function<void(int)> dfs = [&](int u) {\r\n    seen[u] = true;\r\n    active[u] = true;\r\n    st.push(u);\r\n\r\n    dis[u] = low[u] = ++timer;\r\n    for (int id : g.g[u]) {\r\n      int v = g.edges[id].from ^ g.edges[id].to ^ u;\r\n      if (!seen[v]) {\r\n        dfs(v);\r\n        low[u] = min(low[u], low[v]);\r\n      } else if (active[v]) {\r\n        low[u] = min(low[u], dis[v]);\r\n      } \r\n    }\r\n        \r\n    if (low[u] == dis[u]) {\r\n      //..find SCC\r\n      while (st.top() != u) {\r\n        int v = st.top();\r\n        grp[v] = cnt;\r\n        active[v] = false;\r\n        st.pop();\r\n      } \r\n      int v = st.top();\r\n      grp[v] = cnt;\r\n      active[v] = false;\r\n      st.pop();\r\n      cnt++;\r\n    }\r\n  };  \r\n\r\n  for (int i = 0; i < g.n; i++) {\r\n    if (!seen[i]) {\r\n      dfs(i);\r\n    }\r\n  }\r\n  return grp;\r\n  //.. grp[i] <= grp[j] for every edge i -> j\r\n}"],"description":"tarjan"},"template":{"prefix":"template","body":[":insert\r\n/**\r\n *    author:  math2do\r\n *    created: 19.05.2020 10:20:29 IST\r\n**/\r\n\r\n#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nint main() {\r\n  ios_base::sync_with_stdio(false);\r\n  cin.tie(0);\r\n\r\n  return 0;\r\n}\r\n."],"description":"template"},"test":{"prefix":"test","body":["@echo off\r\nfor /l %%x in (1, 1, 10) do (\r\n  echo test case %%x ... ??\r\n  gen > sol.in\r\n  sol < sol.in > sol.out\r\n  foo < sol.in > foo.out\r\n\r\n  fc sol.out foo.out /N > comp.out || exit /b\r\n  echo test case %%x passed\r\n  echo:\r\n  echo:\r\n)\r\necho all tests passed"],"description":"test"},"tester":{"prefix":"tester","body":["@echo off\r\nfor /l %%x in (1, 1, 10) do (\r\n  echo test case %%x ... ??\r\n  gen > sol.in\r\n  sol < sol.in > sol.out\r\n  foo < sol.in > foo.out\r\n\r\n  fc sol.out foo.out /N > comp.out || exit /b\r\n  echo test case %%x passed\r\n  echo:\r\n  echo:\r\n)\r\necho all tests passed"],"description":"tester"},"tick":{"prefix":"tick","body":["inline double tick() {\r\n  static clock_t oldtick;\r\n  clock_t newtick = clock();\r\n  double diff = 1.0 * (newtick - oldtick) / CLOCKS_PER_SEC;\r\n  oldtick = newtick;\r\n  return diff;\r\n}"],"description":"tick"},"toposort":{"prefix":"toposort","body":["/*\r\n//..Mine\r\nusing DFS to find topological sorting : dfs_toposort\r\nusing Kahn's algorithm for topological sorting : kahn_toposort\r\n*/\r\ntemplate <typename T>\r\nvector<int> find_toposort(const digraph<T> &g) {\r\n  vector<int> deg(g.n, 0);\r\n  for (int id = 0; id < (int) g.edges.size(); id++) {\r\n    deg[g.edges[id].to]++;\r\n  }\r\n  vector<int> x;\r\n  for (int i = 0; i < g.n; i++) {\r\n    if (deg[i] == 0) {\r\n      x.push_back(i);\r\n    }\r\n  }\r\n  for (int ptr = 0; ptr < (int) x.size(); ptr++) {\r\n    int i = x[ptr];\r\n    for (int id : g.g[i]) {\r\n      auto &e = g.edges[id];\r\n      int to = e.to;\r\n      if (--deg[to] == 0) {\r\n        x.push_back(to);\r\n      }\r\n    }\r\n  }\r\n  if ((int) x.size() != g.n) {\r\n    return vector<int>();\r\n  }\r\n  return x;\r\n}\r\n"],"description":"toposort"},"treap":{"prefix":"treap","body":["mt19937 rng((unsigned int) chrono::steady_clock::now().time_since_epoch().count());\r\n \r\nclass node {\r\n  public:\r\n  int id;\r\n  node* l;\r\n  node* r;\r\n  node* p;\r\n  bool rev;\r\n  int sz;\r\n  // declare extra variables:\r\n  int P;\r\n \r\n  node(int _id) {\r\n    id = _id;\r\n    l = r = p = NULL;\r\n    rev = false;\r\n    sz = 1;\r\n    // init extra variables:\r\n    P = rng();\r\n  }\r\n \r\n  void unsafe_reverse() {\r\n    rev ^= 1;\r\n    swap(l, r);\r\n    pull();\r\n  }\r\n \r\n  // apply changes:\r\n  void unsafe_apply() {\r\n    \r\n  }\r\n \r\n  void push() {\r\n    if (rev) {\r\n      if (l != NULL) {\r\n        l->unsafe_reverse();\r\n      }\r\n      if (r != NULL) {\r\n        r->unsafe_reverse();\r\n      }\r\n      rev = 0;\r\n    }\r\n    // now push everything else:\r\n \r\n  }\r\n \r\n  void pull() {\r\n    sz = 1;\r\n    // now init from self:\r\n \r\n    if (l != NULL) {\r\n      l->p = this;\r\n      sz += l->sz;\r\n      // now pull from l:\r\n \r\n    }\r\n    if (r != NULL) {\r\n      r->p = this;\r\n      sz += r->sz;\r\n      // now pull from r:\r\n \r\n    }\r\n  }\r\n};\r\n \r\nvoid debug_node(node* v, string pref = \"\") {\r\n  #ifdef LOCAL\r\n    if (v != NULL) {\r\n      debug_node(v->r, pref + \" \");\r\n      cerr << pref << \"-\" << \" \" << v->id << '\\n';\r\n      debug_node(v->l, pref + \" \");\r\n    } else {\r\n      cerr << pref << \"-\" << \" \" << \"NULL\" << '\\n';\r\n    }\r\n  #endif\r\n}\r\n \r\nnamespace treap {\r\n  pair<node*,int> find(node* v, const function<int(node*)> &go_to) {\r\n    // go_to returns: 0 -- found; -1 -- go left; 1 -- go right\r\n    // find returns the last vertex on the descent and its go_to\r\n    if (v == NULL) {\r\n      return {NULL, 0};\r\n    }\r\n    int dir;\r\n    while (true) {\r\n      v->push();\r\n      dir = go_to(v);\r\n      if (dir == 0) {\r\n        break;\r\n      }\r\n      node* u = (dir == -1 ? v->l : v->r);\r\n      if (u == NULL) {\r\n        break;\r\n      }\r\n      v = u;\r\n    }\r\n    return {v, dir};\r\n  }\r\n \r\n  node* get_leftmost(node* v) {\r\n    return find(v, [&](node*) { return -1; }).first;\r\n  }\r\n \r\n  node* get_rightmost(node* v) {\r\n    return find(v, [&](node*) { return 1; }).first;\r\n  }\r\n \r\n  node* get_kth(node* v, int k) { // 0-indexed\r\n    pair<node*,int> p = find(v, [&](node* u) {\r\n      if (u->l != NULL) {\r\n        if (u->l->sz > k) {\r\n          return -1;\r\n        }\r\n        k -= u->l->sz;\r\n      }\r\n      if (k == 0) {\r\n        return 0;\r\n      }\r\n      k--;\r\n      return 1;\r\n    });\r\n    return (p.second == 0 ? p.first : NULL);\r\n  }\r\n \r\n  int get_position(node* v) { // 0-indexed\r\n    int k = (v->l != NULL ? v->l->sz : 0);\r\n    while (v->p != NULL) {\r\n      if (v == v->p->r) {\r\n        k++;\r\n        if (v->p->l != NULL) {\r\n          k += v->p->l->sz;\r\n        }\r\n      }\r\n      v = v->p;\r\n    }\r\n    return k;\r\n  }\r\n \r\n  node* get_bst_root(node* v) {\r\n    while (v->p != NULL) {\r\n      v = v->p;\r\n    }\r\n    return v;\r\n  }\r\n \r\n  pair<node*,node*> split(node* v, const function<bool(node*)> &is_right) {\r\n    if (v == NULL) {\r\n      return {NULL, NULL};\r\n    }\r\n    v->push();\r\n    if (is_right(v)) {\r\n      pair<node*,node*> p = split(v->l, is_right);\r\n      if (p.first != NULL) {\r\n        p.first->p = NULL;\r\n      }\r\n      v->l = p.second;\r\n      v->pull();\r\n      return {p.first, v};\r\n    } else {\r\n      pair<node*,node*> p = split(v->r, is_right);\r\n      v->r = p.first;\r\n      if (p.second != NULL) {\r\n        p.second->p = NULL;\r\n      }\r\n      v->pull();\r\n      return {v, p.second};\r\n    }\r\n  }\r\n \r\n  pair<node*,node*> split_leftmost_k(node* v, int k) {\r\n    return split(v, [&](node* u) {\r\n      int left_and_me = (u->l != NULL ? u->l->sz : 0) + 1;\r\n      if (k >= left_and_me) {\r\n        k -= left_and_me;\r\n        return false;\r\n      }\r\n      return true;\r\n    });\r\n  }\r\n \r\n  node* merge(node* v, node* u) {\r\n    if (v == NULL) {\r\n      return u;\r\n    }\r\n    if (u == NULL) {\r\n      return v;\r\n    }\r\n    if (v->P > u->P) {\r\n//    if (rng() % (v->sz + u->sz) < (unsigned int) v->sz) {\r\n      v->push();\r\n      v->r = merge(v->r, u);\r\n      v->pull();\r\n      return v;\r\n    } else {\r\n      u->push();\r\n      u->l = merge(v, u->l);\r\n      u->pull();\r\n      return u;\r\n    }\r\n  }\r\n \r\n  int count_left(node* v, const function<bool(node*)> &is_right) {\r\n    if (v == NULL) {\r\n      return 0;\r\n    }\r\n    v->push();\r\n    if (is_right(v)) {\r\n      return count_left(v->l, is_right);\r\n    }\r\n    return (v->l != NULL ? v->l->sz : 0) + 1 + count_left(v->r, is_right);\r\n  }\r\n \r\n  node* add(node* r, node* v, const function<bool(node*)> &go_left) {\r\n    pair<node*,node*> p = split(r, go_left);\r\n    return merge(p.first, merge(v, p.second));\r\n  }\r\n \r\n  node* remove(node* v) { // returns the new root\r\n    v->push();\r\n    node* x = v->l;\r\n    node* y = v->r;\r\n    node* p = v->p;\r\n    v->l = v->r = v->p = NULL;\r\n    v->push();\r\n    v->pull(); // now v might be reusable...\r\n    node* z = merge(x, y);\r\n    if (p == NULL) {\r\n      if (z != NULL) {\r\n        z->p = NULL;\r\n      }\r\n      return z;\r\n    }\r\n    if (p->l == v) {\r\n      p->l = z;\r\n    }\r\n    if (p->r == v) {\r\n      p->r = z;\r\n    }\r\n    while (true) {\r\n      p->push();\r\n      p->pull();\r\n      if (p->p == NULL) {\r\n        break;\r\n      }\r\n      p = p->p;\r\n    }\r\n    return p;\r\n  }\r\n \r\n  node* next(node* v) {\r\n    if (v->r == NULL) {\r\n      while (v->p != NULL && v->p->r == v) {\r\n        v = v->p;\r\n      }\r\n      return v->p;\r\n    }\r\n    v->push();\r\n    v = v->r;\r\n    while (v->l != NULL) {\r\n      v->push();\r\n      v = v->l;\r\n    }\r\n    return v;\r\n  }\r\n \r\n  node* prev(node* v) {\r\n    if (v->l == NULL) {\r\n      while (v->p != NULL && v->p->l == v) {\r\n        v = v->p;\r\n      }\r\n      return v->p;\r\n    }\r\n    v->push();\r\n    v = v->l;\r\n    while (v->r != NULL) {\r\n      v->push();\r\n      v = v->r;\r\n    }\r\n    return v;\r\n  }\r\n \r\n  int get_size(node* v) {\r\n    return (v != NULL ? v->sz : 0);\r\n  }\r\n \r\n  template<typename... T>\r\n  void apply(node* v, T... args) {\r\n    v->unsafe_apply(args...);\r\n  }\r\n \r\n  void reverse(node* v) {\r\n    v->unsafe_reverse();\r\n  }\r\n}\r\n \r\nusing namespace treap;"],"description":"treap"},"trie":{"prefix":"trie","body":["template <bool child_cnt_matter>\r\nclass trie {\r\n public:\r\n  using pbb = pair <bool, bool>;\r\n  static constexpr int size = ...\r\n  inline int hash(char ch) { \r\n    return ch - ...; \r\n  }\r\n  struct Node {\r\n    bool end;\r\n    int all;\r\n    int end_cnt;\r\n    vector <Node*> c;\r\n    vector <int> cnt;\r\n    Node() : end(false), all(0), end_cnt(0) {\r\n      c.resize(size);\r\n      cnt.resize(size);\r\n      for (int i = 0; i < size; i++) {\r\n        c[i] = NULL;\r\n        cnt[i] = 0;\r\n      } \r\n    } \r\n  };\r\n\r\n  string sub;\r\n  void Dfs(Node* node, int depth) {\r\n    for (int i = 0; i < size; i++) {\r\n      if (node->c[i] != NULL) {\r\n        sub.push_back((char) (i + '...'));\r\n        cerr << sub << endl;\r\n        Dfs(node->c[i], depth + 1);\r\n        sub.pop_back();\r\n      } \r\n    }\r\n    ...int from = node->end_cnt + (node->all - used);\r\n    ...int many = from / k;\r\n    ...int rem = from % k;\r\n    ...ans += depth * many;\r\n    cerr << \"node : \" << sub << endl;\r\n    cerr << \"depth : \" << depth << endl;\r\n    cerr << \"ends here : \" << node->end_cnt << endl;\r\n    cerr << \"passes through : \" << node->all << endl;\r\n  } \r\n\r\n  void solve() {\r\n    for (int i = 0; i < size; i++) {\r\n      if (root->c[i] != NULL) {\r\n        sub.push_back((char) (i + '...'));\r\n        cerr << sub << endl;\r\n        Dfs(root->c[i], 1);\r\n        sub.pop_back();\r\n      }\r\n    }\r\n  }\r\n  \r\n  bool insert(Node* node, const string &str, int idx) {\r\n    int len = str.length();\r\n    if (idx == len) {\r\n      if (node->end) {\r\n        //..handle no duplicates by returning false\r\n        ...\r\n      }\r\n      node->end_cnt++;\r\n      node->end = true;\r\n      return true;\r\n    }\r\n    int pos = hash(str[idx]);\r\n    Node *temp = node->c[pos];\r\n    if (temp == NULL) {\r\n      temp = new Node();\r\n      node->c[pos] = temp;\r\n    }\r\n    bool res = insert(temp, str, idx + 1);\r\n    if (res == true) {\r\n      node->cnt[pos]++;\r\n      node->all++;\r\n    }\r\n    return res;\r\n  } \r\n\r\n  bool insert(const string &str) {\r\n    if (child_cnt_matter) { \r\n      bool res = insert(root, str, 0);\r\n      return res;\r\n    }\r\n\r\n    //..insertion with duplicates\r\n    Node* crawl = root;\r\n    int len = str.length();\r\n    for (int idx = 0; idx < len; idx++) {\r\n      int pos = hash(str[idx]);\r\n      if (!crawl->c[pos]) {\r\n        crawl->c[pos] = new Node();\r\n      }\r\n      crawl->cnt[pos]++;\r\n      crawl->all++;\r\n      crawl = crawl->c[pos];\r\n    }\r\n    crawl->end_cnt++;\r\n    crawl->end = true;\r\n    return true;\r\n  }\r\n  bool search(const string &str) {\r\n    Node* crawl = root;\r\n    int len = str.length();\r\n    for (int idx = 0; idx < len; idx++) {\r\n      int pos = hash(str[idx]);\r\n      if (!crawl->c[pos]) {\r\n        return false;\r\n      }\r\n      crawl = crawl->c[pos];\r\n    }\r\n    if (crawl->end) return true;\r\n    return false;\r\n  }\r\n\r\n  //..first = was present, second = is child subtree completely removed\r\n  pbb remove(Node* node, const string &str, int idx) {\r\n    int len = str.length();\r\n    if (node == NULL) return {false, false};\r\n    if (idx == len) {\r\n      if (!node->end) return {false, false};\r\n      if (node->all == 0) {\r\n        delete node;\r\n        return {true, true};\r\n      }\r\n      node->end_cnt--;     // deleting only one of same words\r\n      node->end_cnt = 0 .. // deleting all same words\r\n      if (node->end_cnt == 0) {\r\n        node->end = false;\r\n      }\r\n      return {true, false};\r\n    }\r\n\r\n    int pos = hash(str[idx]);\r\n    Node* temp = node->c[pos];\r\n    if (temp == NULL) return {false, false};\r\n    pbb res = remove(temp, str, idx + 1);\r\n    if (res.first) {\r\n      if (res.second) {\r\n        node->c[pos] = NULL;\r\n      }\r\n      node->cnt[pos]--;\r\n      node->all--;\r\n      if (node->all == 0) {\r\n        delete node;\r\n        return {true, true};\r\n      }\r\n      return {true, false};\r\n    }\r\n    return res;\r\n  }\r\n\r\n  bool remove(const string& str) {\r\n    pbb res = remove(root, str, 0);\r\n    return res.first;\r\n  } \r\n \r\n  Node* root;\r\n  trie() {  this->root = new Node(); }\r\n};"],"description":"trie"},"turn":{"prefix":"turn","body":["const int L = -1;\r\nconst int S = 0;\r\nconst int R = 1; \r\nint turn(const point &p, const point &q, const point &r) { \r\n  int val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y); \r\n  if (val == 0) return S;\r\n  return (val > 0) ? R : L;\r\n}"],"description":"turn"},"twosat":{"prefix":"twosat","body":["class twosat {\n public:\n  digraph<int> g;\n  int n;\n\n  twosat(int _n) : g(digraph<int>(2 * _n)), n(_n) {\n  }\n\n  // (v[x] == value_x)\n  inline void add(int x, int value_x) {\n    assert(0 <= x && x < n);\n    assert(0 <= value_x && value_x <= 1);\n    g.add(2 * x + (value_x ^ 1), 2 * x + value_x);\n  }\n  \n  // (v[x] == value_x || v[y] == value_y)\n  inline void add(int x, int value_x, int y, int value_y) {\n    assert(0 <= x && x < n && 0 <= y && y < n);\n    assert(0 <= value_x && value_x <= 1 && 0 <= value_y && value_y <= 1);\n    g.add(2 * x + (value_x ^ 1), 2 * y + value_y);\n    g.add(2 * y + (value_y ^ 1), 2 * x + value_x);\n  }\n\n  inline vector<int> solve() {\n    int cnt;\n    vector<int> c = find_scc(g, cnt);\n    vector<int> res(n);\n    for (int i = 0; i < n; i++) {\n      if (c[2 * i] == c[2 * i + 1]) {\n        return vector<int>();\n      }\n      res[i] = (c[2 * i] < c[2 * i + 1]);\n    }\n    return res;\n  }\n};"],"description":"twosat"},"u128":{"prefix":"u128","body":["long long M = 1LL << 50; \r\nstruct u128 {\r\n  long long lo, hi;\r\n  long double val() {\r\n    return (long double) M * hi + lo;\r\n  }\r\n};\r\n\r\nu128 operator + (const u128 &a, const u128 &b) {\r\n  return u128{(a.lo + b.lo) & (M - 1), a.hi + b.hi + ((a.lo + b.lo) >> 50)};\r\n}\r\n\r\nu128 operator - (const u128 &a, const u128 &b) {\r\n  if (a.lo >= b.lo) return u128{a.lo - b.lo, a.hi - b.hi};\r\n  else return u128{a.lo - b.lo + M, a.hi - b.hi - 1};\r\n}"],"description":"u128"},"ull":{"prefix":"ull","body":["using ull = unsigned long long int;"],"description":"ull"},"undigraph":{"prefix":"undigraph","body":["template <typename T>\r\nclass undigraph : public graph<T> {\r\n public:\r\n  using graph<T>::edges;\r\n  using graph<T>::g;\r\n  using graph<T>::n;\r\n \r\n  undigraph(int _n) : graph<T>(_n) {\r\n  }\r\n \r\n  int add(int from, int to, T cost = 1) {\r\n    assert(0 <= from && from < n && 0 <= to && to < n);\r\n    int id = (int) edges.size();\r\n    g[from].push_back(id);\r\n    g[to].push_back(id);\r\n    edges.push_back({from, to, cost});\r\n    return id;\r\n  }\r\n};"],"description":"undigraph"},"union":{"prefix":"union","body":["int klee(const vector<pair<int, int>> &a) {\r\n  int n = a.size();\r\n  vector<pair<int, bool>> x(n * 2);\r\n  for (int i = 0; i < n; i++) {\r\n    x[i * 2] = {a[i].first, false};\r\n    x[i * 2 + 1] = {a[i].second, true};\r\n  }\r\n\r\n  sort(x.begin(), x.end());\r\n\r\n  int result = 0;\r\n  int cnt = 0;\r\n  for (int i = 0; i < n * 2; i++) {\r\n    if (i > 0 && x[i].first > x[i - 1].first && cnt > 0) {\r\n      result += x[i].first - x[i - 1].first;\r\n    }\r\n\r\n    if (x[i].second) cnt--;\r\n    else cnt++;\r\n  }\r\n  return result;\r\n}"],"description":"union"},"unique":{"prefix":"unique","body":["template <typename T>\r\ninline void unique(vector <T> &arr) {\r\n  auto it = unique(arr.begin(), arr.end(), [&](const T &a, const T &b) -> bool {\r\n    return a == b;  \r\n  });\r\n  arr.resize(it - arr.begin());\r\n} "],"description":"unique"},"upper_bound":{"prefix":"upper_bound","body":["template <typename T>\r\nint upper_bound(vector <T> arr, T x) {\r\n  int n = (int) arr.size();\r\n  int l = 0, h = n - 1;\r\n  int ans = -1;\r\n\r\n  while (l <= h) {\r\n    int m = l + (h - l) / 2;\r\n\r\n    if (x < arr[m]) {  // a[m] can possibly be upper_bound\r\n      ans = m;\r\n      h = m - 1;\r\n    } else {\r\n      l = m + 1;\r\n    } \r\n  }\r\n\r\n  return ans == -1 ? n : ans;\r\n}\r\n"],"description":"upper_bound"},"vec":{"prefix":"vec","body":["template <typename T>\r\nistream &operator>>(istream &is, vector <T> &arr) {\r\n  for (T &val : arr) is >> val;\r\n  return is;\r\n}\r\n\r\ntemplate <typename T>\r\nostream &operator<<(ostream &os, vector <T> &arr) {\r\n  for (T &val : arr) os << val << ' ';\r\n  return os;\r\n}"],"description":"vec"},"window":{"prefix":"window","body":["//..using priority_queue\r\nvector<int> slidingWindow(const vector<int> &arr, int k) {\r\n  priority_queue <pair <int, int>> pq;\r\n  int n = arr.size();\r\n  for (int i = 0; i < k; i++) {\r\n    pq.push(make_pair(arr[i], i));\r\n  }\r\n  pair <int, int> pr = pq.top();\r\n  vector <int> ans;\r\n  ans.push_back(pr.first);\r\n  \r\n  for (int i = k; i < n; i++) {\r\n    pq.push(make_pair(arr[i], i));\r\n\r\n    while (true) {\r\n      pair <int, int> pr = pq.top();\r\n      if (pr.second <= i - k) {\r\n        pq.pop();\r\n        continue;\r\n      }\r\n      ans.push_back(pr.first);\r\n      break;\r\n    }\r\n  }\r\n  return ans;\r\n}\r\n\r\n//..using double-ended queue\r\nvector<int> slidingWindow(const vector<int> &arr, int k) {\r\n  int n = arr.size();\r\n  list <int> dq;\r\n  vector <int> ans;\r\n  for (int i = 0; i < k; i++) {\r\n    while (!dq.empty() && arr[dq.back()] < arr[i]) {\r\n      dq.pop_back();\r\n    }\r\n    dq.push_back(i);\r\n  }\r\n  for (int i = k; i < n; i++) {\r\n    ans.push_back(arr[dq.front()]);\r\n    if (dq.front() <= i - k) dq.pop_front();\r\n    while (!dq.empty() && arr[dq.back()] < arr[i]) {\r\n      dq.pop_back();\r\n    }\r\n    dq.push_back(i);\r\n  }\r\n  ans.push_back(arr[dq.front()]);\r\n  return ans;\r\n}"],"description":"window"},"z":{"prefix":"z","body":["template <typename T>\r\nvector<int> z_function(int n, const T &s) {\r\n  vector<int> z(n, n);\r\n  int l = 0, r = 0;\r\n  for (int i = 1; i < n; i++) {\r\n    z[i] = (i > r ? 0 : min(r - i + 1, z[i - l]));\r\n    while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {\r\n      z[i]++;\r\n    }\r\n    if (i + z[i] - 1 > r) {\r\n      l = i;\r\n      r = i + z[i] - 1;\r\n    }\r\n  }\r\n  return z;\r\n  //..z[i] = longest suffix starting at i that is also a prefix starting at 0\r\n}\r\n\r\ntemplate <typename T>\r\nvector<int> z_function(const T &s) {\r\n  return z_function((int) s.size(), s);\r\n}\r\n\r\n//Mine\r\n//..kshf.....l....i........h\r\nvector <int> buildZ_array(const string& pat, const string &txt) {\r\n  string str = pat + \"$\" + txt;\r\n  int len = str.length();\r\n  vector <int> z(len, 0);\r\n  int l = 0, h = 0;\r\n  for (int i = 1; i < len; i++) {\r\n    if (i > h) {\r\n      l = h = i;\r\n      while (h < len && str[h] == str[h - l]) {\r\n        h++;\r\n      }\r\n      h--; \r\n      z[i] = h - l + 1;\r\n    } else {\r\n      int look = i - l;\r\n      if (z[look] < h - i + 1) {\r\n        z[i] = z[look];\r\n      } else {\r\n        l = i;\r\n        while (h < len && str[h] == str[h - l]) {\r\n          h++;\r\n        }\r\n        h--; \r\n        z[i] = h - l + 1;\r\n      } \r\n    } \r\n  } \r\n  return z;\r\n  //..z[i] = longest suffix starting at i that is also a prefix\r\n} \r\n\r\nvector <int> Z_Algorithm(const string& pat, const string& txt) {\r\n  vector <int> z = buildZ_array(pat, txt);\r\n  vector <int> pos;\r\n  for (int i = 0; i < (int) z.size(); i++) {\r\n    if (z[i] == (int) pat.length()) {\r\n      int idx = i - pat.length() - 1;\r\n      pos.emplace_back(idx);\r\n    } \r\n  }\r\n \r\n  return pos;\r\n  //..starting indices of txt where matching starts\r\n} "],"description":"z"}}