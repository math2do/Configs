# Geany's snippets configuration file
#
# use \n or %newline% for a new line (it will be replaced by the used EOL char(s) - LF, CR/LF, CR).
# use \t or %ws% for an indentation step, it will be replaced according to the current document's indent mode.
# use \s to force whitespace at beginning or end of a value ('key= value' won't work, use 'key=\svalue').
# use %key% for all keys defined in the [Special] section.
# use %cursor% to define where the cursor should be placed after completion. You can define multiple
    # %cursor% wildcards and use the "Move cursor in snippet" to jump to the next defined cursor
    # position in the completed snippet.
# You can define a section for each supported filetype to overwrite default settings, the section
# name must match exactly the internal filetype name, run 'geany --ft-names' for a full list.
#
# Additionally, you can use most of the template wildcards like {developer}, {command:...},
# or {date} in the snippets.
# See the documentation for details.

# For a list of available filetype names, execute:
# geany --ft-names

# Default is used for all filetypes and keys can be overwritten by [filetype] sections
[Default]

# special keys to be used in other snippets, cannot be used "standalone"
# can be used by %key%, e.g. %brace_open%
# nesting of special keys is not supported (e.g. brace_open=\n{\n%brace_close% won't work)
# key "wordchars" is very special, it defines the word delimiting characters when looking for
# a word to auto complete, leave commented to use the default wordchars
[Special]
brace_open=\n{\n\t
brace_close=}\n
block=\n{\n\t%cursor%\n}
block_cursor=\n{\n\t%cursor%\n}
#wordchars=_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789

# Optional keybindings to insert snippets
# Note: these can be overridden by Geany's configurable keybindings
[Keybindings]
#for=<Ctrl>7
sol=<Ctrl>u

[C]
if=if (%cursor%)%block_cursor%
else=else%block_cursor%
for=for (i = 0; i < %cursor%; i++)%block_cursor%
while=while (%cursor%)%block_cursor%
do=do\n{\n\t%cursor%\n} while (%cursor%)\n
switch=switch (%cursor%)%brace_open%case %cursor%:\n\t\t%cursor%\n\t\tbreak;\n\tdefault:\n\t\t%cursor%\n%brace_close%

[Sh]
test=for ((i = 1; i <= 100; i++)) do\n  echo "test case $i ... ??"\n  ./gen > in\n  ./sol < in > sol.out\n  ./foo < in > foo.out\n  diff -w sol.out foo.out || break\n  echo "test case $i passed"\n  echo "" \ndone
comp=for ((i = 1; i <= 100; i++)) do\n  echo "test case $i ... ??"\n  ./gen > in\n  ./sol < in > sol.out\n  ./foo < in > foo.out\n  diff -w sol.out foo.out || break\n  echo "test case $i passed"\n  echo "" \ndone
tester=for ((i = 1; i <= 100; i++)) do\n  echo "test case $i ... ??"\n  ./gen > in\n  ./sol < in > sol.out\n  ./foo < in > foo.out\n  diff -w sol.out foo.out || break\n  echo "test case $i passed"\n  echo "" \ndone

[C++]
if=if (%cursor%)%block_cursor%
else=else%block_cursor%
# for=for (int i = 0; i < %cursor%; i++)%brace_open%\n%brace_close%
for=for (int i = 0; i < %cursor%; i++)
fori=for (int i = 0; i < %cursor%; i++)
forj=for (int j = 0; j < %cursor%; j++)
fork=for (int k = 0; k < %cursor%; k++)

while=while (%cursor%)%block_cursor%
do=do\n{\n\t%cursor%\n} while (%cursor%)\n
switch=switch (%cursor%)%brace_open%case %cursor%:\n\t\t%cursor%\n\t\tbreak;\n\tdefault:\n\t\t%cursor%\n%brace_close%
try=try%block%\ncatch (%cursor%)%block_cursor%
sol = /**\n *    author:  math2do\n *    created: {datetime}\n**/ \n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include "lib/debug.h"\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\t%cursor%\n\treturn 0;\n}
# custom c++ templates
4d=vector <int> dx = {-1, 0, 1, 0};\nvector <int> dy = {0, 1, 0, -1};\n
8d=vector <int> dx = {-1, -1, 0, 1, 1, 1, 0, -1};\nvector <int> dy = {0, 1, 1, 1, 0, -1, -1, -1};\n
add=inline void add(int &a, int b) {\n  a += b;\n  if (a >= mod) {\n    a -= mod;\n  }\n}\n
aho_corasick=template <bool child_cnt_matter>\nclass aho_corasick {\n public:\n  using pbb = pair <bool, bool>;\n  static constexpr int size = ...\n  inline int hash(char ch) { \n    return ch - ...; \n  }\n\n  struct _node {\n   public:\n    bool end;\n    int all;\n    int end_cnt;\n    vector <_node*> c;\n    vector <int> cnt;\n    vector <int> nth;\n    set <int> chars;\n    _node *link;\n    _node() : end(false), all(0), end_cnt(0), link(NULL) {\n      c.resize(size);\n      cnt.resize(size);\n      for (int i = 0; i < size; i++) {\n        c[i] = NULL;\n        cnt[i] = 0;\n      } \n    } \n  };\n  \n  bool insert(_node* node, const string &str, int idx, int at) {\n    int len = str.length();\n    if (idx == len) {\n      if (node->end) {\n        //..handle no duplicates by returning false\n        ...\n      }\n      node->nth.push_back(at);\n      node->end_cnt++;\n      node->end = true;\n      return true;\n    }\n    int pos = hash(str[idx]);\n    _node *temp = node->c[pos];\n    if (temp == NULL) {\n      temp = new _node();\n      node->c[pos] = temp;\n      node->chars.insert(pos);\n    }\n    bool res = insert(temp, str, idx + 1, at);\n    if (res == true) {\n      node->cnt[pos]++;\n      node->all++;\n    }\n    return res;\n  } \n\n  bool insert(vector <string> &arr) {\n    pats.insert(pats.end(), arr.begin(), arr.end());\n    int m = arr.size();\n    if (child_cnt_matter) {\n      for (int ith = 0; ith < m; ith++) {\n        string& str = arr[ith];\n        insert(root, str, 0, n + ith);\n      }\n      n += m;\n      return true;\n    }\n\n    //..insertion with duplicates\n    for (int ith = 0; ith < m; ith++) {\n      _node* crawl = root;\n      string& str = arr[ith];\n      int len = str.length();\n      for (int idx = 0; idx < len; idx++) {\n        int pos = hash(str[idx]);\n        if (!crawl->c[pos]) {\n          crawl->c[pos] = new _node();\n          crawl->chars.insert(pos);\n        }\n        crawl->cnt[pos]++;\n        crawl->all++;\n        crawl = crawl->c[pos];\n      }\n      crawl->end_cnt++;\n      crawl->nth.push_back(n + ith);\n      crawl->end = true;\n    }\n    n += m;\n    return true;\n  }\n  bool insert(const string& str) {\n    vector <string> arr(1, str);\n    bool res = insert(arr);\n    return res;\n  } \n\n  bool find(const string &str) {\n    _node* crawl = root;\n    int len = str.length();\n    for (int idx = 0; idx < len; idx++) {\n      int pos = hash(str[idx]);\n      if (!crawl->c[pos]) {\n        return false;\n      }\n      crawl = crawl->c[pos];\n    }\n    if (crawl->end) return true;\n    return false;\n  }\n\n  //..first = was present, second = is child subtree completely removed\n  pbb remove(_node* node, const string &str, int idx) {\n    int len = str.length();\n    if (node == NULL) return {false, false};\n    if (idx == len) {\n      if (!node->end) return {false, false};\n      if (node->all == 0) {\n        delete node;\n        return {true, true};\n      }\n      node->end_cnt--;     // deleting only one of same words\n      node->end_cnt = 0 .. // deleting all same words\n      if (node->end_cnt == 0) {\n        node->end = false;\n      }\n      return {true, false};\n    }\n\n    int pos = hash(str[idx]);\n    _node* temp = node->c[pos];\n    if (temp == NULL) return {false, false};\n    pbb res = remove(temp, str, idx + 1);\n    if (res.first) {\n      if (res.second) {\n        node->c[pos] = NULL;\n      }\n      node->cnt[pos]--;\n      node->all--;\n      if (node->all == 0) {\n        delete node;\n        return {true, true};\n      }\n      return {true, false};\n    }\n    return res;\n  }\n\n  bool remove(const string& str) {\n    pbb res = remove(root, str, 0);\n    return res.first;\n  }\n\n  //..very much similar to lps pattern matching\n  inline void Move(_node* &temp, int pos) {\n    while (!temp->c[pos]) {\n      temp = temp->link;\n    }\n    temp = temp->c[pos];\n  }\n\n  void build() {\n    queue <_node*> q;\n    for (int pos = 0; pos < size; pos++) {\n      if (root->c[pos]) {\n        q.push(root->c[pos]);\n        root->c[pos]->link = root;\n      } else {\n        root->c[pos] = root;\n      } \n    }\n        \n    while (!q.empty()) {\n      int level = (int) q.size();\n      while (level--) {\n        _node* u = q.front(); q.pop();\n        for (int pos : u->chars) {  \n          q.push(u->c[pos]);\n          _node* temp = u->link;\n          Move(temp, pos);\n          u->c[pos]->link = temp; \n          u->c[pos]->nth.insert(u->c[pos]->nth.end(), (temp->nth).begin(), (temp->nth).end());\n        } \n      }\n    } \n  } \n\n  vector <vector <int>> match(const string &txt) {\n    int len = txt.length();\n    _node* temp = root;\n    vector <vector <int>> ans(n);\n    for  (int idx = 0; idx < len; idx++) {\n      int pos = hash(txt[idx]);\n      Move(temp, pos);\n      for (int ith : temp->nth) {\n        int m = pats[ith].length();\n        ans[ith].push_back(idx + 1 - m);\n      } \n    }\n    return ans;\n    // ans[i] contains first indexing where ith patthern started matching\n  } \n\n  vector <string> pats;\n  int n;\n  _node* root;\n  aho_corasick() {\n    root = new _node();\n    root->link = root; \n    n = 0;\n  }\n};\n\n/*\naho_corasick<true> ac;\nac.insert(pat);\nac.build();\nvector <vector <int>> match = ac.match(txt);\n*/\n
angle=auto angle = [&] (int h, int m) {\n  if (h == 12) h = 0;  \n  if (m == 60) m = 0;  \n  double ang_h = (double) 0.5 * (h * 60 + m);\n  double ang_m = (double) 6.0 * m;\n  double ang = abs(ang_h - ang_m);\n  if (ang > 180.0) {\n    ang = 360 - ang;\n  }\n  return ang;\n};\n
area=double area(vector <Point> &arr) {\n  int n = arr.size();\n  double area = 0.0;   \n  int j = n - 1;\n  for (int i = 0; i < n; i++) { \n    area += (arr[j].x + arr[i].x) * (arr[j].y - arr[i].y);\n    j = i; \n  } \n  return abs(area / 2.0); \n}\n
arr=  for (int i = 0; i < n; i++) {\n\n  } \n
articulation=template <typename T>\nvector <int> articulation(const undigraph <T> &g) {\n  vector <bool> seen(g.n, false);\n  vector <int> low(g.n, 0);\n  vector <int> dis(g.n, 0);\n  vector <int> pv(g.n, -1);\n  vector <bool> art(g.n, false);\n  int timer = 0;\n\n  function <void(int)> dfs = [&](int u) {\n    seen[u] = true;\n    dis[u] = low[u] = ++timer;\n    int child_cnt = 0;\n    for (int id : g.g[u]) {\n      int v = g.edges[id].from ^ g.edges[id].to ^ u;\n      if (!seen[v]) {\n        child_cnt++;\n        pv[v] = u;\n        dfs(v);\n        low[u] = min(low[u], low[v]);\n        if (pv[u] == -1 && child_cnt > 1) {\n          art[u] = true;\n        }\n        if (pv[u] != -1 && low[v] >= dis[u]) {\n          art[u] = true;\n        }\n      } else if (v != pv[u]) {\n        low[u] = min(low[u], dis[v]);\n      }\n    }\n  };\n  dfs(0);\n  vector <int> ans;\n  for (int i = 0; i < g.n; i++) {\n    if (art[i]) {\n      ans.push_back(i);\n    } \n  } \n\n  return ans;\n  // returns sorted list of weak vertices\n} \n
bellman_ford=template <typename T>\nvector <T> bellman_ford(const graph<T> &g, int from, bool& neg) {\n  neg = false;\n  T inf = numeric_limits<T>::max();\n  vector <T> dist(g.n, inf);\n  dist[from] = 0;\n\n  auto relax = [&](auto &e) -> bool {\n    bool done = false;\n    int u = e.from;\n    int v = e.to;\n    int w = e.cost;\n    if (dist[u] != inf && dist[u] + w < dist[v]) {\n      dist[v] = dist[u] + w;\n      done = true;\n    }\n    return done;\n  };\n\n  //relax all edges g.n - 1 times\n  for (int qq = 1; qq <= g.n - 1; qq++) {\n    for (auto &e : g.edges) {\n      relax(e);\n    }\n  } \n\n  //if it relaxes more, then it contains negative cycle\n  for (auto &e : g.edges) {\n    if (relax(e)) {\n      neg = true;\n      goto end;\n    } \n  }\n  end : {\n    return dist;\n  }\n  //dist[i] = distance to 'i' from 'from', inf if not reachable\n  //neg = true if negative cycle is present\n}\n
bfs=auto bfs = [&](int from) {\n  vector <bool> seen(g.n, false);\n  vector <int> dist(g.n, numeric_limits<T>::max());\n  queue <int> q;\n  q.push(from);\n  seen[from] = true;\n  dist[from] = 0;\n  int depth = 0;\n  while (!q.empty()) {\n    int size = (int) q.size();\n    while (size--) {\n      int u = q.front(); q.pop();\n      dist[u] = depth;\n      for (int id : g.g[u]) {\n        int v = g.edges[id].from ^ g.edges[id].to ^ u;\n        if (!seen[v]) {\n          seen[v] = true;\n          q.push(v);\n        }\n      } \n    }\n    depth += 1;\n  }\n  return dist;\n};\n
bicone=template <typename T>\nvector<int> find_bicone(dfs_undigraph<T> &g, int &cnt) {\n  g.dfs_all();\n  vector<int> vertex_comp(g.n);\n  cnt = 0;\n  for (int i : g.order) {\n    if (g.pv[i] == -1 || g.min_depth[i] == g.depth[i]) {\n      vertex_comp[i] = cnt++;\n    } else {\n      vertex_comp[i] = vertex_comp[g.pv[i]];\n    }\n  }\n  return vertex_comp;\n}\n
bigint=namespace BigInteger {\n  const int base = 1000000000;\n  const int base_digits = 9;\n   \n  struct bigint {\n    vector<int> z;\n    int sign;\n   \n    bigint() : sign(1) {}\n   \n    bigint(long long v) {\n      *this = v;\n    }\n   \n    bigint(const string &s) {\n      read(s);\n    }\n   \n    void operator=(const bigint &v) {\n      sign = v.sign;\n      z = v.z;\n    }\n   \n    void operator=(long long v) {\n      sign = 1;\n      if (v < 0) {\n        sign = -1, v = -v;\n      }\n      z.clear();\n      for (; v > 0; v = v / base) {\n        z.push_back((int) (v % base));\n      }\n    }\n   \n    bigint operator+(const bigint &v) const {\n      if (sign == v.sign) {\n        bigint res = v;\n        for (int i = 0, carry = 0; i < (int) max(z.size(), v.z.size()) || carry; ++i) {\n          if (i == (int) res.z.size()) {\n            res.z.push_back(0);\n          }\n          res.z[i] += carry + (i < (int) z.size() ? z[i] : 0);\n          carry = res.z[i] >= base;\n          if (carry) {\n            res.z[i] -= base;\n          }\n        }\n        return res;\n      } else {\n        return *this - (-v);\n      }\n    }\n   \n    bigint operator-(const bigint &v) const {\n      if (sign == v.sign) {\n        if (abs() >= v.abs()) {\n          bigint res = *this;\n          for (int i = 0, carry = 0; i < (int) v.z.size() || carry; ++i) {\n            res.z[i] -= carry + (i < (int) v.z.size() ? v.z[i] : 0);\n            carry = res.z[i] < 0;\n            if (carry) {\n              res.z[i] += base;\n            }\n          }\n          res.trim();\n          return res;\n        } else {\n          return -(v - *this);\n        }\n      } else {\n        return *this + (-v);\n      }\n    }\n   \n    void operator*=(int v) {\n      if (v < 0) {\n        sign = -sign, v = -v;\n      }\n      for (int i = 0, carry = 0; i < (int) z.size() || carry; ++i) {\n        if (i == (int) z.size()) {\n          z.push_back(0);\n        }\n        long long cur = (long long) z[i] * v + carry;\n        carry = (int) (cur / base);\n        z[i] = (int) (cur % base);\n        //asm("divl %%ecx" : "=a"(carry), "=d"(a[i]) : "A"(cur), "c"(base));\n      }\n      trim();\n    }\n   \n    bigint operator*(int v) const {\n      bigint res = *this;\n      res *= v;\n      return res;\n    }\n   \n    friend pair<bigint, bigint> divmod(const bigint &a1, const bigint &b1) {\n      int norm = base / (b1.z.back() + 1);\n      bigint a = a1.abs() * norm;\n      bigint b = b1.abs() * norm;\n      bigint q, r;\n      q.z.resize(a.z.size());\n      for (int i = a.z.size() - 1; i >= 0; i--) {\n        r *= base;\n        r += a.z[i];\n        int s1 = b.z.size() < r.z.size() ? r.z[b.z.size()] : 0;\n        int s2 = b.z.size() - 1 < r.z.size() ? r.z[b.z.size() - 1] : 0;\n        int d = (int) (((long long) s1 * base + s2) / b.z.back());\n        r -= b * d;\n        while (r < 0) {\n          r += b, --d;\n        }\n        q.z[i] = d;\n      }\n      q.sign = a1.sign * b1.sign;\n      r.sign = a1.sign;\n      q.trim();\n      r.trim();\n      return make_pair(q, r / norm);\n    }\n   \n    friend bigint sqrt(const bigint &a1) {\n      bigint a = a1;\n      while (a.z.empty() || (int) a.z.size() % 2 == 1) {\n        a.z.push_back(0);\n      }\n      int n = a.z.size();\n      int firstDigit = (int) sqrt((long long) a.z[n - 1] * base + a.z[n - 2]);\n      int norm = base / (firstDigit + 1);\n      a *= norm;\n      a *= norm;\n      while (a.z.empty() || (int) a.z.size() % 2 == 1) {\n        a.z.push_back(0);\n      }\n      bigint r = (long long) a.z[n - 1] * base + a.z[n - 2];\n      firstDigit = (int) sqrt((long long) a.z[n - 1] * base + a.z[n - 2]);\n      int q = firstDigit;\n      bigint res;\n      for (int j = n / 2 - 1; j >= 0; j--) {\n        for (;; --q) {\n          bigint r1 =\n            (r - (res * 2 * base + q) * q) * base * base +\n            (j > 0 ? (long long) a.z[2 * j - 1] * base + a.z[2 * j - 2] : 0);\n          if (r1 >= 0) {\n            r = r1;\n            break;\n          }\n        }\n        res *= base;\n        res += q;\n        if (j > 0) {\n          int d1 = res.z.size() + 2 < r.z.size() ? r.z[res.z.size() + 2] : 0;\n          int d2 = res.z.size() + 1 < r.z.size() ? r.z[res.z.size() + 1] : 0;\n          int d3 = res.z.size() < r.z.size() ? r.z[res.z.size()] : 0;\n          q = (int) (((long long) d1 * base * base + (long long) d2 * base + d3) / (firstDigit * 2));\n        }\n      }\n      res.trim();\n      return res / norm;\n    }\n   \n    bigint operator/(const bigint &v) const {\n      return divmod(*this, v).first;\n    }\n   \n    bigint operator%(const bigint &v) const {\n      return divmod(*this, v).second;\n    }\n   \n    void operator/=(int v) {\n      if (v < 0) {\n        sign = -sign, v = -v;\n      }\n      for (int i = z.size() - 1, rem = 0; i >= 0; --i) {\n        long long cur = z[i] + (long long) rem * base;\n        z[i] = (int) (cur / v);\n        rem = (int) (cur % v);\n      }\n      trim();\n    }\n   \n    bigint operator/(int v) const {\n      bigint res = *this;\n      res /= v;\n      return res;\n    }\n   \n    int operator%(int v) const {\n      if (v < 0) {\n        v = -v;\n      }\n      int m = 0;\n      for (int i = z.size() - 1; i >= 0; --i) {\n        m = (int) (((long long) m * base + z[i]) % v);\n      }\n      return m * sign;\n    }\n   \n    void operator+=(const bigint &v) {\n      *this = *this + v;\n    }\n    void operator-=(const bigint &v) {\n      *this = *this - v;\n    }\n    void operator*=(const bigint &v) {\n      *this = *this * v;\n    }\n    void operator/=(const bigint &v) {\n      *this = *this / v;\n    }\n   \n    bool operator<(const bigint &v) const {\n      if (sign != v.sign) {\n        return sign < v.sign;\n      }\n      if (z.size() != v.z.size()) {\n        return z.size() * sign < v.z.size() * v.sign;\n      }\n      for (int i = z.size() - 1; i >= 0; i--) {\n        if (z[i] != v.z[i]) {\n          return z[i] * sign < v.z[i] * sign;\n        }\n      }\n      return false;\n    }\n   \n    bool operator>(const bigint &v) const {\n      return v < *this;\n    }\n    bool operator<=(const bigint &v) const {\n      return !(v < *this);\n    }\n    bool operator>=(const bigint &v) const {\n      return !(*this < v);\n    }\n    bool operator==(const bigint &v) const {\n      return !(*this < v) && !(v < *this);\n    }\n    bool operator!=(const bigint &v) const {\n      return *this < v || v < *this;\n    }\n   \n    void trim() {\n      while (!z.empty() && z.back() == 0) {\n        z.pop_back();\n      }\n      if (z.empty()) {\n        sign = 1;\n      }\n    }\n   \n    bool isZero() const {\n      return z.empty() || ((int) z.size() == 1 && !z[0]);\n    }\n   \n    bigint operator-() const {\n      bigint res = *this;\n      res.sign = -sign;\n      return res;\n    }\n   \n    bigint abs() const {\n      bigint res = *this;\n      res.sign *= res.sign;\n      return res;\n    }\n   \n    long long longValue() const {\n      long long res = 0;\n      for (int i = z.size() - 1; i >= 0; i--) {\n        res = res * base + z[i];\n      }\n      return res * sign;\n    }\n   \n    friend bigint gcd(const bigint &a, const bigint &b) {\n      return b.isZero() ? a : gcd(b, a % b);\n    }\n    friend bigint lcm(const bigint &a, const bigint &b) {\n      return a / gcd(a, b) * b;\n    }\n   \n    void read(const string &s) {\n      sign = 1;\n      z.clear();\n      int pos = 0;\n      while (pos < (int) s.size() && (s[pos] == '-' || s[pos] == '+')) {\n        if (s[pos] == '-') {\n          sign = -sign;\n        }\n        ++pos;\n      }\n      for (int i = s.size() - 1; i >= pos; i -= base_digits) {\n        int x = 0;\n        for (int j = max(pos, i - base_digits + 1); j <= i; j++) {\n          x = x * 10 + s[j] - '0';\n        }\n        z.push_back(x);\n      }\n      trim();\n    }\n   \n    friend istream &operator>>(istream &stream, bigint &v) {\n      string s;\n      stream >> s;\n      v.read(s);\n      return stream;\n    }\n   \n    friend ostream &operator<<(ostream &stream, const bigint &v) {\n      if (v.sign == -1) {\n        stream << '-';\n      }\n      stream << (v.z.empty() ? 0 : v.z.back());\n      for (int i = v.z.size() - 2; i >= 0; --i) {\n        stream << setw(base_digits) << setfill('0') << v.z[i];\n      }\n      return stream;\n    }\n   \n    static vector<int> convert_base(const vector<int> &a, int old_digits, int new_digits) {\n      vector<long long> p(max(old_digits, new_digits) + 1);\n      p[0] = 1;\n      for (int i = 1; i < (int) p.size(); i++) {\n        p[i] = p[i - 1] * 10;\n      }\n      vector<int> res;\n      long long cur = 0;\n      int cur_digits = 0;\n      for (int i = 0; i < (int) a.size(); i++) {\n        cur += a[i] * p[cur_digits];\n        cur_digits += old_digits;\n        while (cur_digits >= new_digits) {\n          res.push_back((int) (cur % p[new_digits]));\n          cur /= p[new_digits];\n          cur_digits -= new_digits;\n        }\n      }\n      res.push_back((int) cur);\n      while (!res.empty() && res.back() == 0) {\n        res.pop_back();\n      }\n      return res;\n    }\n   \n    typedef vector<long long> vll;\n   \n    static vll karatsubaMultiply(const vll &a, const vll &b) {\n      int n = a.size();\n      vll res(n + n);\n      if (n <= 32) {\n        for (int i = 0; i < n; i++) {\n          for (int j = 0; j < n; j++) {\n            res[i + j] += a[i] * b[j];\n          }\n        }\n        return res;\n      }\n      int k = n >> 1;\n      vll a1(a.begin(), a.begin() + k);\n      vll a2(a.begin() + k, a.end());\n      vll b1(b.begin(), b.begin() + k);\n      vll b2(b.begin() + k, b.end());\n      vll a1b1 = karatsubaMultiply(a1, b1);\n      vll a2b2 = karatsubaMultiply(a2, b2);\n      for (int i = 0; i < k; i++) {\n        a2[i] += a1[i];\n      }\n      for (int i = 0; i < k; i++) {\n        b2[i] += b1[i];\n      }\n      vll r = karatsubaMultiply(a2, b2);\n      for (int i = 0; i < (int) a1b1.size(); i++) {\n        r[i] -= a1b1[i];\n      }\n      for (int i = 0; i < (int) a2b2.size(); i++) {\n        r[i] -= a2b2[i];\n      }\n      for (int i = 0; i < (int) r.size(); i++) {\n        res[i + k] += r[i];\n      }\n      for (int i = 0; i < (int) a1b1.size(); i++) {\n        res[i] += a1b1[i];\n      }\n      for (int i = 0; i < (int) a2b2.size(); i++) {\n        res[i + n] += a2b2[i];\n      }\n      return res;\n    }\n   \n    bigint operator*(const bigint &v) const {\n      vector<int> a6 = convert_base(this->z, base_digits, 6);\n      vector<int> b6 = convert_base(v.z, base_digits, 6);\n      vll a(a6.begin(), a6.end());\n      vll b(b6.begin(), b6.end());\n      while (a.size() < b.size()) {\n        a.push_back(0);\n      }\n      while (b.size() < a.size()) {\n        b.push_back(0);\n      }\n      while (a.size() & (a.size() - 1)) {\n        a.push_back(0);\n        b.push_back(0);\n      }\n      vll c = karatsubaMultiply(a, b);\n      bigint res;\n      res.sign = sign * v.sign;\n      for (int i = 0, carry = 0; i < (int) c.size(); i++) {\n        long long cur = c[i] + carry;\n        res.z.push_back((int) (cur % 1000000));\n        carry = (int) (cur / 1000000);\n      }\n      res.z = convert_base(res.z, 6, base_digits);\n      res.trim();\n      return res;\n    }\n  };\n} \nusing big = BigInteger::bigint;\n
bridge=// import dfs_undigraph first\n\ntemplate <typename T>\nvector<bool> find_bridges(dfs_undigraph<T> &g) {\n  g.dfs_all();\n  vector<bool> bridge(g.edges.size(), false);\n  for (int i = 0; i < g.n; i++) {\n    if (g.pv[i] != -1 && g.min_depth[i] == g.depth[i]) {\n      bridge[g.pe[i]] = true;\n    }\n  }\n  return bridge;\n}\n\n\ntemplate <typename T>\nvector <int> bridge(const undigraph <T> &g) {\n  vector <bool> seen(g.n, false);\n  vector <int> low(g.n, 0);\n  vector <int> dis(g.n, 0);\n  vector <int> pv(g.n, -1);\n  int timer = 0;\n  vector <int> ans;\n  function <void(int)> dfs = [&](int u) {\n    seen[u] = true;\n    dis[u] = low[u] = ++timer;\n    for (int id : g.g[u]) {\n      int v = g.edges[id].from ^ g.edges[id].to ^ u;\n      if (!seen[v]) {\n        pv[v] = u;\n        dfs(v);\n        low[u] = min(low[u], low[v]);\n        if (low[v] > dis[u]) {\n          ans.push_back(id);\n        }\n      } else if (v != pv[u]) {\n        low[u] = min(low[u], dis[v]);\n      }\n    }\n  };\n  dfs(0);\n  return ans;\n  // return edge id's of bridges\n} \n
calendar=vector <string> week = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};\nvector <string> month = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};\nvector <int> day = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\nbool leap(int year) {\n  if (((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0)) {\n    return true;\n  }\n  return false; \n}\n
can_palindrome=bool can_palindrome(const string &str, int n) {\n  vector <int> fre(26, 0);\n  for (int i = 0; i < n; i++) {\n    fre[str[i] - 'a']++;\n  }\n  pair <char, int> odd = {'0', 0};\n  for (int i = 0; i < 26; i++) {\n    if (fre[i] > 0) {\n      if (fre[i] % 2 == 1) {\n        if (odd.second == 0) {\n          odd.second = 1;\n          odd.first = (char)(i + 'a');\n        } else {\n          return false;\n        } \n      }\n    } \n  }\n  if (odd.second == 1) {\n    if (n % 2 == 0) return false; \n  } \n  return true;\n}\n
catalan=const int N = 100;\nvector <long long> dp(N + 1);\nauto calc = [&] () {\n  dp[0] = dp[1] = 1;\n  for (int i = 2; i <= N; i++) { \n    dp[i] = 0; \n    for (int j = 0; j < i; j++) {\n      dp[i] += dp[j] * dp[i - j - 1]; \n    }\n  }\n};\ncalc();\n
chmax=template <typename T> \ninline bool chmax(T &a, const T &b) {\n  return a < b ? a = b, true : false;\n}\n
chmin=template <typename T> \ninline bool chmin(T &a, const T &b) {\n  return a > b ? a = b, true : false;\n}\n
clock=  #ifdef LOCAL\n    fprintf(stderr, "Time elapsed: %.12lf secs...\n", tick());\n  #endif\n
closest=template <typename T>\nT closest(vector <T>& arr, T x) {\n  int n = arr.size();\n  int l = 0;\n  int h = n - 1;\n  int L = l, H = h;\n  while (l <= h) {\n    int mid = (l + h) / 2;\n    if (x <= arr[mid]) {\n      H = mid;\n      h = mid - 1;\n    } else {\n      l = mid + 1;\n      L = mid;\n    }\n  }\n  if (abs(arr[H] - x) <= abs(arr[L] - x)) return arr[H];\n  return arr[L];\n  //returns closest val to x in arr\n}\n
comb=template <typename T>\nclass combination {\n public:\n  vector <T> fact;\n  vector <T> inv_fact;\n  combination(int N) : fact(N + 1), inv_fact(N + 1) {\n    assert(N < mod);\n    fact[0] = 1;\n    for (int i = 1; i <= N; i++) {\n      fact[i] = fact[i - 1] * i;\n    }\n    inv_fact[N] = T(1) / fact[N];\n    for (int i = N - 1; i >= 0; i--) {\n      inv_fact[i] = inv_fact[i + 1] * (i + 1);\n    }\n  } \n  T P(int n, int r) const {\n    if (r < 0 || n < r) return 0;\n    return fact[n] * inv_fact[n - r];\n  }\n \n  T C(int n, int r) const {\n    if (r < 0 || n < r) return 0;\n    return fact[n] * inv_fact[r] * inv_fact[n - r];\n  }\n};\n\nconst int N = (int) (1e6 + 1);\ncombination <mint> co(N);\ninline mint C(int n, int r) { return co.C(n, r); }\ninline mint P(int n, int r) { return co.P(n, r); }\n
combination=template <typename T>\nclass combination {\n public:\n  vector <T> fact;\n  vector <T> inv_fact;\n  combination(int N) : fact(N + 1), inv_fact(N + 1) {\n    assert(N < mod);\n    fact[0] = 1;\n    for (int i = 1; i <= N; i++) {\n      fact[i] = fact[i - 1] * i;\n    }\n    inv_fact[N] = T(1) / fact[N];\n    for (int i = N - 1; i >= 0; i--) {\n      inv_fact[i] = inv_fact[i + 1] * (i + 1);\n    }\n  } \n  T P(int n, int r) const {\n    if (r < 0 || n < r) return 0;\n    return fact[n] * inv_fact[n - r];\n  }\n \n  T C(int n, int r) const {\n    if (r < 0 || n < r) return 0;\n    return fact[n] * inv_fact[r] * inv_fact[n - r];\n  }\n};\n\nconst int N = (int) (1e6 + 1);\ncombination <mint> co(N);\ninline mint C(int n, int r) { return co.C(n, r); }\ninline mint P(int n, int r) { return co.P(n, r); }\n
comp=template <typename T>\nstruct large {\n  bool operator()(const T &a, const T &b) const {\n    return (!(a < b) && !(!(a < b) && !(b < a)));\n  } \n};\n\ntemplate <typename T>\nstruct small {\n  bool operator()(const T &a, const T &b) const {\n    return a < b;\n  } \n};\n\ntemplate <typename T>\nstruct same {\n  bool operator()(const T &a, const T &b) const {\n    return (!(a < b) && !(b < a));\n  } \n};\n
crt=//..solve for x, given x = ai (mod mi), all mi are mutually co-prime\n/*\n//..Mine\nint crt(vector <int> &a, vector <int> &m) {\n  int t = a.size();\n  int M = 1, x = 0;\n  for (int i = 0; i < t; i++) M *= m[i];\n  for (int i = 0; i < t; i++) {\n    int n = M / m[i];\n    int u = modi(n % m[i], m[i]);\n    x += n * u * a[i];\n  }\n  x %= M;\n  if (x < 0) x += M;\n  return x;\n}\n*/\n\ntemplate <typename T>\nvoid crt(const vector<int>& p, const vector<int>& a, T& res) {\n  assert(p.size() == a.size());\n  auto inverse = [&](int q, int m) {\n    q %= m;\n    if (q < 0) q += m;\n    int b = m, u = 0, v = 1;\n    while (q) {\n      int t = b / q;\n      b -= t * q; swap(q, b);\n      u -= t * v; swap(u, v);\n    }\n    assert(b == 1);\n    if (u < 0) u += m;\n    return u;\n  };\n  vector<int> x(p.size());\n  for (int i = 0; i < (int) p.size(); i++) {\n    assert(0 <= a[i] && a[i] < p[i]);\n    x[i] = a[i];\n    for (int j = 0; j < i; j++) {\n      x[i] = (int) ((long long) (x[i] - x[j]) * inverse(p[j], p[i]) % p[i]);\n      if (x[i] < 0) x[i] += p[i];\n    }\n  }\n  res = 0;\n  for (int i = (int) p.size() - 1; i >= 0; i--) {\n    res = res * p[i] + x[i];\n  }\n}\n
cum=template <typename T, typename U>\nclass cum {\n public:\n  int n, m;\n  vector <vector <T> > mat;\n  cum(vector <vector <U> > &_mat) {\n    n = _mat.size();\n    m = _mat[0].size();\n    mat = vector <vector <T> >(n + 1, vector <T>(m + 1, 0));\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        mat[i + 1][j + 1] = _mat[i][j];\n      } \n    } \n    for (int i = 1; i < n + 1; i++) {\n      for (int j = 1; j < m + 1; j++) {\n        mat[i][j] += mat[i - 1][j] + mat[i][j - 1] - mat[i - 1][j - 1];\n      } \n    }\n  }\n  T get(int x, int y) {\n    return get(0, 0, x, y);\n  } \n  T get(int p, int q, int r, int s) {\n    p += 1, q += 1, r += 1, s += 1;\n    return mat[r][s] - mat[r][q - 1] - mat[p - 1][s] + mat[p - 1][q - 1];\n  } \n};\n\ntemplate <typename T, typename U>\nclass cum {\n public:\n  int n;\n  vector <T> arr;\n  cum(vector <U> &_arr) {\n    n = _arr.size();\n    arr = vector <int>(n);\n    arr[0] = _arr[0];\n    for (int i = 1; i < n; i++) {\n      arr[i] = arr[i - 1] + _arr[i]; \n    } \n  }\n  T get(int x, int y) {\n    T H = arr[y];\n    T L = x - 1 >= 0 ? arr[x - 1] : 0;\n    return H - L;\n  } \n};\n
cycles=template <typename T>\nvector<vector<int>> find_cycles(const graph<T> &g, int bound_cnt = 1 << 30, int bound_size = 1 << 30) {\n  vector<int> was(g.n, -1);\n  vector<int> st;\n  vector<vector<int>> cycles;\n  int total_size = 0;\n  function<void(int, int)> dfs = [&](int v, int pe) {\n    if ((int) cycles.size() >= bound_cnt || total_size >= bound_size) {\n      return;\n    }\n    was[v] = (int) st.size();\n    for (int id : g.g[v]) {\n      if (id == pe) {\n        continue;\n      }\n      auto &e = g.edges[id];\n      int to = e.from ^ e.to ^ v;\n      if (was[to] >= 0) {\n        vector<int> cycle(1, id);\n        for (int j = was[to]; j < (int) st.size(); j++) {\n          cycle.push_back(st[j]);\n        }\n        cycles.push_back(cycle);\n        total_size += (int) cycle.size();\n        if ((int) cycles.size() >= bound_cnt || total_size >= bound_size) {\n          return;\n        }\n        continue;\n      }\n      if (was[to] == -1) {\n        st.push_back(id);\n        dfs(to, id);\n        st.pop_back();\n      }\n    }\n    was[v] = -2;\n  };\n  for (int i = 0; i < g.n; i++) {\n    if (was[i] == -1) {\n      dfs(i, -1);\n    }\n  }\n  return cycles;\n  // cycles are given by edge ids, all cycles are simple\n  // breaks after getting bound_cnt cycles or total_size >= bound_size\n  // digraph: finds at least one cycle in every connected component (if not broken)\n  // undigraph: finds cycle basis\n}\n \n
cyclic=template <typename T>\nbool cyclic(const digraph <T> &g) {\n  const int white = 1;\n  const int gray = 2;\n  const int black = 3;  \n  vector <int> col(g.n, white);\n\n  function <bool(int)> dfs = [&](int u) -> bool {\n    col[u] = gray;\n    bool found = false;\n    for (int id : g.g[u]) {\n      int v = g.edges[id].from ^ g.edges[id].to ^ u;\n      if (col[v] == gray) {\n        found = true;\n        goto end;\n      }\n      if (col[v] == white && dfs(v)) {\n        found = true;\n        goto end;\n      }\n    } \n    col[u] = black;\n    end : {\n      return found;\n    } \n  };\n  \n  bool found = false;\n  for (int u = 0; u < g.n; u++) {\n    if (col[u] == white) {\n      if (dfs(u)) {\n        found = true;\n        goto end;\n      }\n    }\n  }\n  end : {\n    return found;\n  } \n  //returns true if digraph is cyclic\n} \n
deb=template <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return "(" + to_string(p.first) + ", " + to_string(p.second) + ")";\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = "{";\n  for (const auto &x : v) {\n    if (!first) {\n      res += ", ";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += "}";\n  return res;\n}\n\nvoid debug_out() { cerr << endl; }\n \ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << " " << to_string(H);\n  debug_out(T...);\n}\n \n#ifdef LOCAL\n#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n
debug=template <typename A, typename B>\nstring to_string(pair<A, B> p);\n \ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n \ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n \nstring to_string(const string& s) {\n  return '"' + s + '"';\n}\n \nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n \nstring to_string(bool b) {\n  return (b ? "t" : "f");\n}\n\nstring to_string(const char &ch) {\n  return "'" + string(1, ch) + "'";\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = "{";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += ", ";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += "}";\n  return res;\n}\n \ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = "";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  reverse(res.begin(), res.end());\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = "{";\n  for (const auto &x : v) {\n    if (!first) {\n      res += ", ";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += "}";\n  return res;\n}\n \ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return "{" + to_string(p.first) + ", " + to_string(p.second) + "}";\n}\n \ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return "{" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + "}";\n}\n \ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return "{" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ", " + to_string(get<3>(p)) + "}";\n}\n\ntemplate <typename T> \nstring to_string(vector <vector<T>> &mat) {\n  string res = "";\n  char temp[32];\n  int n = mat.size();\n  if (n == 0) return res;\n  res += "\n";\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < (int) mat[i].size(); j++) {\n      sprintf(temp, "%-18s", to_string(mat[i][j]).c_str());\n      res += string(temp);\n    }\n    res += "\n";\n  }\n  return res;\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << " " << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n
debug_impl=template <typename A, typename B>\nstring to_string(pair<A, B> p);\n \ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n \ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n \nstring to_string(const string& s) {\n  return '"' + s + '"';\n}\n \nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n \nstring to_string(bool b) {\n  return (b ? "true" : "false");\n}\n\nstring to_string(const char &ch) {\n  return "'" + string(1, ch) + "'";\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = "{";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += ", ";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += "}";\n  return res;\n}\n \ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = "";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  reverse(res.begin(), res.end());\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = "{";\n  for (const auto &x : v) {\n    if (!first) {\n      res += ", ";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += "}";\n  return res;\n}\n \ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return "{" + to_string(p.first) + ", " + to_string(p.second) + "}";\n}\n \ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return "{" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + "}";\n}\n \ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return "{" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ", " + to_string(get<3>(p)) + "}";\n}\n\ntemplate <typename T> \nstring to_string(vector <vector<T>> &mat) {\n  string res = "";\n  char temp[32];\n  int n = mat.size();\n  if (n == 0) return res;\n  res += "\n";\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < (int) mat[i].size(); j++) {\n      sprintf(temp, "%-18s", to_string(mat[i][j]).c_str());\n      res += string(temp);\n    }\n    res += "\n";\n  }\n  return res;\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << " " << to_string(H);\n  debug_out(T...);\n}\n \n#ifdef LOCAL\n#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n
dfs=vector <bool> seen(g.n, false);\nfunction<void(int)> dfs = [&](int u) {\n  seen[u] = true;\n  for (int id : g.g[u]) {\n    int v = g.edges[id].from ^ g.edges[id].to ^ u;\n    if (!seen[v]) {\n      dfs(v);\n    }\n  }\n};\n//dfs(0);\n
dfs_forest=template <typename T>\nclass dfs_forest : public forest<T> {\n public:\n  using forest<T>::edges;\n  using forest<T>::g;\n  using forest<T>::n;\n \n  vector<int> pv;\n  vector<int> pe;\n  vector<int> order;\n  vector<int> pos;\n  vector<int> end;\n  vector<int> sz;\n  vector<int> root;\n  vector<int> depth;\n  vector<T> dist;\n  int timer;\n \n  dfs_forest(int _n) : forest<T>(_n) {\n  }\n \n  void init() {\n    pv = vector<int>(n, -1);\n    pe = vector<int>(n, -1);\n    order.clear();\n    pos = vector<int>(n, -1);\n    end = vector<int>(n, -1);\n    sz = vector<int>(n, 0);\n    root = vector<int>(n, -1);\n    depth = vector<int>(n, -1);\n    dist = vector<T>(n);\n  }\n \n  void clear() {\n    pv.clear();\n    pe.clear();\n    order.clear();\n    pos.clear();\n    end.clear();\n    sz.clear();\n    root.clear();\n    depth.clear();\n    dist.clear();\n  }\n \n private:\n  void do_dfs(int v) {\n    pos[v] = (int) order.size();\n    order.push_back(v);\n    sz[v] = 1;\n    for (int id : g[v]) {\n      if (id == pe[v]) {\n        continue;\n      }\n      auto &e = edges[id];\n      int to = e.from ^ e.to ^ v;\n      depth[to] = depth[v] + 1;\n      dist[to] = dist[v] + e.cost;\n      pv[to] = v;\n      pe[to] = id;\n      root[to] = (root[v] != -1 ? root[v] : to);\n      do_dfs(to);\n      sz[v] += sz[to];\n    }\n    end[v] = (int) order.size() - 1;\n  }\n \n  void do_dfs_from(int v) {\n    depth[v] = 0;\n    dist[v] = T{};\n    root[v] = v;\n    pv[v] = pe[v] = -1;\n    do_dfs(v);\n  }\n \n public: \n  void dfs(int v, bool clear_order = true) {\n    if (pv.empty()) {\n      init();\n    } else {\n      if (clear_order) {\n        order.clear();\n      }\n    }\n    do_dfs_from(v);\n  }\n \n  void dfs_all() {\n    init();\n    for (int v = 0; v < n; v++) {\n      if (depth[v] == -1) {\n        do_dfs_from(v);\n      }\n    }\n    assert((int) order.size() == n);\n  }\n};\n
dfs_toposort=//..verified against AOJ GRL_4_B\nconst int N = 100001;\nvector <bool> visited(N);\n\nclass Graph {\nprivate:\n  int V;\n  int E;\n  vector <vector <int>> adj;\n  void dfsUtil(int u, stack <int> &st);\npublic:\n  Graph(int n, int m);\n  void addEdge(int s, int t);\n  void topologicalSort();\n};\n\nGraph::Graph(int n, int m) {\n  this->V = n;\n  this->E = m;\n  adj.resize(n);\n}\n\nvoid Graph::addEdge(int s, int t) {\n  adj[s].push_back(t);\n}\n\nvoid Graph::dfsUtil(int u, stack <int> &st) {\n  visited[u] = true;\n  for (int i = 0; i < (int) adj[u].size(); i++) {\n    int v = adj[u][i];\n    if (!visited[v]) {\n      dfsUtil(v, st);\n    }\n  }\n  st.push(u);\n}\n\nvoid Graph::topologicalSort() {\n  fill(visited.begin(), visited.begin() + V, false);\n  stack <int> st;\n  for (int u = 0; u < V; u++) {\n    if (!visited[u]) {\n      dfsUtil(u, st);\n    }\n  }\n\n  //..printing topo order\n  while (!st.empty()) {\n    int u = st.top();\n    st.pop();\n    cout << u << endl;\n  }\n}\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  Graph g(n, m);\n  int s, t;\n  for (int i = 0; i < m; i++) {\n    cin >> s >> t;\n    g.addEdge(s, t);\n  } \n  g.topologicalSort();\n  return 0;\n} \n
dfs_undigraph=template <typename T>\nclass dfs_undigraph : public undigraph<T> {\n public:\n  using undigraph<T>::edges;\n  using undigraph<T>::g;\n  using undigraph<T>::n;\n \n  vector<int> pv;\n  vector<int> pe;\n  vector<int> order;\n  vector<int> pos;\n  vector<int> end;\n  vector<int> sz;\n  vector<int> root;\n  vector<int> depth;\n  vector<int> min_depth;\n  vector<T> dist;\n  vector<int> was;\n  int attempt;\n \n  dfs_undigraph(int _n) : undigraph<T>(_n) {\n  }\n \n  void init() {\n    pv = vector<int>(n, -1);\n    pe = vector<int>(n, -1);\n    order.clear();\n    pos = vector<int>(n, -1);\n    end = vector<int>(n, -1);\n    sz = vector<int>(n, 0);\n    root = vector<int>(n, -1);\n    depth = vector<int>(n, -1);\n    min_depth = vector<int>(n, -1);\n    dist = vector<T>(n);\n    was = vector<int>(n, -1);\n    attempt = 0;\n  }\n \n  void clear() {\n    pv.clear();\n    pe.clear();\n    order.clear();\n    pos.clear();\n    end.clear();\n    sz.clear();\n    root.clear();\n    depth.clear();\n    min_depth.clear();\n    dist.clear();\n    was.clear();\n  }\n \n private:\n  void do_dfs(int v) {\n    was[v] = attempt;\n    pos[v] = (int) order.size();\n    order.push_back(v);\n    sz[v] = 1;\n    min_depth[v] = depth[v];\n    for (int id : g[v]) {\n      if (id == pe[v]) {\n        continue;\n      }\n      auto &e = edges[id];\n      int to = e.from ^ e.to ^ v;\n      if (was[to] == attempt) {\n        min_depth[v] = min(min_depth[v], depth[to]);\n        continue;\n      }\n      depth[to] = depth[v] + 1;\n      dist[to] = dist[v] + e.cost;\n      pv[to] = v;\n      pe[to] = id;\n      root[to] = (root[v] != -1 ? root[v] : to);\n      do_dfs(to);\n      sz[v] += sz[to];\n      min_depth[v] = min(min_depth[v], min_depth[to]);\n    }\n    end[v] = (int) order.size() - 1;\n  }\n \n  void do_dfs_from(int v) {\n    ++attempt;\n    depth[v] = 0;\n    dist[v] = T{};\n    root[v] = v;\n    pv[v] = pe[v] = -1;\n    do_dfs(v);\n  }\n \n public:\n  void dfs(int v, bool clear_order = true) {\n    if (pv.empty()) {\n      init();\n    } else {\n      if (clear_order) {\n        order.clear();\n      }\n    }\n    do_dfs_from(v);\n  }\n \n  void dfs_all() {\n    init();\n    for (int v = 0; v < n; v++) {\n      if (depth[v] == -1) {\n        do_dfs_from(v);\n      }\n    }\n    assert((int) order.size() == n);\n  }\n};\n
diameter=template <typename T>\nT diameter(const forest <T> &g) {\n  vector <bool> seen(g.n, false);\n  vector <T> depth(g.n, -1);\n\n  function <void(int)> dfs = [&](int u) {\n    seen[u] = true;\n    for (int id : g.g[u]) {\n      auto &e = g.edges[id];\n      int v = e.from ^ e.to ^ u;\n      if (!seen[v]) {\n        depth[v] = depth[u] + e.cost;\n        dfs(v);\n      }\n    }\n  };\n\n  depth[0] = 0;\n  dfs(0);\n\n  T max_depth = numeric_limits<T>::min();\n  int from = 0;\n  for (int u = 0; u < g.n; u++) {\n    if (depth[u] > max_depth) {\n      max_depth = depth[u];\n      from = u;\n    }\n  }\n  \n  //reset\n  seen = vector <bool> (g.n, false);\n  depth = vector <int> (g.n, -1);\n  depth[from] = 0;\n  dfs(from);\n\n  T ans = numeric_limits<T>::min();\n  for (int u = 0; u < g.n; u++) {\n    ans = max(ans, depth[u]);\n  }\n  return ans;\n  // returns length of diameter\n} \n
digraph=template <typename T>\nclass digraph : public graph<T> {\n public:\n  using graph<T>::edges;\n  using graph<T>::g;\n  using graph<T>::n;\n \n  digraph(int _n) : graph<T>(_n) {\n  }\n \n  int add(int from, int to, T cost = 1) {\n    assert(0 <= from && from < n && 0 <= to && to < n);\n    int id = (int) edges.size();\n    g[from].push_back(id);\n    edges.push_back({from, to, cost});\n    return id;\n  }\n \n  digraph<T> reverse() const {\n    digraph<T> rev(n);\n    for (auto &e : edges) {\n      rev.add(e.to, e.from, e.cost);\n    }\n    return rev;\n  }\n};\n
dijkstra=/*\n//..Mine\nusing priority_queue : dijkstra_pq\nusing set : dijkstra_st\n*/\ntemplate <typename T>\nvector <T> dijkstra(const graph<T> &g, int start) {\n  assert(0 <= start && start < g.n);\n  vector<T> dist(g.n, numeric_limits<T>::max());\n  priority_queue<pair<T, int>, vector<pair<T, int> >, greater<pair<T, int> > > s;\n  dist[start] = 0;\n  s.emplace(dist[start], start);\n  while (!s.empty()) {\n    T expected = s.top().first;\n    int i = s.top().second;\n    s.pop();\n    if (dist[i] != expected) {\n      continue;\n    }\n    for (int id : g.g[i]) {\n      auto &e = g.edges[id];\n      int to = e.from ^ e.to ^ i;\n      if (dist[i] + e.cost < dist[to]) {\n        dist[to] = dist[i] + e.cost;\n        s.emplace(dist[to], to);\n      }\n    }\n  }\n  return dist;\n  // returns numeric_limits<T>::max() if there's no path\n}\n \n
dijkstra_pq=//verified against interviewbit knight problem and AOJ GRL_1_A\nstruct Edge {\n  int dst;\n  int wgt;\n  Edge(int idst, int iwgt) : dst(idst), wgt(iwgt) {};\n};\n\nclass Graph {\nprivate:\n  int V;\n  int E;\n  vector <vector <Edge>> adj;\npublic:\n  Graph(int n, int m);\n  void addEdge(int src, int dst, int wgt);\n  void dijkstra(int src);\n};\n\nGraph::Graph(int n, int m) {\n  this->V = n;\n  this->E = m;\n  adj.resize(n);\n}\n\nvoid Graph::addEdge(int src, int dst, int wgt) {\n  adj[src].push_back(Edge(dst, wgt));\n}\n\nvoid Graph::dijkstra(int src) {\n  vector <int> dist(V, pinf);\n  priority_queue <pair <int, int>, vector <pair <int, int>>, greater<pair <int, int>>> pq;\n  dist[src] = 0;\n  pq.emplace(0, src);\n  while (!pq.empty()) {\n    pair <int, int> pr = pq.top(); pq.pop();\n    int u = pr.second;\n    for (Edge &edge : adj[u]) {\n      int v = edge.dst;\n      int w = edge.wgt;\n      if (dist[u] + w < dist[v]) {\n        dist[v] = dist[u] + w;\n        pq.emplace(dist[v], v);\n      } \n    } \n  } \n\n  for (int i = 0; i < V; i++) {\n    if (dist[i] == pinf) cout << "INF" << endl;\n    else cout << dist[i] << endl;\n  } \n} \n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m, src;\n  cin >> n >> m >> src;\n  Graph g(n, m);\n  int s, t, w;\n  for (int i = 0; i < m; i++) {\n    cin >> s >> t >> w;\n    g.addEdge(s, t, w);\n  }\n  g.dijkstra(src);\n  return 0;\n}\n
dijkstra_st=//verified against interviewbit knight problem and AOJ GRL_1_A\nstruct Edge {\n  int dst;\n  int wgt;\n  Edge(int idst, int iwgt) : dst(idst), wgt(iwgt) {};\n};\n\nclass Graph {\nprivate:\n  int V;\n  int E;\n  vector <vector <Edge>> adj;\npublic:\n  Graph(int n, int m);\n  void addEdge(int src, int dst, int wgt);\n  void dijkstra(int src);\n};\n\nGraph::Graph(int n, int m) {\n  this->V = n;\n  this->E = m;\n  adj.resize(n);\n}\n\nvoid Graph::addEdge(int src, int dst, int wgt) {\n  adj[src].push_back(Edge(dst, wgt));\n}\n\nvoid Graph::dijkstra(int src) {\n  set <pair <int, int>> st;\n  vector <int> dist(V, pinf);\n  dist[src] = 0;\n  st.emplace(dist[src], src);\n\n  while (!st.empty()) {\n    pair <int, int> pr = *(st.begin());\n    st.erase(st.begin());\n    int u = pr.second;\n\n    for (Edge &edge : adj[u]) {\n      int v = edge.dst;\n      int w = edge.wgt;\n\n      if (dist[u] + w < dist[v]) {\n        if (dist[v] != pinf) {\n          st.erase(st.find(make_pair(dist[v], v)));\n        }\n        dist[v] = w + dist[u];\n        st.emplace(dist[v], v);\n      }\n    }\n  }\n\n  \n  //..printing distances from source\n  for (int i = 0; i < V; i++) {\n    if (dist[i] == pinf) {\n      cout << "INF" << endl;\n    } else {\n      cout << dist[i] << endl;\n    }\n  }\n}\n\nint main() {\n  int n, m, src;\n  cin >> n >> m >> src;\n  Graph g(n, m);\n  int s, t, w;\n  for (int i = 0; i < m; i++) {\n    cin >> s >> t >> w;\n    g.addEdge(s, t, w);\n  }\n  g.dijkstra(src);\n  return 0;\n}\n
dinic=//verifed against AOJ GRL_6_A \nconst int maxnodes = 101;\n\nvector <int> start(maxnodes);\n\nstruct Edge {\n  int to, rev;\n  int flow, cap;\n};\n\nclass Graph {\nprivate:\n  int V;\n  vector <int> level;\n  vector <vector <Edge>> adj;\n  bool dinic_bfs(int s, int t);\n  int dinic_dfs(int s, int t, int flow);\npublic:\n  Graph(int n);\n  void addEdge(int src, int dst, int cap);\n  int maxFlow(int s, int t);\n};\n\nGraph::Graph(int n) {\n  adj.resize(n);\n  level.resize(n);\n  this->V = n;\n}\n\nvoid Graph::addEdge(int src, int dst, int cap) {\n  Edge a = {dst, (int) adj[dst].size(), 0, cap};\n  Edge b = {src, (int) adj[src].size(), 0, 0};\n  adj[src].push_back(a);\n  adj[dst].push_back(b);  \n}\n\nbool Graph::dinic_bfs(int s, int t) {\n  fill(level.begin(), level.end(), -1);\n  level[s] = 0;\n  queue <int> q;\n  q.push(s);\n\n  while (!q.empty()) {\n    int u = q.front();\n    q.pop();\n    for (int j = 0; j < (int) adj[u].size(); j++) {\n      Edge &e = adj[u][j];\n      int v = e.to;\n      if (level[v] < 0 && e.flow < e.cap) {\n        level[v] = level[u] + 1;\n        q.push(v);\n      }\n    }\n  }\n  return level[t] >= 0;\n}\n\nint Graph::dinic_dfs(int u, int t, int flow) {\n  if (u == t) {\n    return flow;\n  }\n  for (; start[u] < (int) adj[u].size(); start[u]++) {\n    Edge &e = adj[u][start[u]]; \n    int v = e.to;\n    if (level[v] == level[u] + 1 && e.flow < e.cap) {\n      int flow_ahead = dinic_dfs(v, t, min(flow, e.cap - e.flow));\n      if (flow_ahead > 0) {\n        e.flow += flow_ahead;\n        adj[v][e.rev].flow -= flow_ahead;\n        return flow_ahead;\n      }\n    }\n  }\n  return 0;\n}\n\nint Graph::maxFlow(int s, int t) {\n  int result = 0;\n  while (dinic_bfs(s, t)) {\n    fill(start.begin(), start.begin() + V, 0);\n    while (int delta = dinic_dfs(s, t, INT_MAX)) {\n      result += delta;\n    }\n  }\n  return result;\n}\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  Graph g(n);\n  int s, d, c;\n  for (int i = 0; i < m; i++) {\n    cin >> s >> d >> c;\n    g.addEdge(s, d, c);\n  }\n  cout << g.maxFlow(0, n - 1) << endl;\n}\n\n\n// Tourist's\ntemplate <typename T>\nclass dinic {\n public:\n  flow_graph<T> &g;\n\n  vector<int> ptr;\n  vector<int> d;\n  vector<int> q;\n\n  dinic(flow_graph<T> &_g) : g(_g) {\n    ptr.resize(g.n);\n    d.resize(g.n);\n    q.resize(g.n);\n  }\n\n  bool expath() {\n    fill(d.begin(), d.end(), -1);\n    q[0] = g.fin;\n    d[g.fin] = 0;\n    int beg = 0, end = 1;\n    while (beg < end) {\n      int i = q[beg++];\n      for (int id : g.g[i]) {\n        const auto &e = g.edges[id];\n        const auto &back = g.edges[id ^ 1];\n        if (back.c - back.f > g.eps && d[e.to] == -1) {\n          d[e.to] = d[i] + 1;\n          if (e.to == g.st) {\n            return true;\n          }\n          q[end++] = e.to;\n        }\n      }\n    }\n    return false;\n  }\n   \n  T dfs(int v, T w) {\n    if (v == g.fin) {\n      return w;\n    }\n    int &j = ptr[v];\n    while (j >= 0) {\n      int id = g.g[v][j];\n      const auto &e = g.edges[id];\n      if (e.c - e.f > g.eps && d[e.to] == d[v] - 1) {\n        T t = dfs(e.to, min(e.c - e.f, w));\n        if (t > g.eps) {\n          g.edges[id].f += t;\n          g.edges[id ^ 1].f -= t;\n          return t;\n        }\n      }\n      j--;\n    }\n    return 0;\n  }\n\n  T max_flow() {\n    while (expath()) {\n      for (int i = 0; i < g.n; i++) {\n        ptr[i] = (int) g.g[i].size() - 1;\n      }\n      T big_add = 0;\n      while (true) {\n        T add = dfs(g.st, numeric_limits<T>::max());\n        if (add <= g.eps) {\n          break;\n        }\n        big_add += add;\n      }\n      if (big_add <= g.eps) {\n        break;\n      }\n      g.flow += big_add;\n    }\n    return g.flow;\n  }\n\n  vector<bool> min_cut() {\n    max_flow();\n    vector<bool> ret(g.n);\n    for (int i = 0; i < g.n; i++) {\n      ret[i] = (d[i] != -1);\n    }\n    return ret;\n  }\n};\n
diophantine=int gcd(int a, int b, int &x, int &y) {\n  if (a == 0) {\n    x = 0; y = 1;\n    return b;\n  }\n  int x1, y1;\n  int d = gcd(b%a, a, x1, y1);\n  x = y1 - (b / a) * x1;\n  y = x1;\n  return d;\n}\n\nbool find_any_solution(int a, int b, int c, int &x0, int &y0, int &g) {\n  g = gcd(abs(a), abs(b), x0, y0);\n  if (c % g) {\n    return false;\n  }\n\n  x0 *= c / g;\n  y0 *= c / g;\n  if (a < 0) x0 = -x0;\n  if (b < 0) y0 = -y0;\n  return true;\n}\n
dominators=template <typename T>\nvector<int> dominators(digraph<T> &g, int root) {\n  int n = g.n;\n  vector<int> pos(n, -1);\n  vector<int> order;\n  vector<int> parent(n, -1);\n  function<void(int)> dfs = [&](int v) {\n    pos[v] = (int) order.size();\n    order.push_back(v);\n    for (int id : g.g[v]) {\n      if (g.ignore != nullptr && g.ignore(id)) {\n        continue;\n      }\n      auto &e = g.edges[id];\n      int u = e.to;\n      if (pos[u] == -1) {\n        parent[u] = v;\n        dfs(u);\n      }\n    }\n  };\n  dfs(root);\n  vector<int> p(n), best(n);\n  iota(p.begin(), p.end(), 0);\n  iota(best.begin(), best.end(), 0);\n  vector<int> sdom = pos;\n  function<int(int)> find_best = [&](int x) {\n    if (p[x] != x) {\n      int u = find_best(p[x]);\n      if (sdom[u] < sdom[best[x]]) {\n        best[x] = u;\n      }\n      p[x] = p[p[x]];\n    }\n    if (sdom[best[p[x]]] < sdom[best[x]]) {\n      best[x] = best[p[x]];\n    }\n    return best[x];\n  };\n  digraph<int> g_rev = g.reverse();\n  vector<int> idom(n, -1);\n  vector<int> link(n, 0);\n  vector< vector<int> > bucket(n);\n  for (int it = (int) order.size() - 1; it >= 0; it--) {\n    int w = order[it];\n    for (int id : g_rev.g[w]) {\n      if (g_rev.ignore != nullptr && g_rev.ignore(id)) {\n        continue;\n      }\n      auto &e = g_rev.edges[id];\n      int u = e.to;\n      sdom[w] = min(sdom[w], sdom[find_best(u)]);\n    }\n    idom[w] = order[sdom[w]];\n    for (int u : bucket[w]) {\n      link[u] = find_best(u);\n    }\n    for (int id : g.g[w]) {\n      if (g.ignore != nullptr && g.ignore(id)) {\n        continue;\n      }\n      auto &e = g.edges[id];\n      int u = e.to;\n      if (parent[u] == w) {\n        p[u] = w;\n      }\n    }\n    bucket[order[sdom[w]]].push_back(w);\n  }\n  for (int it = 1; it < (int) order.size(); it++) {\n    int w = order[it];\n    idom[w] = idom[link[w]];\n  }\n  return idom;\n  // idom[i] -- immediate dominator for vertex i\n}\n \n
dsu=class dsu {\n public:\n  vector<int> p;\n  int n;\n \n  dsu(int _n) : n(_n) {\n    p.resize(n);\n    iota(p.begin(), p.end(), 0);\n  }\n \n  inline int get(int x) {\n    return (x == p[x] ? x : (p[x] = get(p[x])));\n  }\n \n  inline bool unite(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x != y) {\n      p[x] = y;\n      return true;\n    }\n    return false;\n  }\n};\n\n//compressed path\nclass dsu {\n public:\n  vector <int> p;\n  vector <int> r;\n  dsu(int n) {\n    p.resize(n);\n    r.resize(n);\n    iota(p.begin(), p.end(), 0);\n    fill(r.begin(), r.end(), 0);\n  } \n\n  inline int get(int x) {\n    if (x == p[x]) {\n      return x;\n    }\n    return p[x] = get(p[x]);\n  }\n\n  inline bool unite(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x != y) {\n      if (r[x] < r[y]) {\n        swap(x, y);\n      }\n      p[y] = x;\n      if (r[x] == r[y]) {\n        r[x]++;\n      }\n      return true;\n    }\n    return false;\n  }  \n};\n
duval=vector<string> duval(string const& s) {\n  int n = s.size();\n  int i = 0;\n  vector<string> fac;\n  while (i < n) {\n    int j = i + 1, k = i;\n    while (j < n && s[k] <= s[j]) {\n      if (s[k] < s[j]) k = i;\n      else k++;\n      j++;\n    }\n    while (i <= k) {\n      fac.push_back(s.substr(i, j - k));\n      i += j - k;\n    }\n  }\n  return fac;\n}\n
endmond_karp=//..uses bfs for augmentation\n//..verified against AOJ GRL_6_A \nstruct Edge {\n  int v, rev;\n  int cap, flow;\n};\n\nclass Graph {\nprivate:\n  int V;\n  int E;\n  vector <vector <Edge>> adj;\n  bool augment(int s, int t, vector <int> &prev);\npublic:\n  Graph(int n, int m);\n  void addEdge(int src, int dst, int cap);\n  int maxFlow(int s, int t);\n};\n\nGraph::Graph(int n, int m) {\n  this->V = n;\n  this->E = m;\n  adj.resize(n);\n}\n\nvoid Graph::addEdge(int src, int dst, int cap) {\n  Edge a = {dst, (int) adj[dst].size(), cap, 0};\n  Edge b = {src, (int) adj[src].size(), 0, 0};\n\n  adj[src].push_back(a);\n  adj[dst].push_back(b);\n}\n\nbool Graph::augment(int s, int t, vector <int> &prev) {\n  queue <int> q;\n  fill(prev.begin(), prev.end(), -1); //..used as visited\n  q.push(s);\n     \n  while (!q.empty()) {\n    int u = q.front();\n    q.pop();\n\n    for (Edge e : adj[u]) {\n      int v = e.v;\n      if (prev[v] == -1 && e.flow < e.cap) {\n        prev[v] = e.rev;\n        q.push(v);\n      }\n    }\n  }\n  return prev[t] != -1;\n}\n\nint Graph::maxFlow(int s, int t) {\n  int total = 0;\n  vector <int> prev(V);\n  while (augment(s, t, prev)) {\n    int v = t;\n    int flow = pinf;\n    //..find flow\n    while (v != s) {\n      int u = prev[v];\n      Edge e = adj[v][u];         //..reverse Edge\n      Edge f = adj[e.v][e.rev];   //..forward Edge\n      flow = min(flow, f.cap - f.flow);\n      v = e.v;\n    }\n    total += flow;\n    //..flow it\n    v = t;\n    while (v != s) {\n      int u = prev[v];\n      Edge &e = adj[v][u];\n      Edge &f = adj[e.v][e.rev];\n      f.flow += flow;\n      e.flow -= flow;\n      v = e.v;\n    } \n  }\n  return total;\n}\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  Graph g(n, m);\n\n  int src, dst, cap;\n  for (int i = 0; i < m; i++) {\n    cin >> src >> dst >> cap; \n    g.addEdge(src, dst, cap);\n  }\n  cout << g.maxFlow(0, n - 1) << '\n';\n  return 0;\n}\n
etov=template <typename T>\nvector<int> edges_to_vertices(const graph<T> &g, const vector<int> &edge_cycle) {\n  int sz = (int) edge_cycle.size();\n  vector<int> vertex_cycle;\n  if (sz <= 2) {\n    vertex_cycle.push_back(g.edges[edge_cycle[0]].from);\n    if (sz == 2) {\n      vertex_cycle.push_back(g.edges[edge_cycle[0]].to);\n    }\n  } else {\n    for (int i = 0; i < sz; i++) {\n      int j = (i + 1) % sz;\n      auto &e = g.edges[edge_cycle[i]];\n      auto &other = g.edges[edge_cycle[j]];\n      if (other.from == e.from || other.to == e.from) {\n        vertex_cycle.push_back(e.to);\n      } else {\n        vertex_cycle.push_back(e.from);\n      }\n    }\n  }\n  return vertex_cycle;\n  // only for simple cycles!\n}\n \n
euclid=int euclid(point p1, point p2) { \n  int x1 = p1.x;\n  int y1 = p1.y;\n  int x2 = p2.x;\n  int y2 = p2.y;\n  return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2); \n} \n
euler=template <typename T>\nvector<int> find_eulerian_path(const graph<T> &g, int &root) {\n  // in_deg and out_deg are fake for undigraph!\n  vector<int> in_deg(g.n, 0);\n  vector<int> out_deg(g.n, 0);\n  int cnt_edges = 0;\n  for (int id = 0; id < (int) g.edges.size(); id++) {\n    cnt_edges++;\n    auto &e = g.edges[id];\n    out_deg[e.from]++;\n    in_deg[e.to]++;\n  }\n  root = -1;\n  int odd = 0;\n  for (int i = 0; i < g.n; i++) {\n    if ((in_deg[i] + out_deg[i]) % 2 == 1) {\n      odd++;\n      if (root == -1 || out_deg[i] - in_deg[i] > out_deg[root] - in_deg[root]) {\n        root = i;\n      }\n    }\n  }\n  if (odd > 2) {  \n    root = -1;\n    return vector<int>();\n  }\n  if (root == -1) {\n    root = 0;\n    while (root < g.n && in_deg[root] + out_deg[root] == 0) {\n      root++;\n    }\n    if (root == g.n) {\n      // an empty path\n      root = 0;\n      return vector<int>();\n    }\n  }\n  vector<bool> used(g.edges.size(), false);\n  vector<int> ptr(g.n, 0);\n  vector<int> balance(g.n, 0);\n  vector<int> res(cnt_edges);\n  int stack_ptr = 0;\n  int write_ptr = cnt_edges;\n  int v = root;\n  while (true) {\n    bool found = false;\n    while (ptr[v] < (int) g.g[v].size()) {\n      int id = g.g[v][ptr[v]++];\n      if (used[id]) {\n        continue;\n      }\n      used[id] = true;\n      res[stack_ptr++] = id;\n      auto &e = g.edges[id];\n      balance[v]++;\n      v ^= e.from ^ e.to;\n      balance[v]--;\n      found = true;\n      break;\n    }\n    if (!found) {\n      if (stack_ptr == 0) {\n        break;\n      }\n      int id = res[--stack_ptr];\n      res[--write_ptr] = id;\n      auto &e = g.edges[id];\n      v ^= e.from ^ e.to;\n    }\n  }\n  int disbalance = 0;\n  for (int i = 0; i < g.n; i++) {\n    disbalance += abs(balance[i]);\n  }\n  if (write_ptr != 0 || disbalance > 2) {\n    root = -1;\n    return vector<int>();\n  }\n  return res;\n}\n\n
extended_gcd=int extended_gcd(int a, int b, int &x, int &y) {\n  if (b == 0) {\n    x = 1;\n    y = 0;\n    return a;\n  }\n  int x1, y1;\n  int d = extended_gcd(b, a % b, x1, y1);\n  x = y1;\n  y = x1 - (a / b) * y1;\n  return d;\n}\n
factorise=namespace factorizer {\n \n  template <typename T>\n  struct FactorizerVarMod { static T value; };\n  template <typename T>\n  T FactorizerVarMod<T>::value;\n   \n  template <typename T>\n  bool IsPrime(T n, const vector<T>& bases) {\n    if (n < 2) {\n      return false;\n    }\n    vector<T> small_primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\n    for (const T& x : small_primes) {\n      if (n % x == 0) {\n	return n == x;\n      }\n    }\n    if (n < 31 * 31) {\n      return true;\n    }\n    int s = 0;\n    T d = n - 1;\n    while ((d & 1) == 0) {\n      d >>= 1;\n      s++;\n    }\n    FactorizerVarMod<T>::value = n;\n    for (const T& a : bases) {\n      if (a % n == 0) {\n	continue;\n      }\n      Modular<FactorizerVarMod<T>> cur = a;\n      cur = power(cur, d);\n      if (cur == 1) {\n	continue;\n      }\n      bool witness = true;\n      for (int r = 0; r < s; r++) {\n	if (cur == n - 1) {\n	  witness = false;\n	  break;\n	}\n	cur *= cur;\n      }\n      if (witness) {\n	return false;\n      }\n    }\n    return true;\n  }\n   \n  bool IsPrime(long long n) {\n    return IsPrime(n, {2, 325, 9375, 28178, 450775, 9780504, 1795265022});\n  }\n   \n  bool IsPrime(int32_t n) {\n    return IsPrime(n, {2, 7, 61});\n  }\n   \n  // but if you really need unsigned long long version...\n  /*\n  bool IsPrime(unsigned long long n) {\n    if (n < 2) {\n      return false;\n    }\n    vector<uint32_t> small_primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\n    for (uint32_t x : small_primes) {\n      if (n == x) {\n	return true;\n      }\n      if (n % x == 0) {\n	return false;\n      }\n    }\n    if (n < 31 * 31) {\n      return true;\n    }\n    uint32_t s = __builtin_ctzll(n - 1);\n    unsigned long long d = (n - 1) >> s;\n    function<bool(unsigned long long)> witness = [&n, &s, &d](unsigned long long a) {\n      unsigned long long cur = 1, p = d;\n      while (p > 0) {\n	if (p & 1) {\n	  cur = (__uint128_t) cur * a % n;\n	}\n	a = (__uint128_t) a * a % n;\n	p >>= 1;\n      }\n      if (cur == 1) {\n	return false;\n      }\n      for (uint32_t r = 0; r < s; r++) {\n	if (cur == n - 1) {\n	  return false;\n	}\n	cur = (__uint128_t) cur * cur % n;\n      }\n      return true;\n    };\n    vector<unsigned long long> bases_64bit = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};\n    for (unsigned long long a : bases_64bit) {\n      if (a % n == 0) {\n	return true;\n      }\n      if (witness(a)) {\n	return false;\n      }\n    }\n    return true;\n  }\n  */\n   \n  vector<int> least = {0, 1};\n  vector<int> primes;\n  int precalculated = 1;\n   \n  void RunLinearSieve(int n) {\n    n = max(n, 1);\n    least.assign(n + 1, 0);\n    primes.clear();\n    for (int i = 2; i <= n; i++) {\n      if (least[i] == 0) {\n	least[i] = i;\n	primes.push_back(i);\n      }\n      for (int x : primes) {\n	if (x > least[i] || i * x > n) {\n	  break;\n	}\n	least[i * x] = x;\n      }\n    }\n    precalculated = n;\n  }\n   \n  void RunSlowSieve(int n) {\n    n = max(n, 1);\n    least.assign(n + 1, 0);\n    for (int i = 2; i * i <= n; i++) {\n      if (least[i] == 0) {\n	for (int j = i * i; j <= n; j += i) {\n	  if (least[j] == 0) {\n	    least[j] = i;\n	  }\n	}\n      }\n    }\n    primes.clear();\n    for (int i = 2; i <= n; i++) {\n      if (least[i] == 0) {\n	least[i] = i;\n	primes.push_back(i);\n      }\n    }\n    precalculated = n;\n  }\n   \n  void RunSieve(int n) {\n    RunLinearSieve(n);\n  }\n   \n  template <typename T>\n  vector<pair<T, int>> MergeFactors(const vector<pair<T, int>>& a, const vector<pair<T, int>>& b) {\n    vector<pair<T, int>> c;\n    int i = 0;\n    int j = 0;\n    while (i < (int) a.size() || j < (int) b.size()) {\n      if (i < (int) a.size() && j < (int) b.size() && a[i].first == b[j].first) {\n	c.emplace_back(a[i].first, a[i].second + b[j].second);\n	++i;\n	++j;\n	continue;\n      }\n      if (j == (int) b.size() || (i < (int) a.size() && a[i].first < b[j].first)) {\n	c.push_back(a[i++]);\n      } else {\n	c.push_back(b[j++]);\n      }\n    }\n    return c;\n  }\n   \n  template <typename T>\n  vector<pair<T, int>> RhoC(const T& n, const T& c) {\n    if (n <= 1) {\n      return {};\n    }\n    if ((n & 1) == 0) {\n      return MergeFactors({{2, 1}}, RhoC(n / 2, c));\n    }\n    if (IsPrime(n)) {\n      return {{n, 1}};\n    }\n    FactorizerVarMod<T>::value = n;\n    Modular<FactorizerVarMod<T>> x = 2;\n    Modular<FactorizerVarMod<T>> saved = 2;\n    T power = 1;\n    T lam = 1;\n    while (true) {\n      x = x * x + c;\n      T g = __gcd((x - saved)(), n);\n      if (g != 1) {\n	return MergeFactors(RhoC(g, c + 1), RhoC(n / g, c + 1));\n      }\n      if (power == lam) {\n	saved = x;\n	power <<= 1;\n	lam = 0;\n      }\n      lam++;\n    }\n    return {};\n  }\n   \n  template <typename T>\n  vector<pair<T, int>> Rho(const T& n) {\n    return RhoC(n, static_cast<T>(1));\n  }\n   \n  template <typename T>\n  vector<pair<T, int>> Factorize(T x) {\n    if (x <= 1) {\n      return {};\n    }\n    if (x <= precalculated) {\n      vector<pair<T, int>> ret;\n      while (x > 1) {\n	if (!ret.empty() && ret.back().first == least[x]) {\n	  ret.back().second++;\n	} else {\n	  ret.emplace_back(least[x], 1);\n	}\n	x /= least[x];\n      }\n      return ret;\n    }\n    if (x <= static_cast<long long>(precalculated) * precalculated) {\n      vector<pair<T, int>> ret;\n      if (!IsPrime(x)) {\n	for (T i : primes) {\n	  T t = x / i;\n	  if (i > t) {\n	    break;\n	  }\n	  if (x == t * i) {\n	    int cnt = 0;\n	    while (x % i == 0) {\n	      x /= i;\n	      cnt++;\n	    }\n	    ret.emplace_back(i, cnt);\n	    if (IsPrime(x)) {\n	      break;\n	    }\n	  }\n	}\n      }\n      if (x > 1) {\n	ret.emplace_back(x, 1);\n      }\n      return ret;\n    }\n    return Rho(x);\n  }\n   \n  template <typename T>\n  vector<T> BuildDivisorsFromFactors(const vector<pair<T, int>>& factors) {\n    vector<T> divisors = {1};\n    for (auto& p : factors) {\n      int sz = (int) divisors.size();\n      for (int i = 0; i < sz; i++) {\n	T cur = divisors[i];\n	for (int j = 0; j < p.second; j++) {\n	  cur *= p.first;\n	  divisors.push_back(cur);\n	}\n      }\n    }\n    sort(divisors.begin(), divisors.end());\n    return divisors;\n  }\n \n}  // namespace factorizer\n\nusing namespace factoriser;\n\n// returns prime factorisation\ntemplate <typename T>\nvector <pair<T, T>> prime_factorise(T n) {\n  vector <pair <T, T>> fac;\n  if (n <= 1) return fac;\n  int cnt = 0;\n  bool found = false;\n  while (n % 2 == 0) {    \n    n = n / 2;\n    cnt += 1;\n    found = true;\n  }  \n  if (found) fac.emplace_back(2, cnt);\n\n  for (int i = 3; i <= (int) sqrt(n); i = i + 2) {  \n    cnt = 0;\n    found = false;\n    while (n % i == 0) {\n      n = n / i;\n      cnt += 1;\n      found = true;\n    }  \n    if (found) fac.emplace_back(i, cnt);\n  }  \n\n  if (n > 2) {\n    fac.emplace_back(n, 1);\n  }\n  return fac;\n}\n\n// returns all factors\ntemplate <typename T>\nvector <T> factorise(T val) {\n  vector <T> fac;\n  for (T n = 1; n * n <= val; n++) {\n    if (val % n == 0) {\n      if (val / n == n) {\n        fac.emplace_back(n);\n      } else {\n        fac.emplace_back(n);\n        fac.emplace_back(val / n);\n      }\n    } \n  }\n  sort(fac.begin(), fac.end());\n  return fac;\n}\n
fast=#pragma comment(linker, "/stack:200000000")\n#pragma GCC optimize("Ofast")\n#pragma GCC target("sse,sse2,sse3,ssse3,sse4,avx,avx2")\n
fenwick=//..range sum, modify only adds value,\ntemplate <typename T>\nclass fenwick {\n public:\n  vector<T> fenw;\n  int n;\n \n  fenwick(int _n) : n(_n) {\n    fenw.resize(n);\n  }\n \n  void modify(int x, T v) {\n    while (x < n) {\n      fenw[x] += v;\n      x |= (x + 1);\n    }\n  }\n \n  T get(int x) {\n    T v{};\n    while (x >= 0) {\n      v += fenw[x];\n      x = (x & (x + 1)) - 1;\n    }\n    return v;\n  }\n};\n\nstruct node {\n  int a = ...; //don't forget to set default value\n  inline void operator += (node &other) {\n    ...\n  } \n};\n\n//..range minimum query [0 - x]\ntemplate <typename T>\nclass fenwick {\n  vector<T> fenw;\n  int n, v;\n \n  fenwick(int n, int v) : n(n), v(v) {\n    fenw = vector<int>(n, v);\n  }\n \n  void modify(int x, int v) {\n    while (x < n) {\n      fenw[x] = min(fenw[x], v);\n      x |= x + 1;\n    }\n  }\n \n  T get(int x) {\n    T res = v;\n    while (x >= 0) {\n      res = min(res, fenw[x]);\n      x = (x & (x + 1)) - 1;\n    }\n    return res;\n  }\n};\n*/\n\n//..[0 - i] range minimum point update Fenwick, lsb(x) = (x & -x)\ntemplate <typename T>\nclass fenwick {\n public:\n  vector <T> bit;\n  vector <T> arr;\n  int init = numeric_limits<T>::max();\n  int n;\n  fenwick(int _n) : n(_n + 1) { \n    arr = vector <T>(n, init);\n    bit = vector <T>(n, init);\n  }\n\n  fenwick(vector <int>& nums) : fenwick(nums.size()) {\n    int len = nums.size();\n    for (int i = 0; i < len; i++) {\n      modify(i, nums[i]);\n    }                      \n  }\n\n  void modify(int i, int val) { \n    int idx = i + 1;\n    while (idx < n) {\n      bit[idx] = min(bit[idx], val);\n      idx = idx + (idx & -idx);\n    }\n    arr[i] = val;\n  }\n\n  T get(int i) {\n    T res = init;\n    int idx = i + 1;\n    while (idx > 0) {\n      res = min(res, bit[idx]);\n      idx = idx - (idx & -idx);\n    }\n    return res;\n  }\n};\n\n//range sum point update Fenwick, lsb(x) = (x & -x)\ntemplate <typename T>\nclass fenwick {\n public:\n  vector <T> bit;\n  vector <T> arr;\n  int init = 0;\n  int n;\n\n  fenwick(int _n) : n(_n + 1) {\n    arr = vector <T>(n, init);\n    bit = vector <T>(n, init);\n  }\n\n  fenwick(vector <int> &nums) : fenwick(nums.size()) {\n    int len = nums.size();\n    for (int i = 0; i < len; i++) {\n      modify(i, nums[i]);\n    }\n  }\n\n  void modify(int i, int val) { \n    int idx = i + 1;\n    while (idx < n) {\n      bit[idx] += val - arr[i];\n      idx = idx + (idx & -idx);\n    }\n    arr[i] = val;\n  }\n\n  T get(int i) {\n    T sum = init;\n    int idx = i + 1;\n    while (idx > 0) {\n      sum += bit[idx];\n      idx = idx - (idx & -idx);\n    }\n    return sum;\n  }\n\n  int get(int i, int j) { \n    int sumj = get(j);\n    int sumi = get(i - 1);\n    return sumj - sumi;\n  }\n};\n
fenwick2d=template <typename T>\nclass fenwick2d {\n public:\n  vector<vector<T>> fenw;\n  int n, m;\n \n  fenwick2d(int _n, int _m) : n(_n), m(_m) {\n    fenw.resize(n);\n    for (int i = 0; i < n; i++) {\n      fenw[i].resize(m);\n    }\n  }\n \n  inline void modify(int i, int j, T v) {\n    int x = i;\n    while (x < n) {\n      int y = j;\n      while (y < m) {\n        fenw[x][y] += v;\n        y |= (y + 1);\n      }\n      x |= (x + 1);\n    }\n  }\n \n  inline T get(int i, int j) {\n    T v{};\n    int x = i;\n    while (x >= 0) {\n      int y = j;\n      while (y >= 0) {\n        v += fenw[x][y];\n        y = (y & (y + 1)) - 1;\n      }\n      x = (x & (x + 1)) - 1;\n    }\n    return v;\n  }\n};\n
fft=namespace fft {\n  const double PI = acos(-1);\n \n  struct num {\n    double x, y;\n    num(double x = 0, double y = 0) : x(x), y(y) {}\n\n    num operator+(const num& o) const {\n      return num(x + o.x, y + o.y);\n    }\n \n    num operator-(const num& o) const {\n      return num(x - o.x, y - o.y);\n    }\n \n    num operator*(const num& o) const {\n      return num(x * o.x - y * o.y, x * o.y + y * o.x);\n    }\n  };\n \n  num conj(num a) {\n    return num(a.x, -a.y);\n  }\n  vector<num> fa, fb, roots = {num(0, 0), num(1, 0)};\n  vector<int> rev = {0, 1};\n  int base = 1;\n \n  void ensure_base(int nbase) {\n    if (nbase <= base) {\n      return;\n    }\n    rev.resize(1 << nbase);\n    for (int i = 0; i < (1 << nbase); ++i) {\n      rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (nbase - 1));\n    }\n    roots.resize(1 << nbase);\n    while (base < nbase) {\n      double angle = 2 * PI / (1 << (base + 1));\n      for (int i = 1 << (base - 1); i < (1 << base); ++i) {\n        roots[i << 1] = roots[i];\n        double ang = angle * ((i << 1) + 1 - (1 << base));\n        roots[i << 1 | 1] = num(cos(ang), sin(ang));\n      }\n      ++base;\n    }\n  }\n \n  void dft(vector<num>& a, int n) {\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for (int i = 0; i < n; ++i) {\n      if (i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for (int i = 1; i < n; i <<= 1) {\n      for (int j = 0; j < n; j += i << 1) {\n        for (int k = 0; k < i; ++k) {\n          num x = a[j + k], y = a[j + k + i] * roots[i + k];\n          a[j + k] = x + y;\n          a[j + k + i] = x - y;\n        }\n      }\n    }\n  }\n \n  vector<double> multiply(const vector<double>& a, const vector<double>& b) {\n    int need = a.size() + b.size() - 1, nbase = 0;\n    while (1 << nbase < need) {\n      ++nbase;\n    }\n    ensure_base(nbase);\n    bool equal = a == b;\n    int sz = 1 << nbase;\n    if (sz > (int) fa.size()) {\n      fa.resize(sz);\n    }\n    if (sz > (int) fb.size()) {\n      fb.resize(sz);\n    }\n    for (int i = 0; i < (int) a.size(); i++) {\n      fa[i] = num(a[i], 0);\n    }\n    for (int i = a.size(); i < sz; ++i) {\n      fa[i] = num(0, 0);\n    }\n    dft(fa, sz);\n    if (equal) {\n      for (int i = 0; i < sz; ++i) {\n        fb[i] = fa[i];\n      }\n    } else {\n      for (int i = 0; i < (int) b.size(); ++i) {\n        fb[i] = num(b[i], 0);\n      }\n      for (int i = (int) b.size(); i < sz; ++i) {\n        fb[i] = num(0, 0);\n      }\n      dft(fb, sz);\n    }\n    num ratio(1.0 / sz, 0);\n    for (int i = 0; i < sz; ++i) {\n      fa[i] = fa[i] * fb[i] * ratio;\n    }\n    reverse(fa.begin() + 1, fa.begin() + sz);\n    dft(fa, sz);\n    vector<double> c(need);\n    for (int i = 0; i < need; ++i) {\n      c[i] = fa[i].x;\n    }\n    return c;\n  }\n}\n \nusing fft::multiply;\n
fib=vector <int> fib(int maxe = (int) (1e9)) {\n  vector <int> seq = {1, 1};\n  while (true) {\n    int n = seq.size();\n    long long next = (long long) seq[n - 1] + seq[n - 2];\n    if (next > maxe) {\n      break;\n    } \n    seq.push_back(next);\n  } \n  return seq;\n  //returns fibonacci sequence rising atmost maxe\n} \n
flow=/*\n// ..Mine\nusing Dinic's maxflow (V * V * E) uses BFS : dinic\nusing push-relabel method (V * V * E) : push_relabel\nusing Ford-Fulkerson maxflow (E * F) uses DFS : ford_fulkerson\nusing Endmond-Karp (V * E * E) uses BFS : endmond_karp\n*/\n\ntemplate <typename T>\nclass flow_graph {\n public:\n  static constexpr T eps = (T) 1e-9;\n \n  struct edge {\n    int from;\n    int to;\n    T c;\n    T f;\n  };\n \n  vector<vector<int>> g;\n  vector<edge> edges;\n  int n;\n  int st;\n  int fin;\n  T flow;\n \n  flow_graph(int _n, int _st, int _fin) : n(_n), st(_st), fin(_fin) {\n    assert(0 <= st && st < n && 0 <= fin && fin < n && st != fin);\n    g.resize(n);\n    flow = 0;\n  }\n \n  void clear_flow() {\n    for (const edge &e : edges) {\n      e.f = 0;\n    }\n    flow = 0;\n  }\n   \n  int add(int from, int to, T forward_cap, T backward_cap) {\n    assert(0 <= from && from < n && 0 <= to && to < n);\n    int id = (int) edges.size();\n    g[from].push_back(id); //forward edge have even id\n    edges.push_back({from, to, forward_cap, 0});\n    g[to].push_back(id + 1);\n    edges.push_back({to, from, backward_cap, 0});\n    return id;\n  }\n};\n \ntemplate <typename T>\nclass dinic {\n public:\n  flow_graph<T> &g;\n \n  vector<int> ptr;\n  vector<int> d;\n  vector<int> q;\n \n  dinic(flow_graph<T> &_g) : g(_g) {\n    ptr.resize(g.n);\n    d.resize(g.n);\n    q.resize(g.n);\n  }\n \n  bool expath() {\n    fill(d.begin(), d.end(), -1);\n    q[0] = g.fin;\n    d[g.fin] = 0;\n    int beg = 0, end = 1;\n    while (beg < end) {\n      int i = q[beg++];\n      for (int id : g.g[i]) {\n        const auto &e = g.edges[id];\n        const auto &back = g.edges[id ^ 1]; // id + 1\n        if (back.c - back.f > g.eps && d[e.to] == -1) {\n          d[e.to] = d[i] + 1;\n          if (e.to == g.st) {\n            return true;\n          }\n          q[end++] = e.to;\n        }\n      }\n    }\n    return false;\n  }\n   \n  T dfs(int v, T w) {\n    if (v == g.fin) {\n      return w;\n    }\n    int &j = ptr[v];\n    while (j >= 0) {\n      int id = g.g[v][j];\n      const auto &e = g.edges[id];\n      if (e.c - e.f > g.eps && d[e.to] == d[v] - 1) {\n        T t = dfs(e.to, min(e.c - e.f, w));\n        if (t > g.eps) {\n          g.edges[id].f += t;\n          g.edges[id ^ 1].f -= t;\n          return t;\n        }\n      }\n      j--;\n    }\n    return 0;\n  }\n \n  T max_flow() {\n    while (expath()) {\n      for (int i = 0; i < g.n; i++) {\n        ptr[i] = (int) g.g[i].size() - 1;\n      }\n      T big_add = 0;\n      while (true) {\n        T add = dfs(g.st, numeric_limits<T>::max());\n        if (add <= g.eps) {\n          break;\n        }\n        big_add += add;\n      }\n      if (big_add <= g.eps) {\n        break;\n      }\n      g.flow += big_add;\n    }\n    return g.flow;\n  }\n \n  vector<bool> min_cut() {\n    max_flow();\n    vector<bool> ret(g.n);\n    for (int i = 0; i < g.n; i++) {\n      ret[i] = (d[i] != -1);\n    }\n    return ret;\n  }\n};\n
floyd_warshall=template <typename T>\nvector <vector <T>> floyd_warshall(const graph<T> &g, bool &neg) {\n  neg = false;\n  T inf = numeric_limits<T>::max();\n  vector <vector <T>> dist(g.n, vector <T>(g.n, inf));\n  for (int u = 0; u < g.n; u++) {\n    dist[u][u] = 0;\n    for (int id : g.g[u]) {\n      int v = g.edges[id].to ^ g.edges[id].from ^ u;\n      dist[u][v] = g.edges[id].cost;\n    } \n  } \n  //i .... k .... j\n  for (int k = 0; k < g.n; k++) {\n    for (int i = 0; i < g.n; i++) {\n      for (int j = 0; j < g.n; j++) {\n        if (dist[i][k] != inf && dist[k][j] != inf) {\n          if (dist[i][k] + dist[k][j] < dist[i][j]) {\n            dist[i][j] = dist[i][k] + dist[k][j];\n          }\n        }\n      } \n    }\n  } \n  for (int i = 0; i < g.n; i++) {\n    neg |= (dist[i][i] < 0);\n  } \n  return dist;\n  //..negative cycle present when dist[i][i] < 0\n  //..contains inf if no path exists, else shortest path\n}\n
for=for (int i = 0; i < $1; i++) {\n  $0\n}\n
ford_fulkerson=//..verified against AOJ GRL_6_A\nconst int N = 101;\nvector <bool> visited(N);\nstruct Edge {\n  int to, rev;\n  int flow, cap;\n};\n\nclass Graph {\nprivate:\n  int V;\n  int E;\n  vector < vector<Edge>> adj;\n  int augment(int u, int t, int flow);\npublic:\n  Graph(int n, int m);\n  void addEdge(int src, int dst, int cap);\n  int maxFlow(int s, int t);\n};\n\nGraph::Graph(int n, int m) {\n  this->V = n;\n  this->E = m;\n  adj.resize(n);\n} \n\nvoid Graph::addEdge(int src, int dst, int cap) {\n  Edge a = {dst, (int) adj[dst].size(), 0, cap};\n  Edge b = {src, (int) adj[src].size(), 0, 0};\n\n  adj[src].push_back(a);\n  adj[dst].push_back(b);  \n}\n\nint Graph::augment(int u, int t, int flow) {\n  if (u == t) {\n    return flow;\n  }\n  visited[u] = true;\n  for (Edge &e : adj[u]) {    //important to iterate the reference variable &e\n    int v = e.to;\n    if (!visited[v] && e.flow < e.cap) {\n      int flow_ahead = augment(v, t, min(flow, e.cap - e.flow));\n      if (flow_ahead > 0) {\n        e.flow += flow_ahead;\n        adj[v][e.rev].flow -= flow_ahead;\n        return flow_ahead;\n      }\n    }\n  }\n  return 0;\n}\n\nint Graph::maxFlow(int s, int t) {\n  int total = 0;\n  while (true) {\n    fill(visited.begin(), visited.begin() + V, false);\n    int flow = augment(s, t, pinf);\n    if (flow == 0) {\n      break;\n    }\n    total += flow;\n  }\n  return total;\n} \n\nint main() {  \n  int n, m;\n  cin >> n >> m;\n  Graph g(n, m);\n\n  int src, dst, cap;\n  for (int i = 0; i < m; i++) {\n    cin >> src >> dst >> cap;\n    g.addEdge(src, dst, cap);\n  }\n  cout << g.maxFlow(0, n - 1) << '\n';\n  return 0;\n}\n
forest=template <typename T>\nclass forest : public graph<T> {\n public:\n  using graph<T>::edges;\n  using graph<T>::g;\n  using graph<T>::n;\n \n  forest(int _n) : graph<T>(_n) {\n  }\n \n  int add(int from, int to, T cost = 1) {\n    assert(0 <= from && from < n && 0 <= to && to < n);\n    int id = (int) edges.size();\n    assert(id < n - 1);\n    g[from].push_back(id);\n    g[to].push_back(id);\n    edges.push_back({from, to, cost});\n    return id;\n  }\n};\n
fori=for (int i = 0; i < $1; i++) {\n  $0\n} \n
forj=for (int j = 0; j < $1; j++) {\n  $0\n} \n
fork=for (int k = 0; k < $1; k++) {\n  $0\n}\n
frac=struct frac {\n  long long num, den;\n \n  frac(long long x = 0, long long y = 1)  {\n    long long g = abs(__gcd(x, y));\n    if (y < 0) {\n      g = -g;\n    }\n    num = x / g;\n    den = y / g;\n  }\n \n  frac operator-() const {\n    return frac(-num, den);\n  }\n \n  frac operator+(const frac& o) const {\n    return frac(num * o.den + den * o.num, den * o.den);\n  }\n \n  frac operator-(const frac& o) const {\n    return frac(num * o.den - den * o.num, den * o.den);\n  }\n \n  frac operator*(const frac& o) const {\n    return frac(num * o.num, den * o.den);\n  }\n \n  frac operator/(const frac& o) const {\n    return frac(num * o.den, den * o.num);\n  }\n \n  bool operator<(const frac& o) const {\n    return num * o.den < den * o.num;\n  }\n \n  bool operator==(const frac& o) const {\n    return num * o.den == den * o.num;\n  }\n\n  bool operator>(const frac& o) const {\n    return num * o.den < den * o.num;\n  }\n};\n
friend=class Complex {\n  int r;\n  int i;\n  Complex(int ir, int ii) : r(ir), i(ii) {}\n  friend istream& operator >> (istream &in,  Complex &c);\n  friend ostream& operator << (istream &out,  Complex &c);\n};\n\nistream& operator >> (istream &in,  Circle &c) {\n  //TODO\n}\n\nostream& operator << (ostream &out,  Circle &c) {\n  //TODO\n} \n
gauss=typedef double ld;\n \nconst ld eps = 1e-11;\n \nbool IsZero(ld v) {\n  return abs(v) < eps;\n}\n \nenum GAUSS_MODE {\n  DEGREE, ABS\n};\n \ntemplate <typename T>\nvoid GaussianElimination(vector<vector<T>>& a, int limit, GAUSS_MODE mode = ABS) {\n  if (a.empty() || a[0].empty()) {\n    return;\n  }\n  int h = static_cast<int>(a.size());\n  int w = static_cast<int>(a[0].size());\n  for (int i = 0; i < h; i++) {\n    assert(w == static_cast<int>(a[i].size()));\n  }\n  assert(limit <= w);\n  vector<int> deg(h);\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      deg[i] += !IsZero(a[i][j]);\n    }\n  }\n  {\n    int r = 0;\n    for (int c = 0; c < limit; c++) {\n      int id = -1;\n      for (int i = r; i < h; i++) {\n        if (!IsZero(a[i][c]) && (id == -1 || (mode == DEGREE && deg[i] < deg[id]) || (mode == ABS && abs(a[id][c]) < abs(a[i][c])))) {\n          id = i;\n        }\n      }\n      if (id == -1) {\n        continue;\n      }\n      if (id > r) {\n        swap(a[r], a[id]);\n        swap(deg[r], deg[id]);\n        for (int j = c; j < w; j++) {\n          a[id][j] = -a[id][j];\n        }\n      }\n      vector<int> nonzero;\n      for (int j = c; j < w; j++) {\n        if (!IsZero(a[r][j])) {\n          nonzero.push_back(j);\n        }\n      }\n      T inv_a = 1 / a[r][c];\n      for (int i = r + 1; i < h; i++) {\n        if (IsZero(a[i][c])) {\n          continue;\n        }\n        T coeff = -a[i][c] * inv_a;\n        for (int j : nonzero) {\n          if (!IsZero(a[i][j])) deg[i]--;\n          a[i][j] += coeff * a[r][j];\n          if (!IsZero(a[i][j])) deg[i]++;\n        }\n      }\n      ++r;\n    }\n  }\n  for (int r = h - 1; r >= 0; r--) {\n    for (int c = 0; c < limit; c++) {\n      if (!IsZero(a[r][c])) {\n        T inv_a = 1 / a[r][c];\n        for (int i = r - 1; i >= 0; i--) {\n          if (IsZero(a[i][c])) {\n            continue;\n          }\n          T coeff = -a[i][c] * inv_a;\n          for (int j = c; j < w; j++) {\n            a[i][j] += coeff * a[r][j];\n          }\n        }\n        break;\n      }\n    }\n  }\n}\n \ntemplate <typename T>\nvector<T> SolveLinearSystem(vector<vector<T>>& a, const vector<T>& b, int w) {\n  int h = static_cast<int>(a.size());\n  assert(h == static_cast<int>(b.size()));\n  if (h > 0) {\n    assert(w == static_cast<int>(a[0].size()));\n  }\n  for (int i = 0; i < h; i++) {\n    a[i].push_back(b[i]);\n  }\n  GaussianElimination(a, w);\n  vector<T> x(w, 0);\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      if (!IsZero(a[i][j])) {\n        x[j] = a[i][w] / a[i][j];\n        break;\n      }\n    }\n  }\n  return x;\n}\n
gcd=template <typename T>\nT gcd(T a, T b) {\n  return b == 0 ? a : gcd(b, a % b);\n}\n
gen=import matplotlib.pyplot as plt\nimport networkx as nx\nimport sys\nsys.stdin = open("sol.in", "r")\nG = nx.Graph()\nn, m = [int(x) for x in input().split()]\nfor i in range(0, m):\n  s, t, w = [int(x) for x in input().split()]\n  G.add_edge(s, t, weight=w)\n\npos = nx.spring_layout(G)  # compute graph layout\nnx.draw(G, pos, node_size=700)  # draw nodes and edges\nnx.draw_networkx_labels(G, pos)  # draw node labels/names\nlabels = nx.get_edge_attributes(G, 'weight')\nnx.draw_networkx_edge_labels(G, pos, edge_labels=labels)\nplt.show()\n
gomory_hu=template <typename T>\nforest<T> gomory_hu(const undigraph<T> &g) {\n  int n = g.n;\n  if (n == 1) {\n    return forest<T>(n);\n  }\n  flow_graph<T> fg(n, 0, 1);\n  for (auto &e : g.edges) {\n    fg.add(e.from, e.to, e.cost, e.cost);\n  }\n  vector< vector<int> > dist(n, vector<int>(n, numeric_limits<T>::max()));\n  function<void(vector<int>)> dfs = [&g, &n, &fg, &dist, &dfs](vector<int> group) {\n    int sz = group.size();\n    if (sz == 1) {\n      return;\n    }\n    fg.clear_flow();\n    fg.st = group[0];\n    fg.fin = group[1];\n    T flow = fg.max_flow();\n    vector<bool> cut = fg.min_cut();\n    for (int i = 0; i < n; i++) {\n      for (int j = i + 1; j < n; j++) {\n        if (cut[i] != cut[j]) {\n          dist[i][j] = min(dist[i][j], flow);\n        }\n      }\n    }\n    vector<int> new_groups[2];\n    for (int v : group) {\n      new_groups[(int) cut[v]].push_back(v);\n    }\n    for (int id = 0; id < 2; id++) {\n      dfs(new_groups[id]);\n    }\n  };\n  vector<int> group(n);\n  iota(group.begin(), group.end(), 0);\n  dfs(group);\n  undigraph<T> mg(n);\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      mg.add(i, j, -dist[i][j]);\n    }\n  }\n  T foo;\n  vector<int> ids = mst(mg, foo);\n  forest<T> ret(n);\n  for (int id : ids) {\n    auto &e = mg.edges[id];\n    ret.add(e.from, e.to, -e.cost);\n  }\n  return ret;\n  // don't be lazy next time!\n  // implement a proper gomory-hu tree\n}\n
graham=\nvector <point> graham(vector <point> &arr) { \n  int n = arr.size();  \n  int ymin = arr[0].y, start = 0; \n  for (int i = 1; i < n; i++) { \n    int y = arr[i].y; \n    if ((y < ymin) || (ymin == y && arr[i].x < arr[start].x)) {\n      ymin = arr[i].y;\n      start = i; \n    }\n  }\n  auto swap = [&] (point &p1, point &p2) { \n    point temp = p1; \n    p1 = p2; \n    p2 = temp;\n  }; \n  swap(arr[0], arr[start]);\n  point p0 = arr[0]; \n  auto comp = [&](const point &p1, const point &p2) { \n    int o = orientation(p0, p1, p2); \n    if (o == S) return euclid(p0, p1) < euclid(p0, p2);\n    return o == L;\n  };\n  sort(arr.begin() + 1, arr.end(), comp); \n  stack<point> st; \n  st.push(arr[0]); \n  st.push(arr[1]); \n  auto prev = [&]() { \n    point p = st.top(); \n    st.pop(); \n    point res = st.top(); \n    st.push(p); \n    return res; \n  };  \n  for (int i = 2; i < n; i++) {  \n    while (st.size() > 1 && orientation(prev(), st.top(), arr[i]) == R) {\n      st.pop(); \n    }\n    st.push(arr[i]); \n  } \n  point left_top = st.top();\n  ...vector <point> left_wall;\n  for (int i = n - 2; i >= 1; i--) {\n    if (orientation(p0, left_top, arr[i]) == S) {\n      left_wall.push_back(arr[i]);\n    } \n  }\n  vector <point> ans;\n  while (!st.empty()) { \n    point p = st.top(); \n    ans.push_back(p);\n    st.pop(); \n  }\n  reverse(ans.begin(), ans.end());\n  for (point p : left_wall) {\n    ans.push_back(p);\n  }\n  return ans;\n  // returns convex hull in antic-clockwise order from starting left-bottom most point\n} \n
graph=template <typename T>\nclass graph {\n public:\n  struct edge {\n    int from;\n    int to;\n    T cost;\n  };\n \n  vector<edge> edges;\n  vector<vector<int>> g;\n  int n;\n \n  graph(int _n) : n(_n) {\n    g.resize(n);\n  }\n \n  virtual int add(int from, int to, T cost) = 0;\n};\n
group=template <typename T>\nvector <pair <int, int>> group(vector <T> &a) {\n  int n = a.size();\n  vector <pair<int, int>> grp(n);\n  int h = 0;\n  while (h < n) {\n    int l = h;\n    while (h + 1 < n && a[h + 1] == a[l]) {\n      h += 1;\n    }\n    for (int i = l; i <= h; i++) {\n      grp[i].first = l;\n      grp[i].second = h;\n    }\n    l = h + 1;\n    h = h + 1; \n  }\n  return grp; \n  //..grp[i] = range a[i] is scattered\n} \n
hadamard=namespace fwht { \n  template<typename T>\n  void hadamard(vector<T> &a) {\n    int n = a.size();\n    for (int k = 1; k < n; k <<= 1) {\n      for (int i = 0; i < n; i += 2 * k) {\n        for (int j = 0; j < k; j++) {\n          T x = a[i + j];\n          T y = a[i + j + k];\n          a[i + j] = x + y;\n          a[i + j + k] = x - y;\n        }\n      }\n    }\n  }\n   \n  template<typename T>\n  vector<T> multiply(vector<T> a, vector<T> b) {\n    int eq = (a == b);\n    int n = 1;\n    while (n < (int) max(a.size(), b.size())) {\n      n <<= 1;\n    }\n    a.resize(n);\n    b.resize(n);\n    hadamard(a);\n    if (eq) b = a; else hadamard(b);\n    for (int i = 0; i < n; i++) {\n      a[i] *= b[i];\n    }\n    hadamard(a);\n    T q = 1 / static_cast<T>(n);\n    for (int i = 0; i < n; i++) {\n      a[i] *= q;\n    }\n    return a;\n  }\n} \n// namespace fwht\n
hash=//..both p and mod prime\nconst int p = 31;\nconst int mod = (int) (1e9 + 9);\n\ninline long long mul(long long a, long long b) {\n  long long res = a * b;\n  a = res % mod;\n  return a;\n}\n\ninline void add(long long &a, long long b) {\n  a += b;\n  if (a >= mod) {\n    a -= mod;\n  }\n}\n\n//..polynomial rolling hashing of form : str[0] * (p ^ 0) + str[1] * (p ^ 1) + str[2] * (p ^ 2)\n//..complete hash value at end of hash array\nvector <long long> hashing(const string &str) {\n  long long val = 0;\n  long long exp = 1;\n  int len = str.length();\n  vector <long long> hash(len);\n  for (int i = 0; i < len; i++) {   \n    char ch = str[i];\n    int coef = ch - 'a' + 1;\n    add(val, mul(coef, exp));\n    exp = mul(exp, p);\n\n    hash[i] = val;\n  }\n\n  return hash;\n  //..returns incremental hash values\n}\n
hash61=typedef uint64_t HT;\n \nmt19937 rng(787788789);\n \nstruct hash61 {\n  static const HT md = (1LL << 61) - 1;\n  static HT step;\n  static vector<HT> pw;\n \n  static HT addmod(HT a, HT b) {\n    a += b;\n    if (a >= md) a -= md;\n    return a;\n  }\n \n  static HT submod(HT a, HT b) {\n    a += md - b;\n    if (a >= md) a -= md;\n    return a;\n  }\n \n  static HT mulmod(HT a, HT b) {\n    HT l1 = (uint32_t) a, h1 = a >> 32, l2 = (uint32_t) b, h2 = b >> 32;\n    HT l = l1 * l2, m = l1 * h2 + l2 * h1, h = h1 * h2;\n    HT ret = (l & md) + (l >> 61) + (h << 3) + (m >> 29) + (m << 35 >> 3) + 1;\n    ret = (ret & md) + (ret >> 61);\n    ret = (ret & md) + (ret >> 61);\n    return ret - 1;\n  }\n \n  void ensure_pw(int sz) {\n    int cur = (int) pw.size();\n    if (cur < sz) {\n      pw.resize(sz);\n      for (int i = cur; i < sz; i++) {\n        pw[i] = mulmod(pw[i - 1], step);\n      }\n    }\n  }\n \n  vector<HT> pref;\n  int n;\n \n  template<typename T>\n  hash61(const T& s) {\n    n = (int) s.size();\n    ensure_pw(n + 1);\n    pref.resize(n + 1);\n    pref[0] = 1;\n    for (int i = 0; i < n; i++) {\n      pref[i + 1] = addmod(mulmod(pref[i], step), s[i]);\n    }\n  }\n \n  inline HT operator()(const int from, const int to) const {\n    assert(0 <= from && from <= to && to <= n - 1);\n    return submod(pref[to + 1], mulmod(pref[from], pw[to - from + 1]));\n  }\n};\n \nHT hash61::step = (md >> 2) + rng() % (md >> 1);\nvector<HT> hash61::pw = vector<HT>(1, 1);\n
header=#include <vector>\n#include <list>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <assert.h>\n
heap=template <typename T>\nstruct heap {\n  priority_queue<T> foo, bar;\n \n  void push(T x) {\n    foo.push(x);\n  }\n \n  void pop(T x) {\n    bar.push(x);\n  }\n \n  T top() {\n    while (!bar.empty() && foo.top() == bar.top()) {\n      foo.pop();\n      bar.pop();\n    }\n    return foo.top();\n  }\n};\n
hld_forest=template <typename T>\nclass hld_forest : public lca_forest<T> {\n public:\n  using lca_forest<T>::edges;\n  using lca_forest<T>::g;\n  using lca_forest<T>::n;\n  using lca_forest<T>::pv;\n  using lca_forest<T>::sz;\n  using lca_forest<T>::pos;\n  using lca_forest<T>::order;\n  using lca_forest<T>::depth;\n  using lca_forest<T>::dfs;\n  using lca_forest<T>::dfs_all;\n  using lca_forest<T>::lca;\n  using lca_forest<T>::build_lca;\n \n  vector<int> head;\n  vector<int> visited;\n \n  hld_forest(int _n) : lca_forest<T>(_n) {\n    visited.resize(n);\n  }\n \n  void build_hld(const vector<int> &vs) {\n    for (int tries = 0; tries < 2; tries++) {\n      if (vs.empty()) {\n        dfs_all();\n      } else {\n        order.clear();\n        for (int v : vs) {\n          dfs(v, false);\n        }\n        assert((int) order.size() == n);\n      }\n      if (tries == 1) {\n        break;\n      }\n      for (int i = 0; i < n; i++) {\n        if (g[i].empty()) {\n          continue;\n        }\n        int best = -1, bid = 0;\n        for (int j = 0; j < (int) g[i].size(); j++) {\n          int id = g[i][j];\n          int v = edges[id].from ^ edges[id].to ^ i;\n          if (pv[v] != i) {\n            continue;\n          }\n          if (sz[v] > best) {\n            best = sz[v];\n            bid = j;\n          }\n        }\n        swap(g[i][0], g[i][bid]);\n      }\n    }\n    build_lca();\n    head.resize(n);\n    for (int i = 0; i < n; i++) {\n      head[i] = i;\n    }\n    for (int i = 0; i < n - 1; i++) {\n      int x = order[i];\n      int y = order[i + 1];\n      if (pv[y] == x) {\n        head[y] = head[x];\n      }\n    }\n  }\n \n  void build_hld(int v) {\n    build_hld(vector<int>(1, v));\n  }\n \n  void build_hld_all() {\n    build_hld(vector<int>());\n  }\n \n  bool apply_on_path(int x, int y, bool with_lca, function<void(int,int,bool)> f) {\n    // f(x, y, up): up -- whether this part of the path goes up\n    assert(!head.empty());\n    int z = lca(x, y);\n    if (z == -1) {\n      return false;\n    }\n    {\n      int v = x;\n      while (v != z) {\n        if (depth[head[v]] <= depth[z]) {\n          f(pos[z] + 1, pos[v], true);\n          break;\n        }\n        f(pos[head[v]], pos[v], true);\n        v = pv[head[v]];\n      }\n    }\n    if (with_lca) {\n      f(pos[z], pos[z], false);\n    }\n    {\n      int v = y;\n      int cnt_visited = 0;\n      while (v != z) {\n        if (depth[head[v]] <= depth[z]) {\n          f(pos[z] + 1, pos[v], false);\n          break;\n        }\n        visited[cnt_visited++] = v;\n        v = pv[head[v]];\n      }\n      for (int at = cnt_visited - 1; at >= 0; at--) {\n        v = visited[at];\n        f(pos[head[v]], pos[v], false);\n      }\n    }\n    return true;\n  }\n};\n\n/* usage\nhld_forest<int> g(n);\nfor (int i = 0; i < n - 1; i++) {\n  int x, y;\n  cin >> x >> y;\n  --x; --y;\n  g.add(x, y);\n}\ng.build_hld(0);\nvector<int> labels(n);\nfor (int i = 0; i < n; i++) {\n  cin >> labels[i];\n}\nvector<pair<int, int>> a(n);\nfor (int i = 0; i < n; i++) {\n  a[i] = make_pair(labels[g.order[i]], g.order[i]);\n}\nSparseTable<pair<int, int>> st(a, [&](pair<int, int> i, pair<int, int> j) { return max(i, j); });\n\n//queries\nwhile (q--) {\n  int x, y;\n  cin >> x >> y;\n  --x; --y;\n  pair<int, int> mx = make_pair(-1, -1);\n  g.apply_on_path(x, y, true, [&](int from, int to, bool up) {\n    mx = max(mx, st.get(from, to));\n  });\n}\n*/\n
horner=// coeff in form = C0 * x^0 + c1 * x^1 + c2 * x^2 .. . . . cn-1 * x^n-1\ntemplate <typename T>\nT horner(const vector<T>& coeff, T x) {\n  int n = (int) coeff.size();\n  T res = coeff[n - 1];\n  for (int i = n - 2; i >= 0; i--) {\n    res = coeff[i] + x * res;\n  } \n  \n  return res;\n}\n
hull=vector <point> graham(vector <point> &arr) { \n  int n = arr.size();  \n  int ymin = arr[0].y, start = 0; \n  for (int i = 1; i < n; i++) { \n    int y = arr[i].y; \n    if ((y < ymin) || (ymin == y && arr[i].x < arr[start].x)) {\n      ymin = arr[i].y;\n      start = i; \n    }\n  }\n  auto swap = [&] (point &p1, point &p2) { \n    point temp = p1; \n    p1 = p2; \n    p2 = temp;\n  }; \n  swap(arr[0], arr[start]);\n  point p0 = arr[0]; \n  auto comp = [&](const point &p1, const point &p2) { \n    int o = orientation(p0, p1, p2); \n    if (o == S) return euclid(p0, p1) < euclid(p0, p2);\n    return o == L;\n  };\n  sort(arr.begin() + 1, arr.end(), comp); \n  stack<point> st; \n  st.push(arr[0]); \n  st.push(arr[1]); \n  auto prev = [&]() { \n    point p = st.top(); \n    st.pop(); \n    point res = st.top(); \n    st.push(p); \n    return res; \n  };  \n  for (int i = 2; i < n; i++) {  \n    while (st.size() > 1 && orientation(prev(), st.top(), arr[i]) == R) {\n      st.pop(); \n    }\n    st.push(arr[i]); \n  } \n  point left_top = st.top();\n  ...vector <point> left_wall;\n  for (int i = n - 2; i >= 1; i--) {\n    if (orientation(p0, left_top, arr[i]) == S) {\n      left_wall.push_back(arr[i]);\n    } \n  }\n  vector <point> ans;\n  while (!st.empty()) { \n    point p = st.top(); \n    ans.push_back(p);\n    st.pop(); \n  }\n  reverse(ans.begin(), ans.end());\n  for (point p : left_wall) {\n    ans.push_back(p);\n  }\n  return ans;\n  // returns convex hull in antic-clockwise order from starting left-bottom most point\n} \n
hungarian=template<typename T>\nclass hungarian {\n  public:\n  int n;\n  int m;\n  vector< vector<T> > a;\n  vector<T> u;\n  vector<T> v;\n  vector<int> pa;\n  vector<int> pb;\n  vector<int> way;\n  vector<T> minv;\n  vector<bool> used;\n  T inf;\n \n  hungarian(int _n, int _m) : n(_n), m(_m) {\n    assert(n <= m);\n    a = vector< vector<T> >(n, vector<T>(m));\n    u = vector<T>(n + 1);\n    v = vector<T>(m + 1);\n    pa = vector<int>(n + 1, -1);\n    pb = vector<int>(m + 1, -1);\n    way = vector<int>(m, -1);\n    minv = vector<T>(m);\n    used = vector<bool>(m + 1);\n    inf = numeric_limits<T>::max();\n  }\n \n  inline void add_row(int i) {\n    fill(minv.begin(), minv.end(), inf);\n    fill(used.begin(), used.end(), false);\n    pb[m] = i;\n    pa[i] = m;\n    int j0 = m;\n    do {\n      used[j0] = true;\n      int i0 = pb[j0];\n      T delta = inf;\n      int j1 = -1;\n      for (int j = 0; j < m; j++) {\n        if (!used[j]) {\n          T cur = a[i0][j] - u[i0] - v[j];\n          if (cur < minv[j]) {\n            minv[j] = cur;\n            way[j] = j0;\n          }\n          if (minv[j] < delta) {\n            delta = minv[j];\n            j1 = j;\n          }\n        }\n      }\n      for (int j = 0; j <= m; j++) {\n        if (used[j]) {\n          u[pb[j]] += delta;\n          v[j] -= delta;\n        } else {\n          minv[j] -= delta;\n        }\n      }\n      j0 = j1;\n    } while (pb[j0] != -1);\n    do {\n      int j1 = way[j0];\n      pb[j0] = pb[j1];\n      pa[pb[j0]] = j0;\n      j0 = j1;\n    } while (j0 != m);\n  }\n \n  inline T current_score() {\n    return -v[m];\n  }\n \n \n  inline T solve() {\n    for (int i = 0; i < n; i++) {\n      add_row(i);\n    }\n    return current_score();\n  }\n};\n \n
in=  #ifdef LOCAL\n    freopen("sol.in", "rt", stdin);\n  #endif\n
input=from sys import stdin, stdout\nimport sys\nsys.stdout = open("sol.out", "w") # for redirecting output to a file\n\nn = stdin.readline() \n# array input similar method \narr = [int(x) for x in stdin.readline().split()] \n\n#single n input followed by newline\nval = int(input())\nprint(val)\n\n#split expects newline, else error will come unlike cin in c++\na, b = [int(x) for x in input().split()]\nprint(a * b)\n\na, b = map(int, input().split())\nprint(a * b)\n\n#using stdin and stdout\na, b = [int(x) for x in stdin.readline().rstrip().split()]\nstdout.write(str(a * b) + "\n")\n\narr = [2, 3, 4, 5]\n[print(i) for i in arr] temp\n
inside=inline bool inside(int x, int y, int n, int m) {\n  return (x >= 0 && x < n) && (y >= 0 && y < m);\n}\n
inv=/*for mod not prime, but a and mod are co-prime\ninline int inv(int a) {\n  a %= mod;\n  if (a < 0) a += mod;\n  int b = mod, u = 0, v = 1;\n  while (a) {\n    int t = b / a;\n    b -= t * a; swap(a, b);\n    u -= t * v; swap(u, v);\n  }\n  assert(b == 1);\n  if (u < 0) u += mod;\n  return u;\n}\n\n//OR\nint inv(int a) {\n  int x, y;\n  int g = extended_gcd(a, mod, x, y);\n  if (g != 1) {\n    cerr << "No inverse exists" << endl;\n    return 0;\n  } else {\n    x = (x % mod + mod) % mod;\n    return x;\n  }  \n} \n*/\n//when mod is a prime number\ninline int inv(int x) {\n  return power(x, mod - 2);\n}\n
is_palindrome=template <typename T>\nbool is_palindrome(const T &s) {\n  int n = s.size();\n  for (int i = 0; i < n / 2; i++) {\n    int j = n - i - 1;\n    if (s[i] != s[j]) return false;\n  } \n  return true;\n}\n
java=import java.io.OutputStream;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Main {\n  \n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    Task solver = new Task();\n    solver.solve(in, out);\n    out.close();\n  }\n\n  static class Task {\n    public void solve(InputReader in, PrintWriter out) {\n      int n;\n      out.print("Enter a number : ");\n      n = in.nextInt();\n      out.println("You entered " + n);\n      return;\n    }  \n  }\n\n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream), 32768);\n      tokenizer = null;\n    }\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n    public float nextFloat() {\n      return Float.parseFloat(next());\n    }\n    public double nextDouble() {\n      return Double.parseDouble(next());\n    }\n    public String nextLine() {\n      try {\n        return reader.readLine();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n}\n
jump=auto min_jump = [&] (vector <int>& arr) {\n  int n = arr.size();\n  vector <int> dp(n);\n  int max_reach = arr[0];\n  int jumps = 1;\n  int steps = arr[0];\n  dp[0] = 0;\n  for (int i = 1; i < n; i++) {\n    if (i == n - 1) {\n      dp[i] = jumps;\n      return;\n    }\n    max_reach = max(max_reach, i + arr[i]);\n    steps--;\n    dp[i] = jumps;\n    if (steps == 0) {\n      jumps++;\n      steps = max_reach - i;\n    } \n  } \n};\n
kadane=template <typename T>\nT kadane(vector <T> &arr) {\n  T ans = numeric_limits<T>::min();\n  T sum = T{};\n  for (int v : arr) {\n    sum += v;\n    ans = max(ans, sum);\n    sum = max(0, sum);\n  }\n  return ans;\n  //returns only the maximum subarray sum\n} \n\ntemplate <typename T>\nT kadane(vector <T> &arr, int &l, int &h) {\n  l = h = 0;\n  T sum = T{};\n  T ans = numeric_limits<T>::min();\n  int n = arr.size();\n  int s = 0;\n  for (int i = 0; i < n; i++) {\n    sum += arr[i];\n    if (sum > ans) {\n      ans = sum;\n      l = s; h = i;\n    }\n    if (sum < 0) {\n      sum = 0;\n      s = i + 1;\n    }\n  }\n  return ans;\n  //returns maximum sum and the subarray[l - h]\n}\n\n
kahn_toposort=//..verified against AOJ GRL_4_B\nclass Graph {\nprivate:\n  int V;\n  int E;\n  vector <vector <int>> adj;\npublic:\n  Graph(int n, int m);\n  void addEdge(int s, int t);\n  void topologicalSort();\n};\n\nGraph::Graph(int n, int m) {\n  this->V = n;\n  this->E = m;\n  adj.resize(n);\n}\n\nvoid Graph::addEdge(int s, int t) {\n  adj[s].push_back(t);\n}\n\nvoid Graph::topologicalSort() {\n  vector <int> order;\n  vector <int> deg(V, 0);\n  for (int u = 0; u < V; u++) {\n    for (int v : adj[u]) {\n      deg[v]++;\n    } \n  }\n  queue <int> from;\n  for (int u = 0; u < V; u++) {\n    if (deg[u] == 0) {\n      from.push(u);\n    } \n  } \n  while (!from.empty()) {\n    int u = from.front();\n    from.pop();\n    order.emplace_back(u);\n    for (int v : adj[u]) {\n      if (deg[v] == 1) {\n        from.push(v);\n      }\n      deg[v]--;\n    } \n  }\n  if ((int) order.size() != V) { //Cycle present\n    //TODO\n  }\n\n  //..print topo order\n  for (int node : order) cout << node << " ";\n  cout << endl;\n}\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  Graph g(n, m);\n  int s, t;\n  for (int i = 0; i < m; i++) {\n    cin >> s >> t;\n    g.addEdge(s, t);\n  } \n  g.topologicalSort();\n  return 0;\n} \n
klee=// untested\ntemplate <typename T>\nT klee(const vector<pair<T, T>> &a) {\n  int n = a.size();\n  vector<pair<T, bool>> x(n * 2);\n  for (int i = 0; i < n; i++) {\n    x[i * 2] = {a[i].first, false};\n    x[i * 2 + 1] = {a[i].second, true};\n  }\n  sort(x.begin(), x.end());\n  T result = 0;\n  int cnt = 0;\n  for (int i = 0; i < n * 2; i++) {\n    if (cnt > 0) {\n      result += x[i].first - x[i - 1].first;\n    }\n    (x[i].second) ? cnt-- : cnt++;\n  }\n  return result;\n}\n\n//tested\nint klee(const vector<pair<int, int>> &a) {\n  int n = a.size();\n  vector<pair<int, bool>> x(n * 2);\n  for (int i = 0; i < n; i++) {\n    x[i * 2] = {a[i].first, false};\n    x[i * 2 + 1] = {a[i].second, true};\n  }\n  sort(x.begin(), x.end());\n  int result = 0;\n  int cnt = 0;\n  for (int i = 0; i < n * 2; i++) {\n    if (i > 0 && x[i].first > x[i - 1].first && cnt > 0) {\n      result += x[i].first - x[i - 1].first;\n    }\n    if (x[i].second) cnt--;\n    else cnt++;\n  }\n  return result;\n}\n
kmp=vector <int> kmp(const string& pat, const string& txt) {\n  int n = txt.length();\n  int m = pat.length();\n  int len = 0;\n  vector <int> lps = calc_lps(pat);\n  vector <int> pos;\n\n  for (int i = 0; i < n; i++) {\n    while (len > 0 && pat[len] != txt[i]) {\n      len = lps[len - 1];\n    }\n    if (pat[len] == txt[i]) {\n      len++;\n    }\n    if (len == m) {\n      int at = i - len + 1;\n      pos.emplace_back(at);\n      len = lps[len - 1];\n    }\n  }\n\n  return pos;\n  //.. starting indices of match\n}\n
knight=vector <int> dx = {-2, -2, -1, 1, 2, 2, 1, -1};\nvector <int> dy = {-1, 1, 2, 2, 1, -1, -2, -2};\n
kosaraju=template <typename T>\nvector<int> kosaraju(const digraph<T> &g, int &cnt) {\n  digraph<T> g_rev = g.reverse();\n  stack <int> order;\n  vector<bool> seen(g.n, false);\n  function<void(int)> dfs1 = [&](int v) {\n    seen[v] = true;\n    for (int id : g.g[v]) {\n      auto &e = g.edges[id];\n      int to = e.to;\n      if (!seen[to]) {\n        dfs1(to);\n      }\n    }\n    order.push(v);\n  };\n  for (int i = 0; i < g.n; i++) {\n    if (!seen[i]) {\n      dfs1(i);\n    }\n  }\n\n  vector<int> grp(g.n, -1);\n  cnt = 0;\n  function<void(int)> dfs2 = [&](int v) {\n    grp[v] = cnt;\n    for (int id : g_rev.g[v]) {\n      auto &e = g_rev.edges[id];\n      int to = e.to;\n      if (grp[to] == -1) {\n        dfs2(to);\n      }\n    }\n  };\n\n  while (!order.empty()) {\n    int u = order.top();\n    order.pop();\n    if (grp[u] != -1) {\n      continue;\n    }\n    dfs2(u);\n    cnt++;\n  }\n  return grp;\n  //.. grp[i] <= grp[j] for every edge i -> j\n}\n
lca=//..verified against AOJ GRL_5_C\nclass Graph {\nprivate:\n  int V;\n  vector <vector <int>> adj;\n  vector <int> first;\n  vector <int> height;\n  vector <int> euler;\n  void eulerUtil(int u, vector <bool> &visited, int h);\n  vector <int> seg;\n  void build(int idx, int ss, int se);\n  int lca_query(int idx, int ss, int se, int qs, int qe);\npublic:\n  Graph(int n);\n  void addEdge(int u, int v);    \n  void euler_tour();\n  void buildrmq();\n  int lca(int u, int v);\n};\n\nGraph::Graph(int n) {\n  this->V = n;\n  adj.resize(n);\n  first.resize(n);\n  height.resize(n);\n}\n\nvoid Graph::addEdge(int u, int v) {\n  adj[u].push_back(v);\n}\n\nvoid Graph::eulerUtil(int u, vector <bool> &visited, int h) {\n  visited[u] = true;\n  first[u] = euler.size();\n  height[u] = h;\n  euler.push_back(u);\n\n  for (int i = 0; i < (int) adj[u].size(); i++) {\n    int v = adj[u][i];\n    if (!visited[v]) {\n      eulerUtil(v, visited, h + 1);\n      euler.push_back(u);\n    }\n  }\n}\n\nvoid Graph::euler_tour() {\n  vector <bool> visited;\n  fill(visited.begin(), visited.begin() + V, false);\n  eulerUtil(0, visited, 0);\n}\n\n\nvoid Graph::build(int idx, int ss, int se) {\n  if (ss == se) {\n    seg[idx] = euler[ss];\n    return;\n  }\n\n  int m = (ss + se) / 2;\n  build(2 * idx, ss, m);\n  build(2 * idx + 1, m + 1, se);\n  //..store information based on the depth to be minimum in range\n  seg[idx] = height[seg[2 * idx]] < height[seg[2 * idx + 1]] ? seg[2 * idx] : seg[2 * idx + 1];\n}\n\nvoid Graph::buildrmq() {\n  int n = euler.size();\n  seg.resize(4 * n);\n  build(1, 0, n - 1);  \n} \n\nint Graph::lca_query(int idx, int ss, int se, int qs, int qe) {\n  if (qs > qe) {\n    return pinf;\n  }\n  if (ss == qs && se == qe) {\n    return seg[idx];\n  }\n  int m = (ss + se) / 2;\n  int l = lca_query(2 * idx, ss, m, qs, min(m, qe));\n  int r = lca_query(2 * idx + 1, m + 1, se, max(m + 1, qs), qe);\n  if (l == pinf) {\n    return r;\n  } else if (r == pinf) {\n    return l;\n  } else {\n    return height[l] < height[r] ? l : r;\n  }\n}\n\nint Graph::lca(int u, int v) {\n  int qs = first[u];\n  int qe = first[v];\n  if (qs > qe) {\n    swap(qs, qe);\n  }   \n  int n = euler.size();\n  return lca_query(1, 0, n - 1, qs, qe);\n}\n\nint main() {\n  int n;\n  cin >> n;\n  Graph g(n);\n  int k, v;\n  for (int u = 0; u < n; u++) {\n    cin >> k;\n    for (int j = 0; j < k; j++) {\n      cin >> v;\n      //..v is children of u and 0 is the root of this tree\n      g.addEdge(u, v);   \n    } \n  }\n  g.euler_tour();\n  g.buildrmq();\n\n  int q, ui, vi;\n  cin >> q;\n  for (int i = 0; i < q; i++) {\n    cin >> ui >> vi;\n    cout << g.lca(ui, vi) << '\n';\n  } \n  return 0;\n}\n
lca_forest=template <typename T>\nclass lca_forest : public dfs_forest<T> {\n public:\n  using dfs_forest<T>::edges;\n  using dfs_forest<T>::g;\n  using dfs_forest<T>::n;\n  using dfs_forest<T>::pv;\n  using dfs_forest<T>::pos;\n  using dfs_forest<T>::end;\n  using dfs_forest<T>::depth;\n \n  int h;\n  vector<vector<int>> pr;\n \n  lca_forest(int _n) : dfs_forest<T>(_n) {\n  }\n \n  inline void build_lca() {\n    assert(!pv.empty());\n    int max_depth = 0;\n    for (int i = 0; i < n; i++) {\n      max_depth = max(max_depth, depth[i]);\n    }\n    h = 1;\n    while ((1 << h) <= max_depth) {\n      h++;\n    }\n    pr.resize(n);\n    for (int i = 0; i < n; i++) {\n      pr[i].resize(h);\n      pr[i][0] = pv[i];\n    }\n    for (int j = 1; j < h; j++) {\n      for (int i = 0; i < n; i++) {\n        pr[i][j] = (pr[i][j - 1] == -1 ? -1 : pr[pr[i][j - 1]][j - 1]);\n      }\n    }\n  }\n \n  inline bool anc(int x, int y) {\n    return (pos[x] <= pos[y] && end[y] <= end[x]);\n  }\n \n  inline int go_up(int x, int up) {\n    assert(!pr.empty());\n    up = min(up, (1 << h) - 1);\n    for (int j = h - 1; j >= 0; j--) {\n      if (up & (1 << j)) {\n        x = pr[x][j];\n        if (x == -1) {\n          break;\n        }\n      }\n    }\n    return x;\n  }\n \n  inline int lca(int x, int y) {\n    assert(!pr.empty());\n    if (anc(x, y)) {\n      return x;\n    }\n    if (anc(y, x)) {\n      return y;\n    }\n    for (int j = h - 1; j >= 0; j--) {\n      if (pr[x][j] != -1 && !anc(pr[x][j], y)) {\n        x = pr[x][j];\n      }\n    }\n    return pr[x][0];\n  }\n};\n
lcm=template <typename T>\ninline T lcm(T a, T b) {\n  return a / gcd(a, b) * b;\n}\n
lcp=/* tourist's template\ntemplate <typename T>\nvector<int> build_lcp(int n, const T &s, const vector<int> &sa) {\n  assert((int) sa.size() == n);\n  vector<int> rank(n);\n  for (int i = 0; i < n; i++) {\n      rank[sa[i]] = i;\n  }\n  vector<int> lcp(max(n - 1, 0));\n  int k = 0;\n  for (int i = 0; i < n; i++) {\n    k = max(k - 1, 0);\n    if (rank[i] == n - 1) {\n      k = 0;\n    } else {\n      int j = sa[rank[i] + 1];\n      while (i + k < n && j + k < n && s[i + k] == s[j + k]) {\n        k++;\n      }\n      lcp[rank[i]] = k;\n    }\n  }\n  return lcp;\n}\n \ntemplate <typename T>\nvector<int> build_lcp(const T &s, const vector<int> &sa) {\n  return build_lcp((int) s.size(), s, sa);\n}\n\n//..vector<int> sa = suffix_array(s);\n//..vector<int> lcp = build_lcp(s, sa);\n*/\n//..first calc lcp[sa[0]], then lcp[sa[1]] ans so on\nvector<int> build_lcp(const T &s, const vector<int> &sa) {\n  int n = s.length();\n  assert((int) sa.size() == n);\n  vector<int> rank(n);\n  for (int i = 0; i < n; i++) {\n    rank[sa[i]] = i;\n  }\n  vector<int> lcp(max(n - 1, 0));\n  int k = 0;\n  for (int i = 0; i < n; i++) {\n    if (rank[i] == n - 1) {\n      k = 0;\n    } else {\n      int j = sa[rank[i] + 1];\n      while (i + k < n && j + k < n && s[i + k] == s[j + k]) {\n        k++;\n      }\n      lcp[rank[i]] = k;\n      if (k > 0) k--;\n    }\n  }\n  return lcp;\n}\n
leap=bool leap(int year) {\n  if (((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0)) {\n    return true;\n  }\n  return false; \n}\n
leetcode=namespace Leetcode {\nifstream in("sol.in");\nstring line;\nbool done = false;\n\nstring Trim(string &s) {\n  int n = s.length();\n  int i = 0, j = n - 1;\n  while (i < n && s[i] == ' ') {\n    i++;\n  }\n  while (j >= 0 && s[j] == ' ') {\n    j--;\n  }  \n  return s.substr(i, j - i + 1);\n}\n\nvoid Pass() {\n  while (getline(in, line)) {\n    line = Trim(line);\n    if (line.empty()) continue;\n    break;\n  }\n}\n\nstring String() {\n  Pass();\n  return line;\n}\n\ntemplate <typename T>\nvector <T> Vector() {\n  if (!done) Pass();\n  int len = line.length();\n  line = line.substr(1, len - 2);\n  stringstream ss(line);\n  string token;\n  vector <T> arr;\n  while (getline(ss, token, ',')) {\n    int val;\n    if (token == "null") {\n      val = -1;\n    } else {\n      val = stoi(token);\n    }\n    arr.push_back(val);\n  } \n  return arr;\n}\n\ntemplate <typename T>\nvector <vector <T>> Matrix() { \n  Pass();\n  done = true;\n  int len = line.length();\n  string temp = line.substr(1, len - 2);\n  stringstream ss(temp);\n  string token;\n  vector <vector <T>> mat;\n  while (getline(ss, token, ']')) {\n    int i = 0;\n    int l = token.length();\n    while (token[i] != '[') i++;\n    line = token.substr(i, l - i) + ']';\n    vector <T> row = Vector<T>();\n    mat.push_back(row);\n  }\n  done = false;\n  return mat;\n}\n\n#ifdef LOCAL\nstruct TreeNode {\n  int val;\n  TreeNode *left;\n  TreeNode *right;\n  TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n#endif\n  \nusing Node = TreeNode;\n\ntemplate <typename T>\nvoid Serialize(Node* root) { \n  vector <T> tree;  \n  auto Bfs = [&](Node* from) {\n    queue <Node*> q;\n    q.push(from);\n    while (!q.empty()) {\n      int size = (int) q.size();\n      while (size--) {\n        Node* u = q.front(); q.pop();\n        if (u == NULL) tree.push_back(-1);\n        else {\n          tree.push_back(u->val);\n          q.push(u->left);\n          q.push(u->right);\n        }\n      }\n    }\n  };\n\n  Bfs(root);\n  cout << "[";\n  for (int i = 0; i < (int) tree.size(); i++) {\n    if (i > 0) cout << ", ";\n    if (tree[i] == -1) cout << "null";\n    else cout << tree[i];\n  }\n  cout << "]";\n}\n\ntemplate <typename T>\nNode* Deserialize(vector <T> &data) {\n  int n = data.size();\n  queue<Node*> q;\n  Node* root = new Node(data[0]);\n  bool is_left = true;\n  q.push(root);\n\n  Node* cur = NULL;\n  for (int i = 1; i < n; i++) {\n    Node *node = NULL;\n    if (data[i] != -1) {\n      node = new Node(data[i]);\n      q.push(node);\n    }\n\n    if (is_left) {\n      cur = q.front();\n      q.pop();\n      cur->left = node;\n      is_left = false;\n    } else {\n      cur->right = node;\n      is_left = true;\n    }\n  }\n  return root;\n} \n\ntemplate <typename T>\nNode* Tree() {\n  Pass();\n  done = true;\n  vector <T> arr = Vector<T>();\n  Node* root = Deserialize(arr);\n  done = false;\n  return root;\n}  \n\ntemplate <typename T>\nT Int() {\n  Pass();\n  stringstream ss(line);\n  T val;\n  ss >> val;\n  return val;\n}\n\n..........\n\nvoid read_write() {\n  int tt = Int<int>();\n  while (tt--) {\n    ....\n  }\n}}\n\nusing namespace Leetcode;\n\n#ifdef LOCAL\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  read_write();\n  return 0;\n}\n#endif\n
lis=// short implementation\ntemplate<typename T>\nint lis(const vector<T>& a) {\n  vector<T> u;\n  for (const T& x : a) {\n    auto it = lower_bound(u.begin(), u.end(), x);\n    if (it == u.end()) {\n      u.push_back(x);\n    } else {\n      *it = x;\n    }\n  }\n  return (int) u.size();\n}\n\ntemplate <typename T>\nint lis(vector <T>& arr) {\n  int n = arr.size();\n  if (n == 0) {\n    return 0;  \n  }\n  vector <T> tail(n, 0);  \n  int length = 1; \n  tail[0] = arr[0];\n  for (int i = 1; i < n; i++) {  \n    auto b = tail.begin();\n    auto e = tail.begin() + length; \n    auto it = lower_bound(b, e, arr[i]);\n    if (it == tail.begin() + length) {\n      tail[length++] = arr[i];\n    } else {\n      *it = arr[i];\n    }\n  }  \n  return length;  \n}\n
ll=using int64 = long long;\n
lli=using int64 = long long;\n
long=using int64 = long long;\n
lower_bound=template <typename T>\nint lower_bound(vector <T> arr, T x) {\n  int n = arr.size();\n  int l = 0;\n  int h = n; // Not n - 1\n  while (l < h) {\n    int mid = (l + h) / 2;\n    if (x <= arr[mid]) {\n      h = mid;\n    } else {\n      l = mid + 1;\n    }\n  }\n  return l;\n  //returns position of lower_bound\n}\n
lps=vector <int> calc_lps(const string &pat) {\n  int n = pat.length();\n  vector <int> lps(n, 0);\n  int len = 0;\n  lps[0] = len;\n  for (int i = 1; i < n; i++) {\n    while (len > 0 && pat[len] != pat[i]) {\n      len = lps[len - 1];\n    }\n    if (pat[len] == pat[i]) {\n      len++;\n    }\n    lps[i] = len;\n  }\n  return lps;\n  //..lps[i] = the longest proper prefix of pat[0..i] which is also a suffix of pat[0..i].\n}\n
lucas=/// calculate nCk mod module with n, k is large number ~ 10^18, module is small number ~ 10^6\nstruct LucasTheorem {\n  long long mod;\n  vector<long long> fact, inv_fact;\n  const int limits = 4;\n  LucasTheorem(long long _mod) {\n    mod = _mod;\n    fact.assign(mod + 7, 0);\n    inv_fact.assign(mod + 7, 0);\n    fact[0] = 1;\n    for (int i = 1; i < mod; i++) {\n      fact[i] = fact[i - 1] * i % mod;\n    }\n    inv_fact[mod - 1] = inverse(fact[mod - 1]);\n    for (int i = mod - 2; i >= 0; i--) {\n      inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod;\n    }\n  }\n  long long power(long long b, long long e) {\n    long long res = 1;\n    b %= mod;\n    for (; e; e >>= 1, b = b * b % mod) {\n      if (e & 1) res = res * b % mod;\n    }\n    return res;\n  }\n\n  long long inverse(long long a) {\n    return power(a, mod - 2);\n  }\n  vector<int> modRepresent(long long n) {\n    vector<int> res;\n    while (n) {\n      res.push_back(n % mod);\n      n /= mod;\n    }\n    while (res.size() < limits) res.push_back(0);\n    return res;\n  }\n  long long nCk(long long n, long long k) {\n    if (k > n) return 0;\n    long long res = fact[n] * inv_fact[k] % mod;\n    res = res * inv_fact[n - k] % mod;\n    return res;\n  }\n  long long mod_nCk(long long n, long long k) {\n    vector<int> repN = modRepresent(n);\n    vector<int> repK = modRepresent(k);\n    long long res = 1;\n    for (int i = 0; i < limits; i++) {\n      res = res * nCk(repN[i], repK[i]) % mod;\n    }\n    return res;\n  }\n};\n
main=import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Main {\n  \n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    Task solver = new Task();\n    solver.solve(in, out);\n    out.close();\n  }\n\n  static class Task {\n    public void solve(InputReader in, PrintWriter out) {\n      int n;\n      out.print("Enter a number : ");\n      n = in.nextInt();\n      out.println("You entered " + n);\n      return;\n    }  \n  }\n\n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream), 32768);\n      tokenizer = null;\n    }\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n  }\n}\n
manacher=template <typename T>\nvector<int> manacher(int n, const T &s) {\n  if (n == 0) {\n    return vector<int>();\n  }\n  vector<int> res(2 * n - 1, 0);\n  int l = -1, r = -1;\n  for (int z = 0; z < 2 * n - 1; z++) {\n    int i = (z + 1) >> 1;\n    int j = z >> 1;\n    int p = (i >= r ? 0 : min(r - i, res[2 * (l + r) - z]));\n    while (j + p + 1 < n && i - p - 1 >= 0) {\n      if (!(s[j + p + 1] == s[i - p - 1])) {\n        break;\n      }\n      p++;\n    }\n    if (j + p > r) {\n      l = i - p;\n      r = j + p;\n    }\n    res[z] = p;\n  }\n  return res;\n}\n \ntemplate <typename T>\nvector<int> manacher(const T &s) {\n  return manacher((int) s.size(), s);\n}\n\n// based on ideserve youtube channel\n// a   b   c   d   e\n// 0 1 2 3 4 5 6 7 8 9\ntemplate <typename T>\nvector<int> manacher(const T &s) {\n  int n = (int) s.length();\n  vector<int> lps(n, 0);\n  int c = 0, r = 0;\n  for (int i = 1; i < n; i++) {\n    if (r > i) {\n      lps[i] = min(r - i, lps[c - (c - i)]);\n    }\n    while (i + (lps[i] + 1) < n && i - (lps[i] + 1) >= 0) {\n      if (s[i + (lps[i] + 1)] !=  s[i - (lps[i] + 1)]) {\n        break;\n      }\n      lps[i]++; \n    } \n    if (i + lps[i] > r) {\n      c = i;\n      r = i + lps[i];\n    } \n  }\n  return lps; \n}\n\npair <int, int> Odd(vector <int>& lps, int i) {\n  int l = i - lps[2 * i] / 2;\n  int r = i + lps[2 * i] / 2;\n  return make_pair(l, r);            \n}\n\npair <int, int> Even(vector <int>& lps, int i) {\n  if (lps[2 * i + 1] > 0) {\n    int l = i - (lps[2 * i + 1] - 1) / 2;\n    int r = i + (lps[2 * i + 1] - 1) / 2 + 1;\n    return make_pair(l, r);\n  }\n  return make_pair(-1, -1);\n};\n\n\n//Mine\nvoid manacher(const string& str) {\n  int idx = 0;\n  int len = 2 * (int) str.length() + 1;\n  vector <char> arr(len);\n  //arr looks like : $b$a$b.....$\n\n  for (int i = 0; i < len; i++) {\n    if (i % 2 != 0) {\n      arr[i] = str[idx++];\n    } else {\n      arr[i] = '$';\n    }\n  }\n                               \n  vector <int> lps(len, 0);\n  int l = 0;\n  int h = 0;\n  //here m is the center.\n  for (int m = 0; m < len; ) {\n    while (l > 0 && h < len - 1 && arr[l - 1] == arr[h + 1]) {\n      l--;\n      h++;\n    }\n    lps[m] = h - l + 1;\n\n    if (h == len - 1) {\n      //we could simply break here if remaining lps is not required\n      for (int j = m + 1; j <= h; j++) {\n        lps[j] = min(lps[m - (j - m)], 2 * (h - j) + 1);\n      }    \n      break;\n    }\n\n    //center : even m => h + 1, odd m => h\n    int center = h + 1; //(m % 2 == 0 ? 1 : 0);\n    for (int j = m + 1; j <= h; j++) {\n      lps[j] = min(lps[m - (j - m)], 2 * (h - j) + 1);\n      if (j + lps[m - (j - m)] / 2 == h) {\n        center = j;\n        break;\n      }\n    }\n\n    m = center;\n    h = m + lps[m] / 2;\n    l = m - lps[m] / 2;\n  }\n\n  vector <int> even; \n  vector <int> odd;\n\n  //lps value of last '$' is useless\n  //for even count mid taken at left of i\n      \n  for (int i = 0; i < len - 1; i++) {\n    if (i % 2 == 0) even.push_back(lps[i] / 2);\n    else odd.push_back(lps[i] / 2);\n  } \n\n  //form longest palindromic substring \n  int cnt = INT_MIN;\n  int from = 0;\n  for (int i = 0; i < len; i++) {\n    int val = lps[i];\n    if (val > cnt) {\n      cnt = val;\n      from = i;\n    } \n  }\n  \n  //form longest palindromic substring\n  int s = from - cnt / 2;\n  int e = from + cnt / 2;\n  string ans;\n  for (int i = s; i <= e; i++) {\n    if (arr[i] == '$') continue;\n    ans.push_back(arr[i]);\n  } \n  cout << ans << endl;\n}\n
mat=for (int i = 0; i < n; i++) {\n  for (int j = 0; j < m; j++) {\n  \n  } \n} \n
mat_sum=auto get = [&](int x, int y, int xx, int yy) {\n  int h = mat[xx][yy];\n  int l = 0;\n  l += x - 1 >= 0 ? mat[x - 1][yy] : 0;\n  l += y - 1 >= 0 ? mat[xx][y - 1] : 0;\n  l -= (x - 1 >= 0 && y - 1 >= 0) ? mat[x - 1][y - 1] : 0;\n  return h - l; \n};\n
matching=/**\n1) Initialize Maximal Matching M as empty.\n2) While there exists an Augmenting Path p\n     Remove matching edges of p from M and add not-matching edges of p to M\n     (This increases size of M by 1 as p starts and ends with a free vertex)\n3) Return M. \nverified agaist AOJ GRL_7_A\n*/\n/*\nclass Graph {\nprivate:\n  int L;\n  int R;\n  vector <vector <int>> adj;\n  vector <int> level;\n  vector <int> mate;\n  bool levelize();\n  bool dfs(int u);\n\npublic:\n  Graph(int L, int R);    \n  void addEdge(int u, int v);\n  int matching(); \n};\n\nGraph::Graph(int L, int R) {\n  this->L = L;\n  this->R = R;\n  adj.resize(L + R);\n  level.resize(L);\n  mate.resize(L + R);\n}\n\n\nvoid Graph::addEdge(int u, int v) {\n  adj[u].push_back(v + L);\n  adj[v + L].push_back(u);\n}\n\nbool Graph::levelize() {\n  queue <int> q;\n  for (int u = 0; u < L; u++) {\n    level[u] = -1;\n    if (mate[u] == -1) {\n      level[u] = 0;\n      q.push(u);\n    }\n  }\n         \n  while (!q.empty()) {\n    int u = q.front();\n    q.pop();\n\n    for (int w : adj[u]) {\n      int v = mate[w];\n      if (v == -1) {\n        return true;\n      }\n\n      if (level[v] == -1) {\n        level[v] = level[u] + 1;\n        q.push(v);\n      } \n    }\n  }\n  return false;\n}\n\nbool Graph::dfs(int u) {\n  for (int w : adj[u]) {\n    int v = mate[w];\n    if (v == -1 || (level[v] == level[u] + 1 && dfs(v))) {\n      mate[u] = w;\n      mate[w] = u;\n      return true;\n    }\n  }\n\n  return false;\n}\n\nint Graph::matching() {\n  int match = 0;\n  fill(mate.begin(), mate.end(), -1);\n\n  while (levelize()) {\n    for (int u = 0; u < L; u++) {\n      if (mate[u] == -1 && dfs(u)) {\n        match++;\n      }\n    }\n  }\n  return match; \n} \n\nint main() {\n  int L, R, E;\n  cin >> L >> R >> E;\n  int u, v; \n  Graph g(L, R);\n  for (int i = 0; i < E; i++) {\n    cin >> u >> v;\n    g.addEdge(u, v);\n  }\n  cout << g.matching() << '\n';\n  return 0;\n} \n*/\n\n//Hoftcoft-Karp Mathing Algorithm\nclass matching {\n public:\n  vector<vector<int>> g;\n  vector<int> pa;\n  vector<int> pb;\n  vector<int> was;\n  int n, m;\n  int res;\n  int iter;\n \n  matching(int _n, int _m) : n(_n), m(_m) {\n    assert(0 <= n && 0 <= m);\n    pa = vector<int>(n, -1);\n    pb = vector<int>(m, -1);\n    was = vector<int>(n, 0);\n    g.resize(n);\n    res = 0;\n    iter = 0;\n  }\n \n  void add(int from, int to) {\n    assert(0 <= from && from < n && 0 <= to && to < m);\n    g[from].push_back(to);\n  }\n \n  bool dfs(int v) {\n    was[v] = iter;\n    for (int u : g[v]) {\n      if (pb[u] == -1) {\n        pa[v] = u;\n        pb[u] = v;\n        return true;\n      }\n    }\n    for (int u : g[v]) {\n      if (was[pb[u]] != iter && dfs(pb[u])) {\n        pa[v] = u;\n        pb[u] = v;\n        return true;\n      }\n    }\n    return false;\n  }\n \n  int solve() {\n    while (true) {\n      iter++;\n      int add = 0;\n      for (int i = 0; i < n; i++) {\n        if (pa[i] == -1 && dfs(i)) {\n          add++;\n        }\n      }\n      if (add == 0) {\n        break;\n      }\n      res += add;\n    }\n    return res;\n  }\n \n  int run_one(int v) {\n    if (pa[v] != -1) {\n      return 0;\n    }\n    iter++;\n    return (int) dfs(v);\n  }\n};\n
matrix=template <typename T> \nstring to_string(vector <vector<T>> &mat) {\n  string res = "";\n  char temp[32];\n  int n = mat.size();\n  if (n == 0) return res;\n  res += "\n";\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < (int) mat[i].size(); j++) {\n      sprintf(temp, "%-2s", to_string(mat[i][j]).c_str());\n      res += string(temp);\n    }\n    res += "\n";\n  }\n  return res;\n}\n
max=#define max(...) max({__VA_ARGS__})\n
max_flow=/*\n// ..Mine\nusing Dinic's maxflow (V * V * E) uses BFS : dinic\nusing push-relabel method (V * V * E) : push_relabel\nusing Ford-Fulkerson maxflow (E * F) uses DFS : ford_fulkerson\nusing Endmond-Karp (V * E * E) uses BFS : endmond_karp\n*/\n\ntemplate <typename T>\nclass flow_graph {\n public:\n  static constexpr T eps = (T) 1e-9;\n \n  struct edge {\n    int from;\n    int to;\n    T c;\n    T f;\n  };\n \n  vector<vector<int>> g;\n  vector<edge> edges;\n  int n;\n  int st;\n  int fin;\n  T flow;\n \n  flow_graph(int _n, int _st, int _fin) : n(_n), st(_st), fin(_fin) {\n    assert(0 <= st && st < n && 0 <= fin && fin < n && st != fin);\n    g.resize(n);\n    flow = 0;\n  }\n \n  void clear_flow() {\n    for (const edge &e : edges) {\n      e.f = 0;\n    }\n    flow = 0;\n  }\n   \n  int add(int from, int to, T forward_cap, T backward_cap) {\n    assert(0 <= from && from < n && 0 <= to && to < n);\n    int id = (int) edges.size();\n    g[from].push_back(id);\n    edges.push_back({from, to, forward_cap, 0});\n    g[to].push_back(id + 1);\n    edges.push_back({to, from, backward_cap, 0});\n    return id;\n  }\n};\n \ntemplate <typename T>\nclass dinic {\n public:\n  flow_graph<T> &g;\n \n  vector<int> ptr;\n  vector<int> d;\n  vector<int> q;\n \n  dinic(flow_graph<T> &_g) : g(_g) {\n    ptr.resize(g.n);\n    d.resize(g.n);\n    q.resize(g.n);\n  }\n \n  bool expath() {\n    fill(d.begin(), d.end(), -1);\n    q[0] = g.fin;\n    d[g.fin] = 0;\n    int beg = 0, end = 1;\n    while (beg < end) {\n      int i = q[beg++];\n      for (int id : g.g[i]) {\n        const auto &e = g.edges[id];\n        const auto &back = g.edges[id ^ 1];\n        if (back.c - back.f > g.eps && d[e.to] == -1) {\n          d[e.to] = d[i] + 1;\n          if (e.to == g.st) {\n            return true;\n          }\n          q[end++] = e.to;\n        }\n      }\n    }\n    return false;\n  }\n   \n  T dfs(int v, T w) {\n    if (v == g.fin) {\n      return w;\n    }\n    int &j = ptr[v];\n    while (j >= 0) {\n      int id = g.g[v][j];\n      const auto &e = g.edges[id];\n      if (e.c - e.f > g.eps && d[e.to] == d[v] - 1) {\n        T t = dfs(e.to, min(e.c - e.f, w));\n        if (t > g.eps) {\n          g.edges[id].f += t;\n          g.edges[id ^ 1].f -= t;\n          return t;\n        }\n      }\n      j--;\n    }\n    return 0;\n  }\n \n  T max_flow() {\n    while (expath()) {\n      for (int i = 0; i < g.n; i++) {\n        ptr[i] = (int) g.g[i].size() - 1;\n      }\n      T big_add = 0;\n      while (true) {\n        T add = dfs(g.st, numeric_limits<T>::max());\n        if (add <= g.eps) {\n          break;\n        }\n        big_add += add;\n      }\n      if (big_add <= g.eps) {\n        break;\n      }\n      g.flow += big_add;\n    }\n    return g.flow;\n  }\n \n  vector<bool> min_cut() {\n    max_flow();\n    vector<bool> ret(g.n);\n    for (int i = 0; i < g.n; i++) {\n      ret[i] = (d[i] != -1);\n    }\n    return ret;\n  }\n};\n
mcmf=template <typename T, typename C>\nclass MCMF {\n public:\n  static constexpr T eps = (T) 1e-9;\n \n  struct edge {\n    int from;\n    int to;\n    T c;\n    T f;\n    C cost;\n  };\n \n  int n;\n  vector<vector<int>> g;\n  vector<edge> edges;\n  vector<C> d;\n  vector<C> pot;\n  __gnu_pbds::priority_queue<pair<C, int>> q;\n  vector<typename decltype(q)::point_iterator> its;\n  vector<int> pe;\n  const C INF_C = numeric_limits<C>::max() / 2;\n \n  explicit MCMF(int n_) : n(n_), g(n), d(n), pot(n, 0), its(n), pe(n) {}\n \n  int add(int from, int to, T forward_cap, T backward_cap, C edge_cost) {\n    assert(0 <= from && from < n && 0 <= to && to < n);\n    assert(forward_cap >= 0 && backward_cap >= 0);\n    int id = static_cast<int>(edges.size());\n    g[from].push_back(id);\n    edges.push_back({from, to, forward_cap, 0, edge_cost});\n    g[to].push_back(id + 1);\n    edges.push_back({to, from, backward_cap, 0, -edge_cost});\n    return id;\n  }\n \n  void expath(int st) {\n    fill(d.begin(), d.end(), INF_C);\n    q.clear();\n    fill(its.begin(), its.end(), q.end());\n    its[st] = q.push({pot[st], st});\n    d[st] = 0;\n    while (!q.empty()) {\n      int i = q.top().second;\n      q.pop();\n      its[i] = q.end();\n      for (int id : g[i]) {\n        const edge &e = edges[id];\n        int j = e.to;\n        if (e.c - e.f > eps && d[i] + e.cost < d[j]) {\n          d[j] = d[i] + e.cost;\n          pe[j] = id;\n          if (its[j] == q.end()) {\n            its[j] = q.push({pot[j] - d[j], j});\n          } else {\n            q.modify(its[j], {pot[j] - d[j], j});\n          }\n        }\n      }\n    }\n    swap(d, pot);\n  }\n   \n  pair<T, C> max_flow_min_cost(int st, int fin) {\n    T flow = 0;\n    C cost = 0;\n    bool ok = true;\n    for (auto& e : edges) {\n      if (e.c - e.f > eps && e.cost + pot[e.from] - pot[e.to] < 0) {\n        ok = false;\n        break;\n      }\n    }\n    if (ok) {\n      expath(st);\n    } else {\n      vector<int> deg(n, 0);\n      for (int i = 0; i < n; i++) {\n        for (int eid : g[i]) {\n          auto& e = edges[eid];\n          if (e.c - e.f > eps) {\n            deg[e.to] += 1;\n          }\n        }\n      }\n      vector<int> que;\n      for (int i = 0; i < n; i++) {\n        if (deg[i] == 0) {\n          que.push_back(i);\n        }\n      }\n      for (int b = 0; b < (int) que.size(); b++) {\n        for (int eid : g[que[b]]) {\n          auto& e = edges[eid];\n          if (e.c - e.f > eps) {\n            deg[e.to] -= 1;\n            if (deg[e.to] == 0) {\n              que.push_back(e.to);\n            }\n          }\n        }\n      }\n      fill(pot.begin(), pot.end(), INF_C);\n      pot[st] = 0;\n      if (static_cast<int>(que.size()) == n) {\n        for (int v : que) {\n          if (pot[v] < INF_C) {\n            for (int eid : g[v]) {\n              auto& e = edges[eid];\n              if (e.c - e.f > eps) {\n                if (pot[v] + e.cost < pot[e.to]) {\n                  pot[e.to] = pot[v] + e.cost;\n                  pe[e.to] = eid;\n                }\n              }\n            }\n          }\n        }\n      } else {\n        que.assign(1, st);\n        vector<bool> in_queue(n, false);\n        in_queue[st] = true;\n        for (int b = 0; b < (int) que.size(); b++) {\n          int i = que[b];\n          in_queue[i] = false;\n          for (int id : g[i]) {\n            const edge &e = edges[id];\n            if (e.c - e.f > eps && pot[i] + e.cost < pot[e.to]) {\n              pot[e.to] = pot[i] + e.cost;\n              pe[e.to] = id;\n              if (!in_queue[e.to]) {\n                que.push_back(e.to);\n                in_queue[e.to] = true;\n              }\n            }\n          }\n        }\n      }\n    }\n    while (pot[fin] < INF_C) {\n      T push = numeric_limits<T>::max();\n      int v = fin;\n      while (v != st) {\n        const edge &e = edges[pe[v]];\n        push = min(push, e.c - e.f);\n        v = e.from;\n      }\n      v = fin;\n      while (v != st) {\n        edge &e = edges[pe[v]];\n        e.f += push;\n        edge &back = edges[pe[v] ^ 1];\n        back.f -= push;\n        v = e.from;\n      }\n      flow += push;\n      cost += push * pot[fin];\n      expath(st);\n    }\n    return {flow, cost};\n  }\n};\n\n\n/*\n * initial implementation\n\ntemplate <typename T, typename C>\nclass mcmf {\n public:\n  static constexpr T eps = (T) 1e-9;\n \n  struct edge {\n    int from;\n    int to;\n    T c;\n    T f;\n    C cost;\n  };\n \n  vector<vector<int>> g;\n  vector<edge> edges;\n  vector<C> d;\n  vector<int> q;\n  vector<bool> in_queue;\n  vector<int> pe;\n  int n;\n  int st, fin;\n  T flow;\n  C cost;\n \n  mcmf(int _n, int _st, int _fin) : n(_n), st(_st), fin(_fin) {\n    assert(0 <= st && st < n && 0 <= fin && fin < n && st != fin);\n    g.resize(n);\n    d.resize(n);\n    in_queue.resize(n);\n    pe.resize(n);\n    flow = 0;\n    cost = 0;\n  }\n \n  void clear_flow() {\n    for (const edge &e : edges) {\n      e.f = 0;\n    }\n    flow = 0;\n  }\n   \n  void add(int from, int to, T forward_cap, T backward_cap, C cost) {\n    assert(0 <= from && from < n && 0 <= to && to < n);\n    g[from].push_back((int) edges.size());\n    edges.push_back({from, to, forward_cap, 0, cost});\n    g[to].push_back((int) edges.size());\n    edges.push_back({to, from, backward_cap, 0, -cost});\n  }\n \n  bool expath() {\n    fill(d.begin(), d.end(), numeric_limits<C>::max());\n    q.clear();\n    q.push_back(st);\n    d[st] = 0;\n    in_queue[st] = true;\n    int beg = 0;\n    bool found = false;\n    while (beg < (int) q.size()) {\n      int i = q[beg++];\n      if (i == fin) {\n        found = true;\n      }\n      in_queue[i] = false;\n      for (int id : g[i]) {\n        const edge &e = edges[id];\n        if (e.c - e.f > eps && d[i] + e.cost < d[e.to]) {\n          d[e.to] = d[i] + e.cost;\n          pe[e.to] = id;\n          if (!in_queue[e.to]) {\n            q.push_back(e.to);\n            in_queue[e.to] = true;\n          }\n        }\n      }\n    }\n    if (found) {\n      T push = numeric_limits<T>::max();\n      int v = fin;\n      while (v != st) {\n        const edge &e = edges[pe[v]];\n        push = min(push, e.c - e.f);\n        v = e.from;\n      }\n      v = fin;\n      while (v != st) {\n        edge &e = edges[pe[v]];\n        e.f += push;\n        edge &back = edges[pe[v] ^ 1];\n        back.f -= push;\n        v = e.from;\n      }\n      flow += push;\n      cost += push * d[fin];\n    }\n    return found;\n  }\n   \n  pair<T, C> max_flow_min_cost() {\n    while (expath()) {}\n    return {flow, cost};\n  }\n};\n* /\n
merge=template <typename T>\nvector <pair <T, T>> merge(vector<pair<T, T>> &gap) {\n  int n = gap.size();\n  vector <pair <T, T> > ans;\n  sort(gap.begin(), gap.end());  \n  T l = gap[0].first, h = gap[0].second;\n  for (int i = 0; i< n; i++) {\n    if (gap[i].first <= h) {\n      h = max(h, gap[i].second);\n    } else {\n      ans.push_back(make_pair(l, h));\n      l = gap[i].first, h = gap[i].second;\n    } \n  }\n  ans.push_back(make_pair(l, h));\n  return ans;  \n  //returns the merged intervals in sorted order\n}\n
min=#define min(...) min({__VA_ARGS__})\n
mint=template <typename T>\nT power(T a, long long b) {\n  T r = 1;\n  while (b > 0) {\n    if (b & 1) {\n      r *= a;\n    }\n    a *= a;\n    b >>= 1;\n  }\n  return r;\n}\n \ntemplate <typename T>\nT inverse(T a, T m) {\n  a %= m;\n  if (a < 0) {\n    a += m;\n  }\n  T b = m, u = 0, v = 1;\n  while (a) {\n    T t = b / a;\n    b -= a * t;\n    swap(a, b);\n    u -= v * t;\n    swap(u, v);\n  }\n  if (u < 0) {\n    u += m;\n  }\n  return u;\n}\n \ntemplate <int _P>\nstruct modnum {\n  static constexpr int P = _P;\n private:\n  int v;\n public:\n  modnum() : v(0) { }\n  modnum(long long _v) {\n    v = (int) (_v % P);\n    if (v < 0) {\n      v += P;\n    }\n  }\n  explicit operator int() const {\n    return v;\n  }\n  bool operator==(const modnum& o) const {\n    return v == o.v;\n  }\n  bool operator!=(const modnum& o) const {\n    return v != o.v;\n  }\n  modnum inverse() const {\n    return modnum(::inverse(v, P));\n  }\n  modnum operator-() const {\n    return modnum(v ? P - v : 0);\n  }\n  modnum operator+() const {\n    return *this;\n  }\n  modnum& operator++() {\n    v++;\n    if (v == P) {\n      v = 0;\n    }\n    return *this;\n  }\n  modnum& operator--() {\n    if (v == 0) {\n      v = P;\n    }\n    v--;\n    return *this;\n  }\n  modnum operator++(int) {\n    modnum r = *this;\n    ++*this;\n    return r;\n  }\n  modnum operator--(int) {\n    modnum r = *this;\n    --*this;\n    return r;\n  }\n  modnum& operator+=(const modnum& o) {\n    v += o.v;\n    if (v >= P) {\n      v -= P;\n    }\n    return *this;\n  }\n  modnum operator+(const modnum& o) const {\n    return modnum(*this) += o;\n  }\n  modnum& operator-=(const modnum& o) {\n    v -= o.v;\n    if (v < 0) {\n      v += P;\n    }\n    return *this;\n  }\n  modnum operator-(const modnum& o) const {\n    return modnum(*this) -= o;\n  }\n  modnum& operator*=(const modnum& o) {\n    v = (int) ((long long) v * o.v % P);\n    return *this;\n  }\n  modnum operator*(const modnum& o) const {\n    return modnum(*this) *= o;\n  }\n  modnum& operator/=(const modnum& o) {\n    return *this *= o.inverse();\n  }\n  modnum operator/(const modnum& o) const {\n    return modnum(*this) /= o;\n  }\n};\n\ntemplate <int _P>\nstring to_string(const modnum<_P>& n) {\n  return to_string((int)n);\n}\n \ntemplate <int _P>\nostream& operator<<(ostream& out, const modnum<_P>& n) {\n  return out << int(n);\n}\n \ntemplate <int _P>\nistream& operator>>(istream& in, modnum<_P>& n) {\n  long long _v;\n  in >> _v;\n  n = modnum<_P>(_v);\n  return in;\n}\n\nconst int mod = (int) (1e9 + 7); \nusing mint = modnum<mod>;\n
mo=struct query {\n  int when;\n  int L;\n  int H;\n};\n\ntemplate <typename T>\nclass mo {\n public:\n  map <int, int> mp...\n  set <int> st...\n  vector <int> fre...\n  int ans = ...\n  inline void _init() {\n    ..init above variables\n  }  \n  inline void add(int i) {\n    ...add arr[i]\n  }\n\n  inline void rem(int i) {\n    ...remove arr[i]\n  }\n  inline ... get() {\n    ... get answer\n  } \n\n  vector <T> arr;\n  int size;\n\n  mo(vector <T> &_arr) {\n    arr = _arr;\n    int n = _arr.size();\n    size = (int) sqrt(n + 0.1) + 1;\n  } \n  \n  vector <...> get(vector <query>& queries) {  \n    int qq = queries.size();\n    int n = arr.size();\n    auto comp = [&](auto &a, auto &b) ->bool {\n      int ax = a.L / size;\n      int bx = b.L / size;\n      if (ax == bx) {\n        return a.H < b.H;\n      }  \n      return ax < bx;\n    };\n    sort(queries.begin(), queries.end(), comp);\n    int L = 0, H = -1;\n    vector <...> ret(qq);\n    _init();\n    for (query &q : queries) {\n      assert(0 <= q.L && q.L < n && 0 <= q.H && q.H < n);\n      while (L > q.L) { L--; add(L); }\n      while (H < q.H) { H++; add(H); }\n      while (L < q.L) { rem(L); L++; }\n      while (H > q.H) { rem(H); H--; }\n      ret[q.when] = get();\n    }\n    return ret;\n  } \n};\n\n...mo<int> m(arr)\n...vector <...> ans = m.get(queries);\n
mod=const int mod = (int) (1e9 + 7);\n
modi=/*for mod not prime, but a and mod are co-prime\ninline int inv(int a, int md) {\n  a %= md;\n  if (a < 0) a += md;\n  int b = md, u = 0, v = 1;\n  while (a) {\n    int t = b / a;\n    b -= t * a; swap(a, b);\n    u -= t * v; swap(u, v);\n  }\n  assert(b == 1);\n  if (u < 0) u += md;\n  return u;\n}\n\n//OR\nint inv(int a, int md) {\n  int x, y;\n  int g = extended_gcd(a, md, x, y);\n  if (g != 1) {\n    cerr << "No inverse exists" << endl;\n    return 0;\n  } else {\n    x = (x % md + md) % md;\n    return x;\n  }  \n} \n*/\n
mst=//prims spanning tree. very much similar to dijkstra\ntemplate <typename T>\nvector <int> mst(const undigraph<T> &g, T &ans) {\n  priority_queue<pair<T, int>, vector<pair<T, int> >, greater<pair<T, int> > > s;\n  vector<T> dist(g.n, numeric_limits<T>::max());\n  vector <bool> seen(g.n, false);\n  vector <int> ans_list(g.n - 1);\n  \n  int start = 0;\n  dist[start] = 0;\n  s.emplace(dist[start], start);\n  while (!s.empty()) {\n    pair <T, int> pr = s.top(); \n    s.pop();\n    int u = pr.second;\n    seen[u] = true;\n    for (int id : g.g[u]) {\n      auto &e = g.edges[id];\n      int v = e.from ^ e.to ^ u;\n      if (!seen[v] && e.cost < dist[v]) {\n        dist[v] = e.cost;\n        ans_list[v - 1] = id;\n        s.emplace(dist[v], v);\n      } \n    }\n  }\n\n  ans = 0;\n  for (int i = 0; i < g.n; i++) {\n    ans += dist[i];\n  } \n  return ans_list;\n  //returns edge ids of minimum "spanning" forest\n}\n\n//kruskal's mst using disjoint set union\ntemplate <typename T>\nvector<int> mst(const undigraph<T> &g, T &ans) {\n  vector<int> order(g.edges.size());\n  iota(order.begin(), order.end(), 0);\n  sort(order.begin(), order.end(), [&g](int a, int b) {\n    return g.edges[a].cost < g.edges[b].cost;\n  });\n  dsu d(g.n);\n  vector<int> ans_list;\n  ans = 0;\n  for (int id : order) {\n    auto &e = g.edges[id];\n    if (d.get(e.from) != d.get(e.to)) {\n      d.unite(e.from, e.to);\n      ans_list.push_back(id);\n      ans += e.cost;\n    }\n  }\n  return ans_list;\n  //returns edge ids of minimum "spanning" forest\n}\n \n
mul=inline int mul(int a, int b) {\n  long long res = (long long) a * b;\n  a = (int) (res % mod);\n  if (a < 0) {\n    a += mod;\n  }\n  return a;\n}\n
ncr=//..ncr table for variable n and r\nconst int N = ...;\nint C[N + 1][N + 1];\nint calc_C() {\n  C[0][0] = 1;\n  for (int n = 1; n <= N; n++) {\n    C[n][0] = C[n][n] = 1;\n    for (int k = 1; k < n; k++) {\n      C[n][k] = C[n - 1][k - 1] + C[n - 1][k];\n    }\n  }\n}\n\n//..ncr table for fixed n and variable r\nconst int N = ...;\nint C[N + 1];\nvoid calc_C(int n = N) {\n  memset(C, 0, sizeof(C));\n  C[0] = 1; \n  for (int i = 1; i <= n; i++) {\n    for (int j = i; j > 0; j--) {\n      C[j] = C[j] + C[j - 1];\n    }\n  }\n} \n\n\n//..ncr value for specific n and specific r\ninline int C(int n, int r) {\n  if (r < 0 || r > n) {\n    return 0;\n  }\n  r = min(r, n - r);\n  int res = 1;\n  for (int i = 0; i < r; i++) {\n    res *= (n - i);\n    res /= (i + 1);\n  }\n  return res;\n}\n\n//..under mod using ncr = n! / ((n - r) ! * r!)\ntemplate< typename T >\nclass combination {\n public:\n  vector <T> fact;\n  vector <T> ifact;\n  combination(int N) : fact(N + 1), ifact(N + 1) {\n    fact[0] = 1;\n    for (int i = 1; i <= N; i++) {\n      fact[i] = fact[i - 1] * i;\n    }\n    ifact[N] = 1 / fact[N];\n    for (int i = N - 1; i >= 0; i--) {\n      ifact[i] = ifact[i + 1] * (i + 1);\n    }\n  } \n  T P(int n, int r) const {\n    if (r < 0 || n < r) return 0;\n    return fact[n] * ifact[n - r];\n  }\n \n  T C(int n, int r) const {\n    if (r < 0 || n < r) return 0;\n    return fact[n] * ifact[r] * ifact[n - r];\n  }\n \n  T H(int n, int r) const {\n    if (n < 0 || r < 0) return 0;\n    return r == 0 ? 1 : C(n + r - 1, r);\n  }\n};\n
ninf=const int ninf = numeric_limits<int>::min();\n
nm=for (int i = 0; i < n; i++) {\n  for (int j = 0; j < m; j++) {\n    \n  } \n} \n
node=struct TreeNode {\n  int val;\n  TreeNode *left;\n  TreeNode *right;\n  TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nusing Node = TreeNode;\n
ntt=template <typename T>\nclass NTT {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n \n  static Type md;\n  static Modular<T> root;\n  static int base;\n  static int max_base;\n  static vector<Modular<T>> roots;\n  static vector<int> rev;\n \n  static void clear() {\n    root = 0;\n    base = 0;\n    max_base = 0;\n    roots.clear();\n    rev.clear();\n  }\n \n  static void init() {\n    md = T::value;\n    assert(md >= 3 && md % 2 == 1);\n    auto tmp = md - 1;\n    max_base = 0;\n    while (tmp % 2 == 0) {\n      tmp /= 2;\n      max_base++;\n    }\n    root = 2;\n    while (power(root, (md - 1) >> 1) == 1) {\n      root++;\n    }\n    assert(power(root, md - 1) == 1);\n    root = power(root, (md - 1) >> max_base);\n    base = 1;\n    rev = {0, 1};\n    roots = {0, 1};\n  }\n \n  static void ensure_base(int nbase) {\n    if (md != T::value) {\n      clear();\n    }\n    if (roots.empty()) {\n      init();\n    }\n    if (nbase <= base) {\n      return;\n    }\n    assert(nbase <= max_base);\n    rev.resize(1 << nbase);\n    for (int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    roots.resize(1 << nbase);\n    while (base < nbase) {\n      Modular<T> z = power(root, 1 << (max_base - 1 - base));\n      for (int i = 1 << (base - 1); i < (1 << base); i++) {\n        roots[i << 1] = roots[i];\n        roots[(i << 1) + 1] = roots[i] * z;\n      }\n      base++;\n    }\n  }\n \n  static void fft(vector<Modular<T>> &a) {\n    int n = (int) a.size();\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for (int i = 0; i < n; i++) {\n      if (i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for (int k = 1; k < n; k <<= 1) {\n      for (int i = 0; i < n; i += 2 * k) {\n        for (int j = 0; j < k; j++) {\n          Modular<T> x = a[i + j];\n          Modular<T> y = a[i + j + k] * roots[j + k];\n          a[i + j] = x + y;\n          a[i + j + k] = x - y;\n        }\n      }\n    }\n  }\n \n  static vector<Modular<T>> multiply(vector<Modular<T>> a, vector<Modular<T>> b) {\n    if (a.empty() || b.empty()) {\n      return {};\n    }\n    int eq = (a.size() == b.size() && a == b);\n    int need = (int) a.size() + (int) b.size() - 1;\n    int nbase = 0;\n    while ((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    a.resize(sz);\n    b.resize(sz);\n    fft(a);\n    if (eq) b = a; else fft(b);\n    Modular<T> inv_sz = 1 / static_cast<Modular<T>>(sz);\n    for (int i = 0; i < sz; i++) {\n      a[i] *= b[i] * inv_sz;\n    }\n    reverse(a.begin() + 1, a.end());\n    fft(a);\n    a.resize(need);\n    return a;\n  }\n};\n \ntemplate <typename T> typename NTT<T>::Type NTT<T>::md;\ntemplate <typename T> Modular<T> NTT<T>::root;\ntemplate <typename T> int NTT<T>::base;\ntemplate <typename T> int NTT<T>::max_base;\ntemplate <typename T> vector<Modular<T>> NTT<T>::roots;\ntemplate <typename T> vector<int> NTT<T>::rev;\n \ntemplate <typename T>\nvector<Modular<T>> inverse(vector<Modular<T>> a) {\n  int n = (int) a.size();\n  if (n == 1) {\n    return {1 / a[0]};\n  }\n  int m = (n + 1) >> 1;\n  vector<Modular<T>> b = inverse(vector<Modular<T>>(a.begin(), a.begin() + m));\n  int need = n << 1;\n  int nbase = 0;\n  while ((1 << nbase) < need) {\n    ++nbase;\n  }\n  NTT<T>::ensure_base(nbase);\n  int size = 1 << nbase;\n  a.resize(size);\n  b.resize(size);\n  NTT<T>::fft(a);\n  NTT<T>::fft(b);\n  Modular<T> inv = 1 / static_cast<Modular<T>>(size);\n  for (int i = 0; i < size; ++i) {\n    a[i] = (2 - a[i] * b[i]) * b[i] * inv;\n  }\n  reverse(a.begin() + 1, a.end());\n  NTT<T>::fft(a);\n  a.resize(n);\n  return a;\n}\n \ntemplate <typename T>\nvector<Modular<T>>& operator*=(vector<Modular<T>>& a, const vector<Modular<T>>& b) {\n  if (a.empty() || b.empty()) {\n    a.clear();\n  } else {\n    if (min(a.size(), b.size()) < 150) {\n      vector<Modular<T>> c = a;\n      a.assign(a.size() + b.size() - 1, 0);\n      for (int i = 0; i < (int) c.size(); i++) {\n        for (int j = 0; j < (int) b.size(); j++) {\n          a[i + j] += c[i] * b[j];\n        }\n      }\n    } else {\n      a = NTT<T>::multiply(a, b);\n    }\n  }\n  return a;\n}\n \ntemplate <typename T>\nvector<Modular<T>> operator*(const vector<Modular<T>>& a, const vector<Modular<T>>& b) {\n  vector<Modular<T>> c = a;\n  return c *= b;\n}\n \ntemplate <typename T>\nvector<T>& operator+=(vector<T>& a, const vector<T>& b) {\n  if (a.size() < b.size()) {\n    a.resize(b.size());\n  }\n  for (int i = 0; i < (int) b.size(); i++) {\n    a[i] += b[i];\n  }\n  return a;\n}\n \ntemplate <typename T>\nvector<T> operator+(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c += b;\n}\n \ntemplate <typename T>\nvector<T>& operator-=(vector<T>& a, const vector<T>& b) {\n  if (a.size() < b.size()) {\n    a.resize(b.size());\n  }\n  for (int i = 0; i < (int) b.size(); i++) {\n    a[i] -= b[i];\n  }\n  return a;\n}\n \ntemplate <typename T>\nvector<T> operator-(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c -= b;\n}\n \ntemplate <typename T>\nvector<T>& operator*=(vector<T>& a, const vector<T>& b) {\n  if (a.empty() || b.empty()) {\n    a.clear();\n  } else {\n    vector<T> c = a;\n    a.assign(a.size() + b.size() - 1, 0);\n    for (int i = 0; i < (int) c.size(); i++) {\n      for (int j = 0; j < (int) b.size(); j++) {\n        a[i + j] += c[i] * b[j];\n      }\n    }\n  }\n  return a;\n}\n \ntemplate <typename T>\nvector<T> operator*(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c *= b;\n}\n \ntemplate <typename T>\nvector<T> inverse(const vector<T>& a) {\n  assert(!a.empty());\n  int n = (int) a.size();\n  vector<T> b = {1 / a[0]};\n  while ((int) b.size() < n) {\n    vector<T> a_cut(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n    vector<T> x = b * b * a_cut;\n    b.resize(b.size() << 1);\n    for (int i = (int) b.size() >> 1; i < (int) min(x.size(), b.size()); i++) {\n      b[i] = -x[i];\n    }\n  }\n  b.resize(n);\n  return b;\n}\n \ntemplate <typename T>\nvector<T>& operator/=(vector<T>& a, const vector<T>& b) {\n  int n = (int) a.size();\n  int m = (int) b.size();\n  if (n < m) {\n    a.clear();\n  } else {\n    vector<T> d = b;\n    reverse(a.begin(), a.end());\n    reverse(d.begin(), d.end());\n    d.resize(n - m + 1);\n    a *= inverse(d);\n    a.erase(a.begin() + n - m + 1, a.end());\n    reverse(a.begin(), a.end());\n  }\n  return a;\n}\n \ntemplate <typename T>\nvector<T> operator/(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c /= b;\n}\n \ntemplate <typename T>\nvector<T>& operator%=(vector<T>& a, const vector<T>& b) {\n  int n = (int) a.size();\n  int m = (int) b.size();\n  if (n >= m) {\n    vector<T> c = (a / b) * b;\n    a.resize(m - 1);\n    for (int i = 0; i < m - 1; i++) {\n      a[i] -= c[i];\n    }\n  }\n  return a;\n}\n \ntemplate <typename T>\nvector<T> operator%(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c %= b;\n}\n \ntemplate <typename T, typename U>\nvector<T> power(const vector<T>& a, const U& b, const vector<T>& c) {\n  assert(b >= 0);\n  vector<U> binary;\n  U bb = b;\n  while (bb > 0) {\n    binary.push_back(bb & 1);\n    bb >>= 1;\n  }\n  vector<T> res = vector<T> {1} % c;\n  for (int j = (int) binary.size() - 1; j >= 0; j--) {\n    res = res * res % c;\n    if (binary[j] == 1) {\n      res = res * a % c;\n    }\n  }\n  return res;\n}\n \ntemplate <typename T>\nvector<T> derivative(const vector<T>& a) {\n  vector<T> c = a;\n  for (int i = 0; i < (int) c.size(); i++) {\n    c[i] *= i;    \n  }\n  if (!c.empty()) {\n    c.erase(c.begin());\n  }\n  return c;\n}\n \ntemplate <typename T>\nvector<T> primitive(const vector<T>& a) {\n  vector<T> c = a;\n  c.insert(c.begin(), 0);\n  for (int i = 1; i < (int) c.size(); i++) {\n    c[i] /= i;\n  }\n  return c;\n}\n \ntemplate <typename T>\nvector<T> logarithm(const vector<T>& a) {\n  assert(!a.empty() && a[0] == 1);\n  vector<T> u = primitive(derivative(a) * inverse(a));\n  u.resize(a.size());\n  return u;\n}\n \ntemplate <typename T>\nvector<T> exponent(const vector<T>& a) {\n  assert(!a.empty() && a[0] == 0);\n  int n = (int) a.size();\n  vector<T> b = {1};\n  while ((int) b.size() < n) {\n    vector<T> x(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n    x[0] += 1;\n    vector<T> old_b = b;\n    b.resize(b.size() << 1);\n    x -= logarithm(b);\n    x *= old_b;\n    for (int i = (int) b.size() >> 1; i < (int) min(x.size(), b.size()); i++) {\n      b[i] = x[i];\n    }\n  }\n  b.resize(n);\n  return b;\n}\n \ntemplate <typename T>\nvector<T> sqrt(const vector<T>& a) {\n  assert(!a.empty() && a[0] == 1);\n  int n = (int) a.size();\n  vector<T> b = {1};\n  while ((int) b.size() < n) {\n    vector<T> x(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n    vector<T> old_b = b;\n    b.resize(b.size() << 1);\n    x *= inverse(b);\n    T inv2 = 1 / static_cast<T>(2);\n    for (int i = (int) b.size() >> 1; i < (int) min(x.size(), b.size()); i++) {\n      b[i] = x[i] * inv2;\n    }\n  }\n  b.resize(n);\n  return b;\n}\n
orientation=const int L = -1;\nconst int S =  0;\nconst int R =  1; \nint orientation(const point &p, const point &q, const point &r) { \n  int val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y); \n  if (val == 0) return S;\n  return (val > 0) ? R : L;\n} \n
pal=bool can_palin(const string &str, int n) {\n  vector <int> fre(26, 0);\n  for (int i = 0; i < n; i++) {\n    fre[str[i] - 'a']++;\n  }\n  pair <char, int> odd = {'0', 0};\n  for (int i = 0; i < 26; i++) {\n    if (fre[i] > 0) {\n      if (fre[i] % 2 == 1) {\n        if (odd.second == 0) {\n          odd.second = 1;\n          odd.first = (char)(i + 'a');\n        } else {\n          return false;\n        } \n      }\n    } \n  }\n  if (odd.second == 1) {\n    if (n % 2 == 0) return false; \n  } \n  return true;\n}\n\ntemplate <typename T>\nbool palin(const string &T) {\n  int n = s.size();\n  for (int i = 0; i < n / 2; i++) {\n    int j = n - i - 1;\n    if (s[i] != s[j]) return false;\n  } \n  return true;\n} \n
palin=bool can_palin(const string &str, int n) {\n  vector <int> fre(26, 0);\n  for (int i = 0; i < n; i++) {\n    fre[str[i] - 'a']++;\n  }\n  pair <char, int> odd = {'0', 0};\n  for (int i = 0; i < 26; i++) {\n    if (fre[i] > 0) {\n      if (fre[i] % 2 == 1) {\n        if (odd.second == 0) {\n          odd.second = 1;\n          odd.first = (char)(i + 'a');\n        } else {\n          return false;\n        } \n      }\n    } \n  }\n  if (odd.second == 1) {\n    if (n % 2 == 0) return false; \n  } \n  return true;\n}\n\ntemplate <typename T>\nbool palin(const T &s) {\n  int n = s.size();\n  for (int i = 0; i < n / 2; i++) {\n    int j = n - i - 1;\n    if (s[i] != s[j]) return false;\n  } \n  return true;\n} \n
palindrome=bool can_palin(const string &str, int n) {\n  vector <int> fre(26, 0);\n  for (int i = 0; i < n; i++) {\n    fre[str[i] - 'a']++;\n  }\n  pair <char, int> odd = {'0', 0};\n  for (int i = 0; i < 26; i++) {\n    if (fre[i] > 0) {\n      if (fre[i] % 2 == 1) {\n        if (odd.second == 0) {\n          odd.second = 1;\n          odd.first = (char)(i + 'a');\n        } else {\n          return false;\n        } \n      }\n    } \n  }\n  if (odd.second == 1) {\n    if (n % 2 == 0) return false; \n  } \n  return true;\n}\n\ntemplate <typename T>\nbool palin(const T &s) {\n  int n = s.size();\n  for (int i = 0; i < n / 2; i++) {\n    int j = n - i - 1;\n    if (s[i] != s[j]) return false;\n  } \n  return true;\n} \n
parse=namespace parse {\n  bool delim(char c) {\n    return c == ' ';\n  }\n  bool is_op(char c) {\n    return c == '+' || c == '-' || c == '*' || c == '/';\n  }\n  bool is_unary(char c) {\n    return c == '+' || c == '-';\n  }\n  int priority(char op) {\n    if (op < 0) return 3; // unary operator\n    if (op == '+' || op == '-') return 1;\n    if (op == '*' || op == '/') return 2;\n    return -1;\n  }\n  void process_op(stack<int>& st, char op) {\n    if (op < 0) {\n      int l = st.top(); st.pop();\n      switch (-op) {\n        case '+': st.push(l); break;\n        case '-': st.push(-l); break;\n      }\n    } else {\n      int r = st.top(); st.pop();\n      int l = st.top(); st.pop();\n      switch (op) {\n        case '+': st.push(l + r); break;\n        case '-': st.push(l - r); break;\n        case '*': st.push(l * r); break;\n        case '/': st.push(l / r); break;\n      }\n    }\n  }\n  int evaluate(string& s) {\n    stack <int> st;\n    stack <char> op;\n    bool may_be_unary = true;\n    for (int i = 0; i < (int) s.size(); i++) {\n      if (delim(s[i])) continue;\n      if (s[i] == '(') {\n        op.push('(');\n        may_be_unary = true;\n      } else if (s[i] == ')') {\n        while (op.top() != '(') {\n          process_op(st, op.top());\n          op.pop();\n        }\n        op.pop();\n        may_be_unary = false;\n      } else if (is_op(s[i])) {\n        char cur_op = s[i];\n        if (may_be_unary && is_unary(cur_op)) {\n          cur_op = -cur_op;\n        }\n        while (!op.empty() && ((cur_op >= 0 && priority(op.top()) >= priority(cur_op)) || (cur_op < 0 && priority(op.top()) > priority(cur_op)))) {\n          process_op(st, op.top());\n          op.pop();\n        }\n        op.push(cur_op);\n        may_be_unary = true;\n      } else {\n        int number = 0;\n        while (i < (int)s.size() && isalnum(s[i])) {\n          number = number * 10 + s[i++] - '0';\n        }\n        --i;\n        st.push(number);\n        may_be_unary = false;\n      }\n    }\n\n    while (!op.empty()) {\n      process_op(st, op.top());\n      op.pop();\n    }\n    return st.top();\n  }\n}\n//parse::evaluate(s);\n
permute=//..when repeated characters exist\nbool swap_allow(string &str, int idx, int i) {\n  for (int j = idx; j < i; j++) {\n    if (str[j] == str[i]) return false;\n  }\n  return true;\n}\n\nvoid permute(string &str, int idx, int len) {\n  if (idx == len) {\n    cout << str << endl;\n    return;    \n  }\n  for (int i = idx; i < len; i++) {\n    if (swap_allow(str, idx, i)) {\n      swap(str[idx], str[i]);\n      permute(str, idx + 1, len);\n      swap(str[idx], str[i]);\n    }\n  }  \n} \n\n//..when all characters are distinct\nvoid permute(string &str, int idx, int len) {\n  if (idx == len) {\n    cout << str << endl;\n    return;\n  } \n  for (int i = idx; i < len; i++) {\n    swap(str[idx], str[i]);\n    permute(str, idx + 1, len);\n    swap(str[idx], str[i]);\n  } \n} \n\n
phi=const int N = (int) 1e5;\n\nint phi[N + 1];\n\n//for many phi(n) query\nvoid calc_phi() {\n  for (int i = 1; i <= N; i++) {\n    phi[i] = i;\n  }\n  for (int i = 2; i <= N; i++) {\n    if (phi[i] == i) {\n      for (int j = i; j <= N; j += i) {\n        phi[j] *= i - 1;\n        phi[j] /= i;\n      }\n    }\n  }\n}\n\n//for specific n\nint calc_phi(int n) {\n  int res = n;\n  for (int i = 2; i * i <= n; i++) {\n    if (n % i == 0) {\n      while (n % i == 0) {\n        n /= i;\n      }\n      res -= res / i;\n    }\n  }\n  if (n > 1) {\n    res -= res / n;\n  }\n  return res;\n}\n
pi=const double pi = acos(-1.0);\n
pinf=const int pinf = numeric_limits<int>::max();\n
point=struct point {\n  int x;\n  int y;\n  point() : x(0), y(0) { }\n  point(int _x, int _y) : x(_x), y(_y) { }\n  bool operator < (const point &b) const {\n    return x < b.x || (x == b.x && y < b.y);\n  } \n};\n\nstring to_string(const point& p) {\n  return "{" + to_string(p.x) + ", " + to_string(p.y) + "}";\n}\n\nostream& operator<<(ostream& out, const point& p) {\n  out << to_string(p);\n  return out;\n}\n \nistream& operator>>(istream& in, point& p) {\n  in >> p.x >> p.y;\n  return in;\n}\n\ninline int dot(point& a, point& b) {\n  return a.x * b.x + a.y * b.y;\n}\n\ninline int cross(point& a, point& b) {\n  return a.x * b.y - a.y * b.x;\n}\n\ninline int norm(point& a) {\n  return dot(a, a);\n}\n\ninline double abs(point& a) {\n  return sqrt(norm(a));\n}\n\ninline double proj(point& a, point& b) {\n  return dot(a, b) / abs(b);\n}\n\ninline double angle(point& a, point& b) {\n  return acos(dot(a, b) / abs(a) / abs(b));\n}\n\n\ntemplate <typename T>\nstruct TPoint {\n  T x;\n  T y;\n  int id;\n\n  TPoint() : x(0), y(0), id(-1) {}\n  TPoint(const T& x_, const T& y_) : x(x_), y(y_), id(-1) {}\n  TPoint(const T& x_, const T& y_, int id_) : x(x_), y(y_), id(id_) {}\n\n  static constexpr T eps = static_cast<T>(1e-9);\n\n  inline TPoint operator+(const TPoint& rhs) const { return TPoint(x + rhs.x, y + rhs.y); }\n  inline TPoint operator-(const TPoint& rhs) const { return TPoint(x - rhs.x, y - rhs.y); }\n  inline TPoint operator*(const T& rhs) const { return TPoint(x * rhs, y * rhs); }\n  inline TPoint operator/(const T& rhs) const { return TPoint(x / rhs, y / rhs); }\n\n  friend T smul(const TPoint& a, const TPoint& b) {\n    return a.x * b.x + a.y * b.y;\n  }\n\n  friend T vmul(const TPoint& a, const TPoint& b) {\n    return a.x * b.y - a.y * b.x;\n  }\n\n  inline T abs2() const {\n    return x * x + y * y;\n  }\n\n  inline bool operator<(const TPoint& rhs) const {\n    return (y < rhs.y || (y == rhs.y && x < rhs.x));\n  }\n\n  inline bool is_upper() const {\n    return (y > eps || (abs(y) <= eps && x > eps));\n  }\n\n  inline int cmp_polar(const TPoint& rhs) const {\n    assert(abs(x) > eps || abs(y) > eps);\n    assert(abs(rhs.x) > eps || abs(rhs.y) > eps);\n    bool a = is_upper();\n    bool b = rhs.is_upper();\n    if (a != b) {\n      return (a ? -1 : 1);\n    }\n    long long v = x * rhs.y - y * rhs.x;\n    return (v > eps ? -1 : (v < -eps ? 1 : 0));\n  }\n};\n\nusing Point = TPoint<long long>;\n//using Point = TPoint<long double>;\n\ntemplate <typename T>\nstring to_string(const TPoint<T>& p) {\n  return "(" + to_string(p.x) + ", " + to_string(p.y) + ")";\n}\n
policy=#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntypedef tree<int, null_type, less< int>, rb_tree_tag, tree_order_statistics_node_update> st;\n//use st.insert(1), *st.find_by_order(1), st.order_of_key(1) in O(logn) time\n
power=const int mod = (int) (1e9 + 7);\n\ninline int power(int a, int b) {\n  int res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res = mul(res, a);\n    }\n    b >>= 1;\n    a = mul(a, a);\n  }\n  return res;\n}\n
prec=  cout << fixed << setprecision(17);\n  cerr << fixed << setprecision(17);\n
prims_mst=template <typename T>\nvector <int> mst(const undigraph<T> &g, T &ans) {\n  priority_queue<pair<T, int>, vector<pair<T, int> >, greater<pair<T, int> > > pq;\n  vector<T> dist(g.n, numeric_limits<T>::max());\n  vector <bool> seen(g.n, false);\n  vector <int> ans_list(g.n - 1);\n  \n  int start = 0;\n  dist[start] = 0;\n  pq.emplace(dist[start], start);\n  while (!pq.empty()) {\n    pair <T, int> pr = pq.top(); \n    pq.pop();\n    int u = pr.second;\n    seen[u] = true;\n    for (int id : g.g[u]) {\n      auto &e = g.edges[id];\n      int v = e.from ^ e.to ^ u;\n      if (!seen[v] && e.cost < dist[v]) {\n        dist[v] = e.cost;\n        ans_list[v - 1] = id;\n        pq.emplace(dist[v], v);\n      } \n    }\n  }\n\n  ans = 0;\n  for (int i = 0; i < g.n; i++) {\n    ans += dist[i];\n  } \n  return ans_list;\n  //returns edge ids of minimum "spanning" forest\n}\n
push_relabel=//..verfied against AOJ GRL_6_A\nstruct Vertex {\n  int height;\n  int excess;\n};\n\nstruct Edge {\n  int dst, rev;\n  int cap, flow;\n};\n\nclass Graph {\nprivate:\n  int V;\n  int E;\n  vector <Vertex> ver;\n  vector <vector <Edge>> adj;\n  void preFlow(int s);\n  int overFlow(int s, int t);\n  bool push(int u);\n  void relabel(int u);\npublic:\n  Graph(int n, int m);\n  void addEdge(int src, int dst, int cap);\n  int maxFlow(int s, int t);\n};\n\nGraph::Graph(int n, int m) {\n  this->V = n;\n  this->E = m;\n  adj.resize(n);\n  ver.resize(n);\n  for (int i = 0; i < n; i++) {\n    ver[i] = {0, 0};\n  } \n}\n\nvoid Graph::addEdge(int src, int dst, int cap) {\n  Edge a = {dst, (int) adj[dst].size(), cap, 0};\n  Edge b = {src, (int) adj[src].size(), 0, 0};\n\n  adj[src].push_back(a);\n  adj[dst].push_back(b);\n} \n\nvoid Graph::preFlow(int s) {\n  ver[s].height = V;\n  for (Edge &e : adj[s]) {\n    e.flow += e.cap;                      //..flow the whole capacity\n    ver[e.dst].excess += e.cap;\n\n    adj[e.dst][e.rev].flow -= e.cap;      //..flow in reverse\n  }\n}\n\n//..overflow at vertices other than s and t. They could have been queued as well\nint Graph::overFlow(int s, int t) {\n  for (int i = 0; i < V; i++) {\n    if (i == s || i == t) {\n      continue;\n    }\n    if (ver[i].excess > 0) {\n      return i;\n    }\n  }\n  return -1; \n}\n\nbool Graph::push(int u) {\n  for (Edge &e : adj[u]) {\n    if (e.flow == e.cap) {\n      continue;\n    } \n    int v = e.dst;\n    if (ver[v].height < ver[u].height) {\n      int flow = min(ver[u].excess, e.cap - e.flow);\n      ver[u].excess -= flow;\n      ver[v].excess += flow;\n\n      e.flow += flow;\n      adj[v][e.rev].flow -= flow;\n\n      return true;\n    }    \n  }\n  return false;\n}\n\nvoid Graph::relabel(int u) {\n  int min_h = pinf;\n  for (Edge e : adj[u]) {\n    if (e.flow == e.cap) {\n      continue;\n    }\n    int v = e.dst;\n    min_h = min(min_h, ver[v].height);\n    ver[u].height = min_h + 1;      \n  }\n}\n\nint Graph::maxFlow(int s, int t) {\n  preFlow(s);\n  //..until overflow is not over\n  while (1) {\n    int node = overFlow(s, t);\n    if (node == -1) break;\n\n    if (!push(node)) {\n      relabel(node);\n    }\n  }\n  \n  int total = 0;\n  for (Edge e : adj[s]) {\n    total += e.flow;    \n  }\n  return total;\n} \n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  Graph g(n, m);\n\n  int src, dst, cap;\n  for (int i = 0; i < m; i++) {\n    cin >> src >> dst >> cap;\n    g.addEdge(src, dst, cap);\n  }\n  cout << g.maxFlow(0, n - 1) << '\n';\n\n  return 0;\n} \n
queue=template <typename T> \nstring to_string(queue <T> &q) {\n  bool first = true;\n  string res = "{";\n  queue <T> temp = q;\n  while (!temp.empty()) {\n    T x = temp.front();\n    temp.pop();\n    if (!first) {\n      res += ", ";\n    }    \n    first = false;\n    res += to_string(x);\n  } \n  res += "}";\n  return res;\n}\n
rabin_karp=//verfied against NHAY spoj\n//..both p and mod are primes\nconst int p = 31;\nconst int mod = (int) (1e9 + 9);\n\ninline long long mul(long long a, long long b) {\n  long long res = a * b;\n  a = res % mod;\n  return a;\n}\n\ninline void add(long long &a, long long b) {\n  a += b;\n  if (a >= mod) {\n    a -= mod;\n  }\n}\n\ninline void sub(long long &a, long long b) {\n  a -= b;\n  if (a < 0) {\n    a += mod;\n  }\n}\n \nlong long power(long long a, long long b) {\n  long long res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res = mul(res, a);\n    }\n    b >>= 1;\n    a = mul(a, a);\n  }\n  return res;\n}\n\ninline long long inv(long long x) {\n  return power(x, mod - 2);\n}\n\n//..polynomial rolling hashing of form : str[0] * (p ^ 0) + str[1] * (p ^ 1) + str[2] * (p ^ 2)\n//..complete hash value at end of hash array\nvector <long long> hashing(const string &str) {\n  long long val = 0;\n  long long exp = 1;\n  int len = str.length();\n  vector <long long> hash(len);\n  for (int i = 0; i < len; i++) {   \n    char ch = str[i];\n    int coef = ch - 'a' + 1;\n    add(val, mul(coef, exp));\n    exp = mul(exp, p);\n\n    hash[i] = val;\n  }\n\n  return hash;\n}\n\n//..hash[i..j] = (hash[0...j] - hash[0...i - 1]) / (p ^ i) under mod\nvector <int> rabin_karp(const string& pat, const string &txt) {\n  int n = pat.length();\n  int m = txt.length();\n  vector <int> pos;   \n  vector <long long> a = hashing(pat);\n  vector <long long> b = hashing(txt);\n  \n  //..block hashing in text, windowing...\n  long long match = a[n - 1];\n  for (int i = 0; i <= m - n; i++) { \n    int j = i + n - 1;\n    long long val = b[j];\n    if (i - 1 >= 0) {\n      sub(val, b[i - 1]);\n      val = mul(val, inv(power(p, i)));\n    }\n    if (val == match) {\n      pos.emplace_back(i);\n    } \n  }\n  return pos;\n  //..first positions of pattern match\n}\n
radix=namespace radix {\n \nvector<int> p(65537);\n \ntemplate<typename T>\nvoid SortShift(vector<T>& a, vector<T>& new_a, int shift) {\n  assert(a.size() == new_a.size());\n  int n = static_cast<int>(a.size());\n  fill(p.begin(), p.end(), 0);\n  for (int i = 0; i < n; i++) p[1 + ((a[i] >> shift) & 0xffff)]++;\n  for (int i = 1; i <= 65536; i++) p[i] += p[i - 1];\n  for (int i = 0; i < n; i++) new_a[p[(a[i] >> shift) & 0xffff]++] = a[i];\n}\n \nvoid Sort(vector<int32_t>& a) {\n  constexpr int32_t flip = static_cast<int32_t>(1) << 31;\n  for (auto& aa : a) aa ^= flip;\n  vector<int32_t> b(a.size());\n  SortShift(a, b, 0);\n  SortShift(b, a, 16);\n  for (auto& aa : a) aa ^= flip;\n}\n \nvoid Sort(vector<uint32_t>& a) {\n  vector<uint32_t> b(a.size());\n  SortShift(a, b, 0);\n  SortShift(b, a, 16);\n}\n \nvoid Sort(vector<int64_t>& a) {\n  constexpr int64_t flip = static_cast<int64_t>(1) << 63;\n  for (auto& aa : a) aa ^= flip;\n  vector<int64_t> b(a.size());\n  SortShift(a, b, 0);\n  SortShift(b, a, 16);\n  SortShift(a, b, 32);\n  SortShift(b, a, 48);\n  for (auto& aa : a) aa ^= flip;\n}\n \nvoid Sort(vector<uint64_t>& a) {\n  vector<uint64_t> b(a.size());\n  SortShift(a, b, 0);\n  SortShift(b, a, 16);\n  SortShift(a, b, 32);\n  SortShift(b, a, 48);\n}\n \n}  // namespace radix\n
rand=mt19937 rng((unsigned int) chrono::system_clock::now().time_since_epoch().count());\ntemplate <typename T>\nT rand(T L, T H) {\n  return uniform_int_distribution<T> (L, H)(rng);\n}\n
rank=template <typename T>\nvector <int> ranking(vector <T> &arr) {\n  int n = arr.size();\n  vector <pair <T, int>> pr(n);\n  for (int i = 0; i < n; i++) {\n    pr[i] = make_pair(arr[i], i);\n  } \n  sort(pr.begin(), pr.end());\n  int rank = 0;\n  int h = 0;\n  vector <int> r(n);\n  while (h < n) {\n    int l = h;\n    while (h + 1 < n && pr[h + 1].first == pr[l].first) {\n      h += 1;\n    }\n    for (int i = l; i <= h; i++) {\n      r[pr[i].second] = rank;\n    } \n    rank += 1;\n    l = h + 1;\n    h = h + 1;\n  }\n  return r; \n  //..r[i] is the rank of arr[i] if arr was sorted\n}\n
ranking=template <typename T>\nvector <int> ranking(vector <T> &arr) {\n  int n = arr.size();\n  vector <pair <T, int>> pr(n);\n  for (int i = 0; i < n; i++) {\n    pr[i] = make_pair(arr[i], i);\n  } \n  stable_sort(pr.begin(), pr.end());\n  int rank = 0;\n  int h = 0;\n  vector <int> r(n);\n  while (h < n) {\n    int l = h;\n    while (h + 1 < n && pr[h + 1].first == pr[l].first) {\n      h += 1;\n    }\n    for (int i = l; i <= h; i++) {\n      r[pr[i].second] = rank;\n    } \n    rank += 1;\n    l = h + 1;\n    h = h + 1;\n  }\n  return r; \n  //..r[i] is the rank of arr[i] if arr was sorted\n} \n
read=template <typename T> \ninline void read(T &x) {\n  char c = (char) getchar();\n  bool f = false;\n  for (x = 0; !isdigit(c); c = (char) getchar()) {\n    if (c == '-') {\n      f = true;\n    }\n  }\n  for (; isdigit(c); c = (char) getchar()) {\n    x = x * 10 + c - '0';\n  }\n  if (f) {\n    x = -x;\n  }\n}\n
rng=mt19937 rng((unsigned int) chrono::system_clock::now().time_since_epoch().count());\n
rotate=/*\ninline void rotate(int& x, int& y, int n) {\n  x = n - 1 - y;\n  y = x;\n}\n*/\n//rotate string s by amt to L or R\nauto rotateL = [&](string &s, int k) {\n  int len = s.length();\n  k = k % len;\n  string t(len, '0');\n  int idx = k;\n  for (int i = 0; i < len; i++) {\n    t[i] = s[idx];\n    idx = idx + 1;\n    if (idx == len) idx = 0;\n  } \n  s = t;\n};\nauto rotateR = [&](string &s, int k) {\n  int len = s.length();\n  k = k % len;\n  rotateL(s, len - k);\n};\n
sa=/* tourist's template\ntemplate <typename T>\nvector<int> suffix_array(int n, const T &s, int char_bound) {\n  vector<int> a(n);\n  if (n == 0) {\n    return a;\n  }\n  if (char_bound != -1) {\n    vector<int> aux(char_bound, 0);\n    for (int i = 0; i < n; i++) {\n      aux[s[i]]++;\n    }\n    int sum = 0;\n    for (int i = 0; i < char_bound; i++) {\n      int add = aux[i];\n      aux[i] = sum;\n      sum += add;\n    }\n    for (int i = 0; i < n; i++) {\n      a[aux[s[i]]++] = i;\n    }\n  } else {\n    iota(a.begin(), a.end(), 0);\n    sort(a.begin(), a.end(), [&s](int i, int j) { return s[i] < s[j]; });\n  }\n  vector<int> sorted_by_second(n);\n  vector<int> ptr_group(n);\n  vector<int> new_group(n);\n  vector<int> group(n);\n  group[a[0]] = 0;\n  for (int i = 1; i < n; i++) {\n    group[a[i]] = group[a[i - 1]] + (!(s[a[i]] == s[a[i - 1]]));\n  }\n  int cnt = group[a[n - 1]] + 1;\n  int step = 1;\n  while (cnt < n) {\n    int at = 0;\n    for (int i = n - step; i < n; i++) {\n      sorted_by_second[at++] = i;\n    }\n    for (int i = 0; i < n; i++) {\n      if (a[i] - step >= 0) {\n        sorted_by_second[at++] = a[i] - step;\n      }\n    }\n    for (int i = n - 1; i >= 0; i--) {\n      ptr_group[group[a[i]]] = i;\n    }\n    for (int i = 0; i < n; i++) {\n      int x = sorted_by_second[i];\n      a[ptr_group[group[x]]++] = x;\n    }\n    new_group[a[0]] = 0;\n    for (int i = 1; i < n; i++) {\n      if (group[a[i]] != group[a[i - 1]]) {\n        new_group[a[i]] = new_group[a[i - 1]] + 1;\n      } else {\n        int pre = (a[i - 1] + step >= n ? -1 : group[a[i - 1] + step]);\n        int cur = (a[i] + step >= n ? -1 : group[a[i] + step]);\n        new_group[a[i]] = new_group[a[i - 1]] + (pre != cur);\n      }\n    }\n    swap(group, new_group);\n    cnt = group[a[n - 1]] + 1;\n    step <<= 1;\n  }\n  return a;\n}\n \ntemplate <typename T>\nvector<int> suffix_array(const T &s, int char_bound) {\n  return suffix_array((int) s.size(), s, char_bound);\n}\n//..vector <int> sa = suffix_array(str, 256);\n*/\n\n//Mine\nnamespace suffix {\n  int char_bound = 256;\n  struct suf { \n    int idx;\n    vector <int> rank;\n    suf() { rank.resize(2); }\n  }; \n\n  void radix_sort(vector <suf>& sufs, int idx = 1) { \n    int n = sufs.size();\n    vector <int> bucket(char_bound + 1, 0);\n    vector <suf> temp(n);\n    for (int i = 0; i < n; i++) {\n      bucket[sufs[i].rank[idx] + 1]++;\n    }\n    for (int i = 1; i < char_bound; i++) {\n      bucket[i] += bucket[i - 1];\n    }\n    for (int i = n - 1; i >= 0; i--) {\n      temp[bucket[sufs[i].rank[idx] + 1] - 1] = sufs[i];\n      bucket[sufs[i].rank[idx] + 1]--;\n    }\n    for (int i = 0; i < n; i++) {\n      sufs[i] = temp[i];\n    }\n    temp.clear();\n    if (idx == 0) return;\n    else radix_sort(sufs, 0);\n  } \n\n  vector <int> suffix_array(const string &str) {\n    int n = str.length();\n    vector <suf> sufs(n);\n    for (int i = 0; i < n; i++) { \n      sufs[i].idx = i;\n      sufs[i].rank[0] = str[i];\n      sufs[i].rank[1] = ((i + 1) < n) ? str[i + 1] : -1;\n    }\n    radix_sort(sufs);\n    vector <int> ind(n);\n    for (int k = 4; k < 2 * n; k = k * 2) { \n      int rank = 0; \n      int prev_rank = sufs[0].rank[0];\n      sufs[0].rank[0] = rank;\n      ind[sufs[0].idx] = 0;\n      for (int i = 1; i < n; i++) {\n        if (sufs[i].rank[0] == prev_rank && sufs[i].rank[1] == sufs[i - 1].rank[1]) { \n          prev_rank = sufs[i].rank[0]; \n          sufs[i].rank[0] = rank; \n        } else {\n          prev_rank = sufs[i].rank[0]; \n          sufs[i].rank[0] = ++rank; \n        } \n        ind[sufs[i].idx] = i; \n      } \n      for (int i = 0; i < n; i++) { \n        int next = sufs[i].idx + k / 2; \n        sufs[i].rank[1] = (next < n) ? sufs[ind[next]].rank[0] : -1; \n      } \n      radix_sort(sufs);\n    } \n    vector <int> a(n);\n    for (int i = 0; i < n; i++) { \n      a[i] = sufs[i].idx; \n    }\n    return a; \n  } \n}\n\nusing suffix::suffix_array;\n
scc=/*\n//..Mine\nusing Kosaraju Algo uses reverse graph  : kosaraju\nusing Tarjan uses dicovery and low time : tarjan\n*/\n\ntemplate <typename T>\nvector<int> find_scc(const digraph<T> &g, int &cnt) {\n  digraph<T> g_rev = g.reverse();\n  vector<int> order;\n  vector<bool> was(g.n, false);\n  function<void(int)> dfs1 = [&](int v) {\n    was[v] = true;\n    for (int id : g.g[v]) {\n      auto &e = g.edges[id];\n      int to = e.to;\n      if (!was[to]) {\n        dfs1(to);\n      }\n    }\n    order.push_back(v);\n  };\n  for (int i = 0; i < g.n; i++) {\n    if (!was[i]) {\n      dfs1(i);\n    }\n  }\n  vector<int> c(g.n, -1);\n  function<void(int)> dfs2 = [&](int v) {\n    for (int id : g_rev.g[v]) {\n      auto &e = g_rev.edges[id];\n      int to = e.to;\n      if (c[to] == -1) {\n        c[to] = c[v];\n        dfs2(to);\n      }\n    }\n  };\n  cnt = 0;\n  for (int id = g.n - 1; id >= 0; id--) {\n    int i = order[id];\n    if (c[i] != -1) {\n      continue;\n    }\n    c[i] = cnt++;\n    dfs2(i);\n  }\n  return c;\n  // c[i] <= c[j] for every edge i -> j\n}\n
segtree=class segtree {\n public:\n  struct node {\n    // don't forget to set default value (used for leaves)\n    // not necessarily neutral element!\n    ...\n    // variable holding the temporarily cumulative range updates\n    T add = 0; \n    bool mark = false;\n    // the query result = node property, leaf property\n    T sum = 0;     \n    ...\n\n    void apply(int l, int h, ... v) {\n      assert(l <= h); // l == h for point update\n      ...\n      add += v;\n      sum += (h - l + 1) * v; // set query variable = query[l - h], Also for point-update one variable is required\n      mark = true;\n      ...\n    }\n  };\n \n  node unite(const node &a, const node &b) const {\n    node res;\n    res.sum = a.sum + b.sum; // do nothing for point query, simlply return res\n    // don't merge the temporary holdings of child since they're responsible in different range\n    return res;\n    ...\n  }\n \n  inline void push(int i, int l, int h) {\n    int m = (l + h) >> 1;\n    // push from i into left child and right child, Also no push in point-update\n    // only bother about pushing and not about pulling (uniting)\n   /*\n    if (tree[i].mark) {\n      tree[i << 1].apply(l, m, tree[i].add);\n      tree[(i << 1) + 1].apply(m + 1, h, tree[i].add);\n      tree[i].add = 0;\n      tree[i].mark = false;\n    }\n    */\n  }\n \n  inline void pull(int i) {\n    tree[i] = unite(tree[i << 1], tree[(i << 1) + 1]);\n  }\n \n  int n;\n  vector<node> tree;\n  \n  template <typename M>\n  void build(int i, int l, int h, const vector<M> &v) {\n    if (l == h) {\n      tree[i].apply(l, h, v[l]);\n      return;\n    }\n    int m = (l + h) >> 1;\n    build(i << 1, l, m, v);\n    build((i << 1) + 1, m + 1, h, v);\n    pull(i);\n  }\n \n  node get(int i, int l, int h, int ql, int qh) {\n    if (ql <= l && h <= qh) {\n      return tree[i];\n    }\n    int m = (l + h) >> 1;\n    push(i, l, h);\n    node res{};\n    if (qh <= m) {\n      res = get(i << 1, l, m, ql, qh);\n    } else {\n      if (ql > m) {\n        res = get((i << 1) + 1, m + 1, h, ql, qh);\n      } else {\n        res = unite(get(i << 1, l, m, ql, qh), get((i << 1) + 1, m + 1, h, ql, qh));\n      }\n    }\n    pull(i);\n    return res;\n  }\n \n  template <typename... M>\n  void modify(int i, int l, int h, int ql, int qh, const M&... v) {\n    if (ql <= l && h <= qh) {\n      tree[i].apply(l, h, v...);\n      return;\n    }\n    push(i, l, h);\n    int m = (l + h) >> 1;\n    if (qh <= m) {\n      modify(i << 1, l, m, ql, qh, v...);\n    } else {\n      if (ql > m) {\n        modify((i << 1) + 1, m + 1, h, ql, qh, v...);\n      } else {\n        modify(i << 1, l, m, ql, qh, v...);\n        modify((i << 1) + 1, m + 1, h, ql, qh, v...);\n      }\n    }\n    pull(i);\n  }\n \n  template <typename M>\n  segtree(const vector<M> &v) {\n    n = (int) v.size();\n    assert(n > 0);\n    tree.resize(4 * n);\n    build(1, 0, n - 1, v);\n  }\n \n  node get(int ql, int qh) {\n    assert(0 <= ql && ql <= qh && qh <= n - 1);\n    return get(1, 0, n - 1, ql, qh);\n  }\n \n  template <typename... M>\n  void modify(int ql, int qh, const M&... v) {\n    assert(0 <= ql && ql <= qh && qh <= n - 1);\n    modify(1, 0, n - 1, ql, qh, v...);\n  }\n};\n
segtree_tourist=class segtree {\n public:\n  struct node {\n    // don't forget to set default value (used for leaves)\n    // not necessarily neutral element!\n    ...\n    // variable holding the temporarily cumulative range updates\n    T add = 0; \n    bool mark = false;\n    // node property, leaf property\n    T sum = 0;     \n    ...\n\n    void apply(int l, int h, ... v) {\n      ...\n      add += v;\n      sum += (h - l + 1) * v; // set query variable = query[l - h], Also for point-update one variable is required\n      mark = true;\n      ...\n    }\n  };\n \n  node unite(const node &a, const node &b) const {\n    ...\n    node res;\n    res.sum = a.sum + b.sum; // do nothing for point query, simlply return res\n    return res;\n    ...\n  }\n \n  inline void push(int i, int l, int h) {\n    int m = (l + h) >> 1;\n    // push from i into left child and right child, Also no push in point-update\n   /*\n    if (tree[i].mark) {\n      tree[i << 1].apply(l, m, tree[i].add);\n      tree[(i << 1) + 1].apply(m + 1, h, tree[i].add);\n      tree[i].add = 0;\n      tree[i].mark = false;\n    }\n    */\n  }\n \n  inline void pull(int i) {\n    tree[i] = unite(tree[i << 1], tree[(i << 1) + 1]);\n  }\n \n  int n;\n  vector<node> tree;\n \n  void build(int i, int l, int h) {\n    if (l == h) {\n      return;\n    }\n    int m = (l + h) >> 1;\n    build(i << 1, l, m);\n    build((i << 1) + 1, m + 1, h);\n    pull(i);\n  }\n \n  template <typename M>\n  void build(int i, int l, int h, const vector<M> &v) {\n    if (l == h) {\n      tree[i].apply(l, h, v[l]);\n      return;\n    }\n    int m = (l + h) >> 1;\n    build(i << 1, l, m, v);\n    build((i << 1) + 1, m + 1, h, v);\n    pull(i);\n  }\n \n  node get(int i, int l, int h, int ql, int qh) {\n    if (ql <= l && h <= qh) {\n      return tree[i];\n    }\n    int m = (l + h) >> 1;\n    push(i, l, h);\n    node res{};\n    if (qh <= m) {\n      res = get(i << 1, l, m, ql, qh);\n    } else {\n      if (ql > m) {\n        res = get((i << 1) + 1, m + 1, h, ql, qh);\n      } else {\n        res = unite(get(i << 1, l, m, ql, qh), get((i << 1) + 1, m + 1, h, ql, qh));\n      }\n    }\n    pull(i);\n    return res;\n  }\n \n  template <typename... M>\n  void modify(int i, int l, int h, int ql, int qh, const M&... v) {\n    if (ql <= l && h <= qh) {\n      tree[i].apply(l, h, v...);\n      return;\n    }\n    push(i, l, h);\n    int m = (l + h) >> 1;\n    if (qh <= m) {\n      modify(i << 1, l, m, ql, qh, v...);\n    } else {\n      if (ql > m) {\n        modify((i << 1) + 1, m + 1, h, ql, qh, v...);\n      } else {\n        modify(i << 1, l, m, ql, qh, v...);\n        modify((i << 1) + 1, m + 1, h, ql, qh, v...);\n      }\n    }\n    pull(i);\n  }\n \n  int find_first_knowingly(int i, int l, int h, const function<bool(const node&)> &f) {\n    if (l == h) {\n      return l;\n    }\n    push(i, l, h);\n    int m = (l + h) >> 1;\n    int res;\n    if (f(tree[i << 1])) {\n      res = find_first_knowingly(i << 1, l, m, f);\n    } else {\n      res = find_first_knowingly((i << 1) + 1, m + 1, h, f);\n    }\n    pull(i);\n    return res;\n  }\n \n  int find_first(int i, int l, int h, int ql, int qh, const function<bool(const node&)> &f) {\n    if (ql <= l && h <= qh) {\n      if (!f(tree[i])) {\n        return -1;\n      }\n      return find_first_knowingly(i, l, h, f);\n    }\n    push(i, l, h);\n    int m = (l + h) >> 1;\n    int res = -1;\n    if (ql <= m) {\n      res = find_first(i << 1, l, m, ql, qh, f);\n    }\n    if (qh > m && res == -1) {\n      res = find_first((i << 1) + 1, m + 1, h, ql, qh, f);\n    }\n    pull(i);\n    return res;\n  }\n \n  int find_last_knowingly(int i, int l, int h, const function<bool(const node&)> &f) {\n    if (l == h) {\n      return l;\n    }\n    push(i, l, h);\n    int m = (l + h) >> 1;\n    int res;\n    if (f(tree[(i << 1) + 1])) {\n      res = find_last_knowingly((i << 1) + 1, m + 1, h, f);\n    } else {\n      res = find_last_knowingly(i << 1, l, m, f);\n    }\n    pull(i);\n    return res;\n  }\n \n  int find_last(int i, int l, int h, int ql, int qh, const function<bool(const node&)> &f) {\n    if (ql <= l && h <= qh) {\n      if (!f(tree[i])) {\n        return -1;\n      }\n      return find_last_knowingly(i, l, h, f);\n    }\n    push(i, l, h);\n    int m = (l + h) >> 1;\n    int res = -1;\n    if (qh > m) {\n      res = find_last((i << 1) + 1, m + 1, h, ql, qh, f);\n    }\n    if (ql <= m && res == -1) {\n      res = find_last(i << 1, l, m, ql, qh, f);\n    }\n    pull(i);\n    return res;\n  }\n \n  segtree(int _n) : n(_n) {\n    assert(n > 0);\n    tree.resize(4 * n);\n    build(1, 0, n - 1);\n  }\n \n  template <typename M>\n  segtree(const vector<M> &v) {\n    n = v.size();\n    assert(n > 0);\n    tree.resize(4 * n);\n    build(1, 0, n - 1, v);\n  }\n \n  node get(int ql, int qh) {\n    assert(0 <= ql && ql <= qh && qh <= n - 1);\n    return get(1, 0, n - 1, ql, qh);\n  }\n \n  node get(int p) {\n    assert(0 <= p && p <= n - 1);\n    return get(1, 0, n - 1, p, p);\n  }\n \n  template <typename... M>\n  void modify(int ql, int qh, const M&... v) {\n    assert(0 <= ql && ql <= qh && qh <= n - 1);\n    modify(1, 0, n - 1, ql, qh, v...);\n  }\n\n  // find_first and find_last call all FALSE elements\n  // to the left (right) of the sought position exactly once\n \n  int find_first(int ql, int qh, const function<bool(const node&)> &f) {\n    assert(0 <= ql && ql <= qh && qh <= n - 1);\n    return find_first(1, 0, n - 1, ql, qh, f);\n  }\n \n  int find_last(int ql, int qh, const function<bool(const node&)> &f) {\n    assert(0 <= ql && ql <= qh && qh <= n - 1);\n    return find_last(1, 0, n - 1, ql, qh, f);\n  }\n};\n
sieve=//calc upto SQRT(n) = m primes using simple_sieve then calc remaining primes using segmented_sieve\nconst int N = (int) 1e8;\nconst int M = (int) 1e4;\nvector <int> primes;\nvector <bool> isprime(M + 1);\n\nvoid simple_sieve() {\n  fill(isprime.begin(), isprime.end(), true);\n\n  for (int i = 2; i * i <= M; i++) {\n    if (isprime[i]) {\n      for (int j = i * i; j <= M; j += i) {\n        isprime[j] = false;\n      }\n    }\n  }\n\n  primes.push_back(2);\n  for (int i = 3; i <= M; i += 2) {\n    if (isprime[i]) {\n      primes.push_back(i);\n    }\n  }\n}\n\nvoid segmented_sieve() {  \n  int limit = M + 1;\n  int low = limit;\n  int high = 2 * limit;\n\n  while (low < N) {\n    if (high >= N) high = N;\n    bool mark[limit + 1];\n    fill(mark, mark + limit + 1, true);\n\n    for (int i = 0; i < (int) primes.size(); i++) {\n      int lolimit = (low / primes[i]) * primes[i];\n      if (lolimit < low) {\n        lolimit += primes[i];\n      }\n      for (int j = lolimit; j < high; j += primes[i]) {\n        mark[j - low] = false;\n      }\n    }\n\n    for (int i = low; i < high; i++) {\n      if (mark[i - low]) {\n        primes.push_back(i);\n      } \n    }\n\n    low = high;\n    high += limit;\n  }  \n}\n
sparse=//function must be overlapping friendly e.g min, max, gcd, lcm\ntemplate <typename T, class F = function<T(const T&, const T&)>>\nclass SparseTable {\n public:\n  int n;\n  vector<vector<T>> mat;\n  F func;\n \n  SparseTable(const vector<T>& a, const F& f) : func(f) {\n    n = static_cast<int>(a.size());\n    int max_log = 32 - __builtin_clz(n);\n    mat.resize(max_log);\n    mat[0] = a;\n    for (int i = 1; i < max_log; i++) {\n      mat[i].resize(n - (1 << i) + 1);\n      for (int j = 0; j <= n - (1 << i); j++) {\n        mat[i][j] = func(mat[i - 1][j], mat[i - 1][j + (1 << (i - 1))]);\n      }\n    }\n  }\n \n  T get(int from, int to) const {\n    assert(0 <= from && from <= to && to <= n - 1);\n    int lg = 32 - __builtin_clz(to - from + 1) - 1;\n    return func(mat[lg][from], mat[lg][to - (1 << lg) + 1]);\n  }\n};\n\n...vector <int> arr;\n...SparseTable <int> st(arr, [&](const int& a, const int& b) { return min(a, b); });\n
splay=class node {\n public:\n  node* l;\n  node* r;\n  node* p;\n  bool rev;\n  // declare extra variables:\n  int tl;\n  int tr;\n  int tv;\n  int ml;\n  int mr;\n  int mv;\n  int sm;\n  int id;\n \n  void init(int _tl, int _tr, int _tv, int _id) {\n    l = r = p = NULL;\n    rev = false;\n    // init extra variables:\n    tl = _tl;\n    tr = _tr;\n    tv = _tv;\n    ml = tl;\n    mr = tr;\n    mv = tv;\n    sm = tv;\n    id = _id;\n  }\n \n  void unsafe_reverse() {\n    rev ^= 1;\n    swap(l, r);\n    pull();\n  }\n \n  // apply changes:\n  void unsafe_apply() {\n  }\n \n  void push() {\n    if (rev) {\n      if (l != NULL) {\n        l->unsafe_reverse();\n      }\n      if (r != NULL) {\n        r->unsafe_reverse();\n      }\n      rev = 0;\n    }\n    // now push everything else:\n  }\n \n  void pull() {\n    // now init from self:\n    ml = tl;\n    mr = tr;\n    mv = tv;\n    sm = tv;\n    if (l != NULL) {\n      l->p = this;\n      // now pull from l:\n      ml = min(ml, l->ml);\n      mr = max(mr, l->mr);\n      mv = max(mv, l->mv);\n      sm += l->sm;\n    }\n    if (r != NULL) {\n      r->p = this;\n      // now pull from r:\n      ml = min(ml, r->ml);\n      mr = max(mr, r->mr);\n      mv = max(mv, r->mv);\n      sm += r->sm;\n    }\n  }\n};\n\nnamespace splay_tree {\n  bool is_bst_root(node* v) {\n    if (v == NULL) {\n      return false;\n    }\n    return (v->p == NULL || (v->p->l != v && v->p->r != v));\n  }\n   \n  void rotate(node* v) {\n    node* u = v->p;\n    assert(u != NULL);\n    u->push();\n    v->push();\n    v->p = u->p;\n    if (v->p != NULL) {\n      if (v->p->l == u) {\n        v->p->l = v;\n      }\n      if (v->p->r == u) {\n        v->p->r = v;\n      }\n    }\n    if (v == u->l) {\n      u->l = v->r;\n      v->r = u;\n    } else {\n      u->r = v->l;\n      v->l = u;\n    }\n    u->pull();\n    v->pull();\n  }\n   \n  void splay(node* v) {\n    if (v == NULL) {\n      return;\n    }\n    while (!is_bst_root(v)) {\n      node* u = v->p;\n      if (!is_bst_root(u)) {\n        if ((u->l == v) ^ (u->p->l == u)) {\n          rotate(v);\n        } else {\n          rotate(u);\n        }\n      }\n      rotate(v);\n    }\n  }\n   \n  pair<node*, int> find(node* v, const function<int(node*)> &go_to) {\n    // go_to returns: 0 -- found; -1 -- go left; 1 -- go right\n    // find returns the last vertex on the descent and its go_to\n    if (v == NULL) {\n      return {NULL, 0};\n    }\n    splay(v);\n    int dir;\n    while (true) {\n      v->push();\n      dir = go_to(v);\n      if (dir == 0) {\n        break;\n      }\n      node* u = (dir == -1 ? v->l : v->r);\n      if (u == NULL) {\n        break;\n      }\n      v = u;\n    }\n    splay(v);\n    return {v, dir};\n  }\n   \n  node* get_leftmost(node* v) {\n    return find(v, [&](node*) {\n      return -1;\n    }).first;\n  }\n   \n  node* get_rightmost(node* v) {\n    return find(v, [&](node*) {\n      return 1;\n    }).first;\n  }\n   \n  node* get_bst_root(node* v) {\n    splay(v);\n    return v;\n  }\n   \n  pair<node*, node*> split(node* v, const function<bool(node*)> &is_right) {\n    if (v == NULL) {\n      return {NULL, NULL};\n    }\n    pair<node*, int> p = find(v, [&](node * u) {\n      return is_right(u) ? -1 : 1;\n    });\n    v = p.first;\n    v->push();\n    if (p.second == -1) {\n      node* u = v->l;\n      if (u == NULL) {\n        return {NULL, v};\n      }\n      v->l = NULL;\n      u->p = v->p;\n      u = get_rightmost(u);\n      v->p = u;\n      v->pull();\n      return {u, v};\n    } else {\n      node* u = v->r;\n      if (u == NULL) {\n        return {v, NULL};\n      }\n      v->r = NULL;\n      v->pull();\n      return {v, u};\n    }\n  }\n   \n  node* merge(node* v, node* u) {\n    if (v == NULL) {\n      return u;\n    }\n    if (u == NULL) {\n      return v;\n    }\n    v = get_rightmost(v);\n    assert(v->r == NULL);\n    splay(u);\n    v->push();\n    v->r = u;\n    v->pull();\n    return v;\n  }\n   \n  node* add(node* r, node* v, const function<bool(node*)> &go_left) {\n    pair<node*, node*> p = split(r, go_left);\n    return merge(p.first, merge(v, p.second));\n  }\n   \n  node* remove(node* v) { // returns the new root\n    splay(v);\n    v->push();\n    node* x = v->l;\n    node* y = v->r;\n    v->l = v->r = NULL;\n    node* z = merge(x, y);\n    if (z != NULL) {\n      z->p = v->p;\n    }\n    v->p = NULL;\n    v->push();\n    v->pull(); // now v might be reusable...\n    return z;\n  }\n   \n  node* next(node* v) {\n    splay(v);\n    v->push();\n    if (v->r == NULL) {\n      return NULL;\n    }\n    v = v->r;\n    while (v->l != NULL) {\n      v->push();\n      v = v->l;\n    }\n    splay(v);\n    return v;\n  }\n   \n  node* prev(node* v) {\n    splay(v);\n    v->push();\n    if (v->l == NULL) {\n      return NULL;\n    }\n    v = v->l;\n    while (v->r != NULL) {\n      v->push();\n      v = v->r;\n    }\n    splay(v);\n    return v;\n  }\n   \n  template<typename... T>\n  void apply(node* v, T... args) {\n    splay(v);\n    v->unsafe_apply(args...);\n  }\n   \n  void reverse(node* v) {\n    splay(v);\n    v->unsafe_reverse();\n  }\n}\n \nusing namespace splay_tree;\n
sqrd=template <typename T>\nclass sqrd {\n public:\n  struct block {\n    //set variables with default values\n    int ans = ...\n  };\n  vector <T> arr;\n  vector <block> b;\n  int size;\n  void unite(block &u, T val) const {\n    ... u = u + val\n  }\n  void remove(block &u, T val) const {\n    ... u = u - val\n  } \n\n  sqrd(vector <T> &_arr) {\n    arr = _arr;\n    int n = _arr.size();\n    size = (int) sqrt(n + 0.1) + 1;\n    b = vector <block> (size);\n    for (int i = 0; i < n; i++) {\n      unite(b[i / size], _arr[i]);\n    } \n  }\n  void modify(int i, T val) {\n    remove(b[i / size], arr[i]);\n    unite(b[i / size], val);\n    arr[i] = val;\n  } \n  ... get(int L, int H) {\n    int ans = ...\n    for (int i = L; i <= H; ) {\n      if (i % size == 0 && i + size - 1 <= H) {\n        block u = b[i / size];\n        ...ans = ans + u\n        i += size;\n      } else {\n        ...ans = ans + arr[i]\n        i++;\n      }\n    }\n    return ans;\n  } \n};\n
stack=template <typename T> \nstring to_string(stack <T> &st) {\n  bool first = true;\n  string res = "}";\n  stack <T> temp = st;\n  while (!temp.empty()) {\n    T x = temp.top();\n    temp.pop();\n    if (!first) {\n      res += " ,";\n    }\n    first = false;\n    res += to_string(x); \n  } \n  res += "{";\n  reverse(res.begin(), res.end());\n  return res;\n}\n
sub=inline void sub(int &a, int b) {\n  a -= b;\n  if (a < 0) {\n    a += mod;\n  }\n}\n
subset=//..iterative\ntemplate <typename T>\nvector <vector <T>> subset(vector <T>& arr) {\n  int n = arr.size();\n  int total = ((1 << n) - 1);\n  vector <vector <T>> ss(total);\n\n  for (int mask = 1; mask <= total; mask++) {\n    for (int sh = 0; sh < n; sh++) {\n      if ((mask & (1 << sh)) != 0) {\n        ss[mask - 1].push_back(arr[sh]);\n      } \n    }\n  }\n  ...ss.push_back(vector <T>());\n  return ss;\n}\n\n//..recursive\ntemplate <typename T>\nvoid subsetUtil(int idx, int n, vector <T> &temp, vector <vector <T>> &ss, vector <T> &arr) {\n  if (idx == n) {\n    ss.push_back(temp);\n    return;\n  } \n  //..including  \n  temp.push_back(arr[idx]);\n  subsetUtil(idx + 1, n, temp, ss, arr);\n  temp.pop_back();\n  //..excluding\n  subsetUtil(idx + 1, n, temp, ss, arr);\n} \n\ntemplate <typename T>\nvector <vector <T>> subset(vector <T>& arr) {\n  vector <vector <T>> ss;\n  int n = arr.size();\n  vector <T> temp;\n  subsetUtil(0, n, temp, ss, arr);\n  ...ss.push_back(vector <T>());\n  return ss;\n}  \n
suffix_array=/* tourist's template\ntemplate <typename T>\nvector<int> suffix_array(int n, const T &s, int char_bound) {\n  vector<int> a(n);\n  if (n == 0) {\n    return a;\n  }\n  if (char_bound != -1) {\n    vector<int> aux(char_bound, 0);\n    for (int i = 0; i < n; i++) {\n      aux[s[i]]++;\n    }\n    int sum = 0;\n    for (int i = 0; i < char_bound; i++) {\n      int add = aux[i];\n      aux[i] = sum;\n      sum += add;\n    }\n    for (int i = 0; i < n; i++) {\n      a[aux[s[i]]++] = i;\n    }\n  } else {\n    iota(a.begin(), a.end(), 0);\n    sort(a.begin(), a.end(), [&s](int i, int j) { return s[i] < s[j]; });\n  }\n  vector<int> sorted_by_second(n);\n  vector<int> ptr_group(n);\n  vector<int> new_group(n);\n  vector<int> group(n);\n  group[a[0]] = 0;\n  for (int i = 1; i < n; i++) {\n    group[a[i]] = group[a[i - 1]] + (!(s[a[i]] == s[a[i - 1]]));\n  }\n  int cnt = group[a[n - 1]] + 1;\n  int step = 1;\n  while (cnt < n) {\n    int at = 0;\n    for (int i = n - step; i < n; i++) {\n      sorted_by_second[at++] = i;\n    }\n    for (int i = 0; i < n; i++) {\n      if (a[i] - step >= 0) {\n        sorted_by_second[at++] = a[i] - step;\n      }\n    }\n    for (int i = n - 1; i >= 0; i--) {\n      ptr_group[group[a[i]]] = i;\n    }\n    for (int i = 0; i < n; i++) {\n      int x = sorted_by_second[i];\n      a[ptr_group[group[x]]++] = x;\n    }\n    new_group[a[0]] = 0;\n    for (int i = 1; i < n; i++) {\n      if (group[a[i]] != group[a[i - 1]]) {\n        new_group[a[i]] = new_group[a[i - 1]] + 1;\n      } else {\n        int pre = (a[i - 1] + step >= n ? -1 : group[a[i - 1] + step]);\n        int cur = (a[i] + step >= n ? -1 : group[a[i] + step]);\n        new_group[a[i]] = new_group[a[i - 1]] + (pre != cur);\n      }\n    }\n    swap(group, new_group);\n    cnt = group[a[n - 1]] + 1;\n    step <<= 1;\n  }\n  return a;\n}\n \ntemplate <typename T>\nvector<int> suffix_array(const T &s, int char_bound) {\n  return suffix_array((int) s.size(), s, char_bound);\n}\n//..vector <int> sa = suffix_array(str, 256);\n*/\n\n//Mine\nnamespace suffix {\n  int char_bound = 256;\n  struct suf { \n    int idx;\n    vector <int> rank;\n    suf() { rank.resize(2); }\n  }; \n\n  void radix_sort(vector <suf>& sufs, int idx = 1) { \n    int n = sufs.size();\n    vector <int> bucket(char_bound + 1, 0);\n    vector <suf> temp(n);\n    for (int i = 0; i < n; i++) {\n      bucket[sufs[i].rank[idx] + 1]++;\n    }\n    for (int i = 1; i < char_bound; i++) {\n      bucket[i] += bucket[i - 1];\n    }\n    for (int i = n - 1; i >= 0; i--) {\n      temp[bucket[sufs[i].rank[idx] + 1] - 1] = sufs[i];\n      bucket[sufs[i].rank[idx] + 1]--;\n    }\n    for (int i = 0; i < n; i++) {\n      sufs[i] = temp[i];\n    }\n    temp.clear();\n    if (idx == 0) return;\n    else radix_sort(sufs, 0);\n  } \n\n  vector <int> suffix_array(const string &str) {\n    int n = str.length();\n    vector <suf> sufs(n);\n    for (int i = 0; i < n; i++) { \n      sufs[i].idx = i;\n      sufs[i].rank[0] = str[i];\n      sufs[i].rank[1] = ((i + 1) < n) ? str[i + 1] : -1;\n    }\n    radix_sort(sufs);\n    vector <int> ind(n);\n    for (int k = 4; k < 2 * n; k = k * 2) { \n      int rank = 0; \n      int prev_rank = sufs[0].rank[0];\n      sufs[0].rank[0] = rank;\n      ind[sufs[0].idx] = 0;\n      for (int i = 1; i < n; i++) {\n        if (sufs[i].rank[0] == prev_rank && sufs[i].rank[1] == sufs[i - 1].rank[1]) { \n          prev_rank = sufs[i].rank[0]; \n          sufs[i].rank[0] = rank; \n        } else {\n          prev_rank = sufs[i].rank[0]; \n          sufs[i].rank[0] = ++rank; \n        } \n        ind[sufs[i].idx] = i; \n      } \n      for (int i = 0; i < n; i++) { \n        int next = sufs[i].idx + k / 2; \n        sufs[i].rank[1] = (next < n) ? sufs[ind[next]].rank[0] : -1; \n      } \n      radix_sort(sufs);\n    } \n    vector <int> a(n);\n    for (int i = 0; i < n; i++) { \n      a[i] = sufs[i].idx; \n    }\n    return a; \n  } \n}\n\nusing suffix::suffix_array;\n
suffix_automaton=class suffix_automaton {\n public:\n  struct state {\n    int len;\n    int link;\n    int fpos;\n    map<char, int> next;\n  };\n\n  string str;\n  int n;\n  vector <state> st;\n  int size;\n  int last;\n  vector <bool> terminals;\n\n  suffix_automaton(const string &istr) {\n    str = istr + ...//'$' or istr (for min_shift;\n    n = istr.length();\n    st.resize(2 * n);\n    st[0].len = 0;\n    st[0].link = -1;\n    size++;\n    last = 0;\n  }\n\n  suffix_automaton() {\n\n  }\n\n  void add(char c) {\n    int cur = size++;\n    st[cur].len = st[last].len + 1;\n    st[cur].fpos = st[cur].len - 1;\n    int p = last;\n    while (p != -1 && !st[p].next.count(c)) {\n      st[p].next[c] = cur;\n      p = st[p].link;\n    }\n    if (p == -1) {\n      st[cur].link = 0;\n      st[cur].fpos = st[cur].len - 1;\n    } else {\n      int q = st[p].next[c];\n      if (st[p].len + 1 == st[q].len) {\n        st[cur].link = q;\n        st[cur].fpos = st[cur].len - 1;\n      } else {\n        int clone = size++;\n        st[clone].len = st[p].len + 1;\n        st[clone].next = st[q].next;\n        st[clone].link = st[q].link;\n        st[clone].fpos = st[q].fpos;\n        while (p != -1 && st[p].next[c] == q) {\n          st[p].next[c] = clone;\n          p = st[p].link;\n        }\n        st[q].link = st[cur].link = clone;\n      }\n    }\n    last = cur;\n  }\n\n  vector <int> topo_sort() {\n    vector <int> order;\n    vector <int> deg(last + 1, 0);\n    for (int u = 0; u < last + 1; u++) {\n      for (int ch = 0; ch <= 256; ch++) {\n        if (st[u].next.count(ch)) {\n          int v = st[u].next[ch];\n          deg[v]++;\n        } \n      } \n    }\n    queue <int> from;\n    for (int u = 0; u < last + 1; u++) {\n      if (deg[u] == 0) {\n        from.push(u);\n      } \n    } \n    while (!from.empty()) {\n      int u = from.front();\n      from.pop();\n      order.emplace_back(u);\n      for (int ch = 0; ch <= 256; ch++) {\n        if (st[u].next.count(ch)) {\n          int v = st[u].next[ch];\n          if (deg[v] == 1) {\n            from.push_back(v);\n          }\n          deg[v]--;\n        } \n      } \n    }\n    return order;\n  } \n  \n  void build() {\n    for (char ch : str) {\n      add(ch);\n    } \n    terminals.resize(last + 1);\n    fill(terminals.begin(), terminals.end(), false);\n    int p = last;\n    while(p > 0) {\n      terminals[p] = true;  \n      p = st[p].link;\n    }\n  }\n\n  vector <int> dp;\n  int different() {\n    dp.resize(last + 1);\n    fill(dp.begin(), dp.end(), -1);\n    auto Dfs = [&](auto Self, int u) {\n      if (dp[u] != -1) return dp[u];\n      int cnt = 0;\n      for (int ch = 0; ch <= 256; ch++) {\n        if (st[u].next.count(ch)) {\n          cnt += Self(Self, st[u].next[ch]);\n        } \n      } \n      return dp[u] = cnt + 1;\n    };\n\n    int ret = 0;\n    for (int ch = 0; ch <= 256; ch++) {\n      if (st[0].next.count(ch)) {\n        ret += Dfs(Dfs, st[0].next[ch]);\n      }\n    }     \n    return ret;\n  }\n\n  int length_sum() {\n    different();\n\n    vector <int> ans(last + 1, -1);\n    auto Dfs = [&](auto Self, int u) {\n      if (ans[u] != -1) return ans[u];\n      int cnt = 0;\n      for (int ch = 0; ch <= 256; ch++) {\n        if (st[u].next.count(ch)) {\n          cnt += Self(Self, st[u].next[ch]) + dp[st[u].next[ch]];\n        } \n      } \n      return ans[u] = cnt;\n    };\n\n    int ret = 0;\n    for (int ch = 0; ch <= 256; ch++) {\n      if (st[0].next.count(ch)) {\n        ret += Dfs(Dfs, st[0].next[ch]);\n      }\n    }     \n    return ret;\n  } \n\n  string kthlex(int k) {\n    string ans;\n    int path = 0;\n    bool found = false;\n    auto Dfs = [&](auto Self, int u) {\n      for (int ch = 0; ch <= 256; ch++) {\n        if (st[u].next.count(ch)) {\n          path++;\n          if (path == k) {\n            found = true;            \n            ans.push_back(ch);\n            return;\n          }\n          Self(Self, st[u].next[ch]);\n          if (path == k) { \n            ans.push_back(ch);\n            return;\n          }\n        } \n      }\n    }\n\n    for (int ch = 0; ch <= 256; ch++) {\n      if (st[0].next.count(ch)) {\n        Dfs(Dfs, st[0].next[ch]);\n        if (found) break;\n      }\n    }\n    return ans;\n  }\n\n  //..minimum shift to obtain smallest (lexico)\n  int min_shift() {\n    int t = n / 2;\n    int tp = 0;\n    bool found = false;\n    auto Dfs = [&](auto Self, int u) {\n      for (int ch = 0; ch <= 256; ch++) {\n        if (st[u].next.count(ch)) {\n          tp++;\n          if (tp == t) {\n            found = true;\n            //..cout << st[u].fpos - t + 2 << endl;\n            break;\n          }\n          Self(Self, st[u].next[ch]);\n          if (found) break;\n        } \n      }\n    }\n\n    for (int ch = 0; ch <= 256; ch++) {\n      if (st[0].next.count(ch)) {\n        Dfs(Dfs, st[0].next[ch]);\n        if (found) break;\n      }\n    }\n  } \n\n  bool occurs(const string &pat) {\n    int pos = 0;\n    for (char c : pat) {\n      int found = st[pos].next.count[c];\n      if (!found) return false;\n      pos = st[pos].next[c];\n    } \n    return true;\n  }\n  \n  //..contruct using suffix_automaton st();\n  string lcs(string s, string t) {\n    str = s;\n    n = s.length();\n    st.resize(2 * n);\n    st[0].len = 0;\n    st[0].link = -1;\n    size++;\n    last = 0;\n    \n    int v = 0, l = 0,\n    int best = 0, bestpos = 0;\n    for (int i = 0; i < (int)t.length(); i++) {\n      while (v && !st[v].next.count(t[i])) {\n        v = st[v].link;\n        l = st[v].len;\n      }\n      if (st[v].next.count(t[i])) {\n        v = st[v].next[t[i]];\n        ++l;\n      }\n      if (l > best) {\n        best = l;\n        bestpos = i;\n      }\n    }\n    return t.substr(bestpos - best + 1, best);\n  } \n\n  vector <int> match(const string &pat) {\n    \n  } \n}; \n
swap=inline void swap(int& a, int& b) {\n  a = a ^ b;\n  b = a ^ b;\n  a = a ^ b;\n}\n
tarjan=template <typename T>\nvector<int> tarjan(const digraph<T> &g, int &cnt) {\n  vector <bool> seen(g.n, false);\n  vector <int> low(g.n, 0);\n  vector <int> dis(g.n, 0);\n  vector <bool> active(g.n, false);\n  stack <int> st;\n  vector <int> grp(g.n, -1);\n  int timer = 0;\n  cnt = 0;\n  \n  function<void(int)> dfs = [&](int u) {\n    seen[u] = true;\n    active[u] = true;\n    st.push(u);\n\n    dis[u] = low[u] = ++timer;\n    for (int id : g.g[u]) {\n      int v = g.edges[id].from ^ g.edges[id].to ^ u;\n      if (!seen[v]) {\n        dfs(v);\n        low[u] = min(low[u], low[v]);\n      } else if (active[v]) {\n        low[u] = min(low[u], dis[v]);\n      } \n    }\n        \n    if (low[u] == dis[u]) {\n      //..find SCC\n      while (st.top() != u) {\n        int v = st.top();\n        grp[v] = cnt;\n        active[v] = false;\n        st.pop();\n      } \n      int v = st.top();\n      grp[v] = cnt;\n      active[v] = false;\n      st.pop();\n      cnt++;\n    }\n  };  \n\n  for (int i = 0; i < g.n; i++) {\n    if (!seen[i]) {\n      dfs(i);\n    }\n  }\n  return grp;\n  //.. grp[i] <= grp[j] for every edge i -> j\n}\n
template=:insert\n/**\n *    author:  math2do\n *    created: 19.05.2020 10:20:29 IST\n**/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n\n  return 0;\n}\n.\n
test=@echo off\nfor /l %%x in (1, 1, 10) do (\n  echo test case %%x ... ??\n  gen > sol.in\n  sol < sol.in > sol.out\n  foo < sol.in > foo.out\n\n  fc sol.out foo.out /N > comp.out || exit /b\n  echo test case %%x passed\n  echo:\n  echo:\n)\necho all tests passed\n
tester=@echo off\nfor /l %%x in (1, 1, 10) do (\n  echo test case %%x ... ??\n  gen > sol.in\n  sol < sol.in > sol.out\n  foo < sol.in > foo.out\n\n  fc sol.out foo.out /N > comp.out || exit /b\n  echo test case %%x passed\n  echo:\n  echo:\n)\necho all tests passed\n
tick=inline double tick() {\n  static clock_t oldtick;\n  clock_t newtick = clock();\n  double diff = 1.0 * (newtick - oldtick) / CLOCKS_PER_SEC;\n  oldtick = newtick;\n  return diff;\n}\n
toposort=/*\n//..Mine\nusing DFS to find topological sorting : dfs_toposort\nusing Kahn's algorithm for topological sorting : kahn_toposort\n*/\ntemplate <typename T>\nvector<int> find_toposort(const digraph<T> &g) {\n  vector<int> deg(g.n, 0);\n  for (int id = 0; id < (int) g.edges.size(); id++) {\n    deg[g.edges[id].to]++;\n  }\n  vector<int> x;\n  for (int i = 0; i < g.n; i++) {\n    if (deg[i] == 0) {\n      x.push_back(i);\n    }\n  }\n  for (int ptr = 0; ptr < (int) x.size(); ptr++) {\n    int i = x[ptr];\n    for (int id : g.g[i]) {\n      auto &e = g.edges[id];\n      int to = e.to;\n      if (--deg[to] == 0) {\n        x.push_back(to);\n      }\n    }\n  }\n  if ((int) x.size() != g.n) {\n    return vector<int>();\n  }\n  return x;\n}\n
treap=mt19937 rng((unsigned int) chrono::steady_clock::now().time_since_epoch().count());\n \nclass node {\n  public:\n  int id;\n  node* l;\n  node* r;\n  node* p;\n  bool rev;\n  int sz;\n  // declare extra variables:\n  int P;\n \n  node(int _id) {\n    id = _id;\n    l = r = p = NULL;\n    rev = false;\n    sz = 1;\n    // init extra variables:\n    P = rng();\n  }\n \n  void unsafe_reverse() {\n    rev ^= 1;\n    swap(l, r);\n    pull();\n  }\n \n  // apply changes:\n  void unsafe_apply() {\n    \n  }\n \n  void push() {\n    if (rev) {\n      if (l != NULL) {\n        l->unsafe_reverse();\n      }\n      if (r != NULL) {\n        r->unsafe_reverse();\n      }\n      rev = 0;\n    }\n    // now push everything else:\n \n  }\n \n  void pull() {\n    sz = 1;\n    // now init from self:\n \n    if (l != NULL) {\n      l->p = this;\n      sz += l->sz;\n      // now pull from l:\n \n    }\n    if (r != NULL) {\n      r->p = this;\n      sz += r->sz;\n      // now pull from r:\n \n    }\n  }\n};\n \nvoid debug_node(node* v, string pref = "") {\n  #ifdef LOCAL\n    if (v != NULL) {\n      debug_node(v->r, pref + " ");\n      cerr << pref << "-" << " " << v->id << '\n';\n      debug_node(v->l, pref + " ");\n    } else {\n      cerr << pref << "-" << " " << "NULL" << '\n';\n    }\n  #endif\n}\n \nnamespace treap {\n  pair<node*,int> find(node* v, const function<int(node*)> &go_to) {\n    // go_to returns: 0 -- found; -1 -- go left; 1 -- go right\n    // find returns the last vertex on the descent and its go_to\n    if (v == NULL) {\n      return {NULL, 0};\n    }\n    int dir;\n    while (true) {\n      v->push();\n      dir = go_to(v);\n      if (dir == 0) {\n        break;\n      }\n      node* u = (dir == -1 ? v->l : v->r);\n      if (u == NULL) {\n        break;\n      }\n      v = u;\n    }\n    return {v, dir};\n  }\n \n  node* get_leftmost(node* v) {\n    return find(v, [&](node*) { return -1; }).first;\n  }\n \n  node* get_rightmost(node* v) {\n    return find(v, [&](node*) { return 1; }).first;\n  }\n \n  node* get_kth(node* v, int k) { // 0-indexed\n    pair<node*,int> p = find(v, [&](node* u) {\n      if (u->l != NULL) {\n        if (u->l->sz > k) {\n          return -1;\n        }\n        k -= u->l->sz;\n      }\n      if (k == 0) {\n        return 0;\n      }\n      k--;\n      return 1;\n    });\n    return (p.second == 0 ? p.first : NULL);\n  }\n \n  int get_position(node* v) { // 0-indexed\n    int k = (v->l != NULL ? v->l->sz : 0);\n    while (v->p != NULL) {\n      if (v == v->p->r) {\n        k++;\n        if (v->p->l != NULL) {\n          k += v->p->l->sz;\n        }\n      }\n      v = v->p;\n    }\n    return k;\n  }\n \n  node* get_bst_root(node* v) {\n    while (v->p != NULL) {\n      v = v->p;\n    }\n    return v;\n  }\n \n  pair<node*,node*> split(node* v, const function<bool(node*)> &is_right) {\n    if (v == NULL) {\n      return {NULL, NULL};\n    }\n    v->push();\n    if (is_right(v)) {\n      pair<node*,node*> p = split(v->l, is_right);\n      if (p.first != NULL) {\n        p.first->p = NULL;\n      }\n      v->l = p.second;\n      v->pull();\n      return {p.first, v};\n    } else {\n      pair<node*,node*> p = split(v->r, is_right);\n      v->r = p.first;\n      if (p.second != NULL) {\n        p.second->p = NULL;\n      }\n      v->pull();\n      return {v, p.second};\n    }\n  }\n \n  pair<node*,node*> split_leftmost_k(node* v, int k) {\n    return split(v, [&](node* u) {\n      int left_and_me = (u->l != NULL ? u->l->sz : 0) + 1;\n      if (k >= left_and_me) {\n        k -= left_and_me;\n        return false;\n      }\n      return true;\n    });\n  }\n \n  node* merge(node* v, node* u) {\n    if (v == NULL) {\n      return u;\n    }\n    if (u == NULL) {\n      return v;\n    }\n    if (v->P > u->P) {\n//    if (rng() % (v->sz + u->sz) < (unsigned int) v->sz) {\n      v->push();\n      v->r = merge(v->r, u);\n      v->pull();\n      return v;\n    } else {\n      u->push();\n      u->l = merge(v, u->l);\n      u->pull();\n      return u;\n    }\n  }\n \n  int count_left(node* v, const function<bool(node*)> &is_right) {\n    if (v == NULL) {\n      return 0;\n    }\n    v->push();\n    if (is_right(v)) {\n      return count_left(v->l, is_right);\n    }\n    return (v->l != NULL ? v->l->sz : 0) + 1 + count_left(v->r, is_right);\n  }\n \n  node* add(node* r, node* v, const function<bool(node*)> &go_left) {\n    pair<node*,node*> p = split(r, go_left);\n    return merge(p.first, merge(v, p.second));\n  }\n \n  node* remove(node* v) { // returns the new root\n    v->push();\n    node* x = v->l;\n    node* y = v->r;\n    node* p = v->p;\n    v->l = v->r = v->p = NULL;\n    v->push();\n    v->pull(); // now v might be reusable...\n    node* z = merge(x, y);\n    if (p == NULL) {\n      if (z != NULL) {\n        z->p = NULL;\n      }\n      return z;\n    }\n    if (p->l == v) {\n      p->l = z;\n    }\n    if (p->r == v) {\n      p->r = z;\n    }\n    while (true) {\n      p->push();\n      p->pull();\n      if (p->p == NULL) {\n        break;\n      }\n      p = p->p;\n    }\n    return p;\n  }\n \n  node* next(node* v) {\n    if (v->r == NULL) {\n      while (v->p != NULL && v->p->r == v) {\n        v = v->p;\n      }\n      return v->p;\n    }\n    v->push();\n    v = v->r;\n    while (v->l != NULL) {\n      v->push();\n      v = v->l;\n    }\n    return v;\n  }\n \n  node* prev(node* v) {\n    if (v->l == NULL) {\n      while (v->p != NULL && v->p->l == v) {\n        v = v->p;\n      }\n      return v->p;\n    }\n    v->push();\n    v = v->l;\n    while (v->r != NULL) {\n      v->push();\n      v = v->r;\n    }\n    return v;\n  }\n \n  int get_size(node* v) {\n    return (v != NULL ? v->sz : 0);\n  }\n \n  template<typename... T>\n  void apply(node* v, T... args) {\n    v->unsafe_apply(args...);\n  }\n \n  void reverse(node* v) {\n    v->unsafe_reverse();\n  }\n}\n \nusing namespace treap;\n
trie=template <bool child_cnt_matter>\nclass trie {\n public:\n  using pbb = pair <bool, bool>;\n  static constexpr int size = ...\n  inline int hash(char ch) { \n    return ch - ...; \n  }\n  struct Node {\n    bool end;\n    int all;\n    int end_cnt;\n    vector <Node*> c;\n    vector <int> cnt;\n    Node() : end(false), all(0), end_cnt(0) {\n      c.resize(size);\n      cnt.resize(size);\n      for (int i = 0; i < size; i++) {\n        c[i] = NULL;\n        cnt[i] = 0;\n      } \n    } \n  };\n\n  string sub;\n  void Dfs(Node* node, int depth) {\n    for (int i = 0; i < size; i++) {\n      if (node->c[i] != NULL) {\n        sub.push_back((char) (i + '...'));\n        cerr << sub << endl;\n        Dfs(node->c[i], depth + 1);\n        sub.pop_back();\n      } \n    }\n    ...int from = node->end_cnt + (node->all - used);\n    ...int many = from / k;\n    ...int rem = from % k;\n    ...ans += depth * many;\n    cerr << "node : " << sub << endl;\n    cerr << "depth : " << depth << endl;\n    cerr << "ends here : " << node->end_cnt << endl;\n    cerr << "passes through : " << node->all << endl;\n  } \n\n  void solve() {\n    for (int i = 0; i < size; i++) {\n      if (root->c[i] != NULL) {\n        sub.push_back((char) (i + '...'));\n        cerr << sub << endl;\n        Dfs(root->c[i], 1);\n        sub.pop_back();\n      }\n    }\n  }\n  \n  bool insert(Node* node, const string &str, int idx) {\n    int len = str.length();\n    if (idx == len) {\n      if (node->end) {\n        //..handle no duplicates by returning false\n        ...\n      }\n      node->end_cnt++;\n      node->end = true;\n      return true;\n    }\n    int pos = hash(str[idx]);\n    Node *temp = node->c[pos];\n    if (temp == NULL) {\n      temp = new Node();\n      node->c[pos] = temp;\n    }\n    bool res = insert(temp, str, idx + 1);\n    if (res == true) {\n      node->cnt[pos]++;\n      node->all++;\n    }\n    return res;\n  } \n\n  bool insert(const string &str) {\n    if (child_cnt_matter) { \n      bool res = insert(root, str, 0);\n      return res;\n    }\n\n    //..insertion with duplicates\n    Node* crawl = root;\n    int len = str.length();\n    for (int idx = 0; idx < len; idx++) {\n      int pos = hash(str[idx]);\n      if (!crawl->c[pos]) {\n        crawl->c[pos] = new Node();\n      }\n      crawl->cnt[pos]++;\n      crawl->all++;\n      crawl = crawl->c[pos];\n    }\n    crawl->end_cnt++;\n    crawl->end = true;\n    return true;\n  }\n  bool search(const string &str) {\n    Node* crawl = root;\n    int len = str.length();\n    for (int idx = 0; idx < len; idx++) {\n      int pos = hash(str[idx]);\n      if (!crawl->c[pos]) {\n        return false;\n      }\n      crawl = crawl->c[pos];\n    }\n    if (crawl->end) return true;\n    return false;\n  }\n\n  //..first = was present, second = is child subtree completely removed\n  pbb remove(Node* node, const string &str, int idx) {\n    int len = str.length();\n    if (node == NULL) return {false, false};\n    if (idx == len) {\n      if (!node->end) return {false, false};\n      if (node->all == 0) {\n        delete node;\n        return {true, true};\n      }\n      node->end_cnt--;     // deleting only one of same words\n      node->end_cnt = 0 .. // deleting all same words\n      if (node->end_cnt == 0) {\n        node->end = false;\n      }\n      return {true, false};\n    }\n\n    int pos = hash(str[idx]);\n    Node* temp = node->c[pos];\n    if (temp == NULL) return {false, false};\n    pbb res = remove(temp, str, idx + 1);\n    if (res.first) {\n      if (res.second) {\n        node->c[pos] = NULL;\n      }\n      node->cnt[pos]--;\n      node->all--;\n      if (node->all == 0) {\n        delete node;\n        return {true, true};\n      }\n      return {true, false};\n    }\n    return res;\n  }\n\n  bool remove(const string& str) {\n    pbb res = remove(root, str, 0);\n    return res.first;\n  } \n \n  Node* root;\n  trie() {  this->root = new Node(); }\n};\n
turn=const int L = -1;\nconst int S = 0;\nconst int R = 1; \nint turn(const point &p, const point &q, const point &r) { \n  int val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y); \n  if (val == 0) return S;\n  return (val > 0) ? R : L;\n}\n
twosat=class twosat {\n public:\n  digraph<int> g;\n  int n;\n\n  twosat(int _n) : g(digraph<int>(2 * _n)), n(_n) {\n  }\n\n  // (v[x] == value_x)\n  inline void add(int x, int value_x) {\n    assert(0 <= x && x < n);\n    assert(0 <= value_x && value_x <= 1);\n    g.add(2 * x + (value_x ^ 1), 2 * x + value_x);\n  }\n  \n  // (v[x] == value_x || v[y] == value_y)\n  inline void add(int x, int value_x, int y, int value_y) {\n    assert(0 <= x && x < n && 0 <= y && y < n);\n    assert(0 <= value_x && value_x <= 1 && 0 <= value_y && value_y <= 1);\n    g.add(2 * x + (value_x ^ 1), 2 * y + value_y);\n    g.add(2 * y + (value_y ^ 1), 2 * x + value_x);\n  }\n\n  inline vector<int> solve() {\n    int cnt;\n    vector<int> c = find_scc(g, cnt);\n    vector<int> res(n);\n    for (int i = 0; i < n; i++) {\n      if (c[2 * i] == c[2 * i + 1]) {\n        return vector<int>();\n      }\n      res[i] = (c[2 * i] < c[2 * i + 1]);\n    }\n    return res;\n  }\n};\n
u128=long long M = 1LL << 50; \nstruct u128 {\n  long long lo, hi;\n  long double val() {\n    return (long double) M * hi + lo;\n  }\n};\n\nu128 operator + (const u128 &a, const u128 &b) {\n  return u128{(a.lo + b.lo) & (M - 1), a.hi + b.hi + ((a.lo + b.lo) >> 50)};\n}\n\nu128 operator - (const u128 &a, const u128 &b) {\n  if (a.lo >= b.lo) return u128{a.lo - b.lo, a.hi - b.hi};\n  else return u128{a.lo - b.lo + M, a.hi - b.hi - 1};\n}\n
ull=using ull = unsigned long long int;\n
undigraph=template <typename T>\nclass undigraph : public graph<T> {\n public:\n  using graph<T>::edges;\n  using graph<T>::g;\n  using graph<T>::n;\n \n  undigraph(int _n) : graph<T>(_n) {\n  }\n \n  int add(int from, int to, T cost = 1) {\n    assert(0 <= from && from < n && 0 <= to && to < n);\n    int id = (int) edges.size();\n    g[from].push_back(id);\n    g[to].push_back(id);\n    edges.push_back({from, to, cost});\n    return id;\n  }\n};\n
union=int klee(const vector<pair<int, int>> &a) {\n  int n = a.size();\n  vector<pair<int, bool>> x(n * 2);\n  for (int i = 0; i < n; i++) {\n    x[i * 2] = {a[i].first, false};\n    x[i * 2 + 1] = {a[i].second, true};\n  }\n\n  sort(x.begin(), x.end());\n\n  int result = 0;\n  int cnt = 0;\n  for (int i = 0; i < n * 2; i++) {\n    if (i > 0 && x[i].first > x[i - 1].first && cnt > 0) {\n      result += x[i].first - x[i - 1].first;\n    }\n\n    if (x[i].second) cnt--;\n    else cnt++;\n  }\n  return result;\n}\n
unique=template <typename T>\ninline void unique(vector <T> &arr) {\n  auto it = unique(arr.begin(), arr.end(), [&](const T &a, const T &b) -> bool {\n    return a == b;  \n  });\n  arr.resize(it - arr.begin());\n} \n
upper_bound=template <typename T>\nint upper_bound(vector <T> arr, T x) {\n  int n = arr.size();\n  int l = 0;\n  int h = n; // Not n - 1\n  while (l < h) {\n    int mid = (l + h) / 2;\n    if (x >= arr[mid]) {\n      l = mid + 1;\n    } else {\n      h = mid;\n    }\n  }\n  return l;\n  //returns position of upper_bound\n}\n
vec=template <typename T>\nistream &operator>>(istream &is, vector <T> &arr) {\n  for (T &val : arr) is >> val;\n  return is;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &os, vector <T> &arr) {\n  for (T &val : arr) os << val << ' ';\n  return os;\n}\n
window=//..using priority_queue\nvector<int> slidingWindow(const vector<int> &arr, int k) {\n  priority_queue <pair <int, int>> pq;\n  int n = arr.size();\n  for (int i = 0; i < k; i++) {\n    pq.push(make_pair(arr[i], i));\n  }\n  pair <int, int> pr = pq.top();\n  vector <int> ans;\n  ans.push_back(pr.first);\n  \n  for (int i = k; i < n; i++) {\n    pq.push(make_pair(arr[i], i));\n\n    while (true) {\n      pair <int, int> pr = pq.top();\n      if (pr.second <= i - k) {\n        pq.pop();\n        continue;\n      }\n      ans.push_back(pr.first);\n      break;\n    }\n  }\n  return ans;\n}\n\n//..using double-ended queue\nvector<int> slidingWindow(const vector<int> &arr, int k) {\n  int n = arr.size();\n  list <int> dq;\n  vector <int> ans;\n  for (int i = 0; i < k; i++) {\n    while (!dq.empty() && arr[dq.back()] < arr[i]) {\n      dq.pop_back();\n    }\n    dq.push_back(i);\n  }\n  for (int i = k; i < n; i++) {\n    ans.push_back(arr[dq.front()]);\n    if (dq.front() <= i - k) dq.pop_front();\n    while (!dq.empty() && arr[dq.back()] < arr[i]) {\n      dq.pop_back();\n    }\n    dq.push_back(i);\n  }\n  ans.push_back(arr[dq.front()]);\n  return ans;\n}\n
z=template <typename T>\nvector<int> z_function(int n, const T &s) {\n  vector<int> z(n, n);\n  int l = 0, r = 0;\n  for (int i = 1; i < n; i++) {\n    z[i] = (i > r ? 0 : min(r - i + 1, z[i - l]));\n    while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {\n      z[i]++;\n    }\n    if (i + z[i] - 1 > r) {\n      l = i;\n      r = i + z[i] - 1;\n    }\n  }\n  return z;\n  //..z[i] = longest suffix starting at i that is also a prefix starting at 0\n}\n\ntemplate <typename T>\nvector<int> z_function(const T &s) {\n  return z_function((int) s.size(), s);\n}\n\n//Mine\n//..kshf.....l....i........h\nvector <int> buildZ_array(const string& pat, const string &txt) {\n  string str = pat + "$" + txt;\n  int len = str.length();\n  vector <int> z(len, 0);\n  int l = 0, h = 0;\n  for (int i = 1; i < len; i++) {\n    if (i > h) {\n      l = h = i;\n      while (h < len && str[h] == str[h - l]) {\n        h++;\n      }\n      h--; \n      z[i] = h - l + 1;\n    } else {\n      int look = i - l;\n      if (z[look] < h - i + 1) {\n        z[i] = z[look];\n      } else {\n        l = i;\n        while (h < len && str[h] == str[h - l]) {\n          h++;\n        }\n        h--; \n        z[i] = h - l + 1;\n      } \n    } \n  } \n  return z;\n  //..z[i] = longest suffix starting at i that is also a prefix\n} \n\nvector <int> Z_Algorithm(const string& pat, const string& txt) {\n  vector <int> z = buildZ_array(pat, txt);\n  vector <int> pos;\n  for (int i = 0; i < (int) z.size(); i++) {\n    if (z[i] == (int) pat.length()) {\n      int idx = i - pat.length() - 1;\n      pos.emplace_back(idx);\n    } \n  }\n \n  return pos;\n  //..starting indices of txt where matching starts\n} \n


[Java]
if=if (%cursor%)%block_cursor%
else=else%block_cursor%
for=for (int i = 0; i < %cursor%; i++)%brace_open%\n%brace_close%
while=while (%cursor%)%block_cursor%
do=do\n{\n\t%cursor%\n} while (%cursor%)\n
switch=switch (%cursor%)%brace_open%case %cursor%:\n\t\t%cursor%\n\t\tbreak;\n\tdefault:\n\t\t%cursor%\n%brace_close%
try=try%block%\ncatch (%cursor%)%block_cursor%

[PHP]
if=if (%cursor%)%block_cursor%
else=else%block_cursor%
for=for ($i = 0; $i < %cursor%; $i++)%brace_open%\n%brace_close%
while=while (%cursor%)%block_cursor%
do=do\n{\n\t%cursor%\n} while (%cursor%)\n
switch=switch (%cursor%)%brace_open%case %cursor%:\n\t\t%cursor%\n\t\tbreak;\n\tdefault:\n\t\t%cursor%\n%brace_close%
try=try%block%\ncatch (%cursor%)%block_cursor%

[Javascript]
if=if (%cursor%)%block_cursor%
else=else%block_cursor%
for=for (i = 0; i < %cursor%; i++)%block_cursor%
while=while (%cursor%)%block_cursor%
do=do\n{\n\t%cursor%\n} while (%cursor%)\n
switch=switch (%cursor%)%brace_open%case %cursor%:\n\t\t%cursor%\n\t\tbreak;\n\tdefault:\n\t\t%cursor%\n%brace_close%
try=try%block%\ncatch (%cursor%)%block_cursor%

[C#]
if=if (%cursor%)%block_cursor%
else=else%block_cursor%
for=for (i = 0; i < %cursor%; i++)%block_cursor%
while=while (%cursor%)%block_cursor%
do=do\n{\n\t%cursor%\n} while (%cursor%)\n
switch=switch (%cursor%)%brace_open%case %cursor%:\n\t\t%cursor%\n\t\tbreak;\n\tdefault:\n\t\t%cursor%\n%brace_close%
try=try%block%\ncatch (%cursor%)%block_cursor%

[Vala]
if=if (%cursor%)%block_cursor%
else=else%block_cursor%
for=for (i = 0; i < %cursor%; i++)%block_cursor%
while=while (%cursor%)%block_cursor%
do=do\n{\n\t%cursor%\n} while (%cursor%)\n
switch=switch (%cursor%)%brace_open%case %cursor%:\n\t\t%cursor%\n\t\tbreak;\n\tdefault:\n\t\t%cursor%\n%brace_close%
try=try%block%\ncatch (%cursor%)%block_cursor%

[ActionScript]
if=if (%cursor%)%block_cursor%
else=else%block_cursor%
for=for (i = 0; i < %cursor%; i++)%block_cursor%
while=while (%cursor%)%block_cursor%
do=do\n{\n\t%cursor%\n} while (%cursor%)\n
switch=switch (%cursor%)%brace_open%case %cursor%:\n\t\t%cursor%\n\t\tbreak;\n\tdefault:\n\t\t%cursor%\n%brace_close%
try=try%block%\ncatch (%cursor%)%block_cursor%

[Python]
for=for i in xrange(%cursor%):\n\t
if=if %cursor%:\n\t
elif=elif %cursor%:\n\t
else=else:\n\t
while=while %cursor%:\n\t
try=try:\n\t%cursor%\nexcept Exception, ex:\n\t
with=with %cursor%:\n\t
def=def %cursor% (%cursor%):\n\t""" Function doc """\n\t
class=class %cursor%:\n\t""" Class doc """\n\t\n\tdef __init__ (self):\n\t\t""" Class initialiser """\n\t\tpass

[Ferite]
iferr=iferr%block_cursor%fix%block%
monitor=monitor%block_cursor%handle%block%

[Haskell]

[HTML]
table=<table>\n\t<tr>\n\t\t<td>%cursor%</td>\n\t</tr>\n</table>

[Erlang]
case=case %cursor% of\n\t%cursor% -> %cursor%\nend
if=if\n\t%cursor% -> %cursor%\nend
begin=begin\n\t%cursor%\nend
fun=fun(%cursor%) ->\n\t%cursor%\nend
try=try %cursor% of\n\t%cursor% ->\n\t%cursor%\ncatch\n\t%cursor% ->\n\t%cursor%\nend
module=-module(%cursor%).
export=-export(%cursor%).
compile=-compile(%cursor%).
include=-include(%cursor%).
